# Install Movement CLI

⚙️

<aside>

- Prerequisites:
- Install [Rust Programming Language](https://www.rust-lang.org/tools/install)
- [Git](https://git-scm.com/downloads)
- [Cmake](https://cmake.org/download/)
- [LLVM](https://releases.llvm.org/)
- [libssl-dev](https://packages.ubuntu.com/jammy/libssl-dev) and
[libclang-dev](https://packages.ubuntu.com/jammy/libclang-dev)
</aside>
## Install Movement CLI via build from source (Linux/MacOS)
[See Details Here](https://docs.movementnetwork.xyz/devs/getstarted)
### Install
- Step 1: Clone the Aptos-core repo & go into the newly created directory
```rust
git clone https://github.com/movementlabsxyz/aptos-core.git && cd aptos-core
```
- Step 2: Install all prerequites using automatic script
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

1. Using the Automatic Script to install prerequisites
```bash
./scripts/dev_setup.sh
```
2. Update your current shell environment
```bash
source ~/.cargo/env
```
3. Ensure you have `cargo` installed by following this commands:
```bash
cargo --version
```
- Step 3: Build the CLI tool
```bash
cargo build -p movement
```

> The binary will be available at `target/debug/movement`
>
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Step 4: Move this executable to a place in your path
```bash
sudo cp target/debug/movement /opt/homebrew/bin/
```

### Check
```bash
movement --help
```
> Result
>
```bash
Command Line Interface (CLI) for developing and interacting with the Movement blockchain
Usage: movement <COMMAND>
Commands:
account Tool for interacting with accounts
config
Tool for interacting with configuration of the Movement CLI tool
genesis Tool for setting up an Movement chain Genesis transaction
governance Tool for on-chain governance
info
Show build information about the CLI
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

init
Tool to initialize current directory for the movement tool
key
Tool for generating, inspecting, and interacting with keys
move
Tool for Move smart contract related operations
multisig Tool for interacting with multisig accounts
node
Tool for operations related to nodes
stake
Tool for manipulating stake and stake pools
update
Update the CLI or other tools it depends on
help
Print this message or the help of the given subcommand(s)
Options:
-h, --help Print help
-V, --version Print version
```
## Build, Test & Call function on Movement
> Ensure you have the ClI installed
### Set up Development Environment
- Initialize your Aptos profile for package development and add Movement as a custom network
```bash
movement init --network custom --rest-url https://aptos.testnet.porto.movementlabs.xyz/v1
--faucet-url https://fund.testnet.porto.movementlabs.xyz
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

> Currently, we'll skip the faucet stage in the CLI and instead execute this through the UI via this
[link](https://faucet.movementnetwork.xyz/).
>
- Sucess Result:
```bash
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.porto.movementlabs.xyz/v1
Not configuring a faucet because --skip-faucet was provided
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or
keep one if present)]
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has
been initialized locally, but you must transfer coins to it to create the account onchain
--Movement CLI is now set up for account
0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 as profile
default!
See the account here:
https://explorer.aptoslabs.com/account/0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f7
0c789160a5829e73586?network=custom
Run `movement --help` for more information about commands
{
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

"Result": "Success"
}
```
- Here you need to pay attention to the Account that was created:
`0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586`
```bash
No key given, generating key...
Account 0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586 has
been initialized locally, but you must transfer coins to it to create the account onchain
```
After completing this process, a folder named `.movement` containing a `config.yaml` file will
appear in your directory. All the information you previously generated will be stored in this
`config.yaml` file.
### Faucet Move Token
To execute transactions on the Movement blockchain, you'll need Move Tokens to pay for
transaction fees. You can obtain free Move tokens from the faucet UI using this link:
- Use the address generated in the file `.movement/config.yaml`
![image.png](/content-images/install-movement-cli/image.png)
- Afterwards, you can verify your token balance using the following command:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```bash
movement account balance --account
0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586
```
- The result below confirms that you now possess 1 Move token
```json
{
"Result": [
{
"asset_type": "coin",
"coin_type": "0x1::aptos_coin::AptosCoin",
"balance": 100000000
}
]
}
```

### Initialize your Move project
You can easily initialize a default project source code using the following command:
```bash
movement move init --name hello_movement
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
After initializing the Move source code, your folder will contain the following files and directories:
```bash
├── .movement/config.yaml
├── Move.toml
├── scripts
├── sources
└── tests
```
The key file to pay attention to is Move.toml
```js
[package] # Includes packages metadata such as name version
name = "hello_movement"
version = "1.0.0"
authors = []
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
[dev-addresses]
# Multiline Style
[dependencies.AptosFramework]
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
```
You will copy and paste the previously generated account address into the [addresses] section
to publish your contract to that address.
```js
[addresses]
movement = "0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586"
```
### Implement Code
Create your `.move` contract file in the `/sources` folder.
```toml
├── .aptos/config.yaml
├── Move.toml
├── scripts
├── sources
│ └── hello_world.move
└── tests
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

> `/sources/hello_world.move`
>
```rust
module movement::hello_world {
use std::string::{String, utf8};
use std::debug::print;
struct MoveResource has key {
string: String
}
public entry fun create_first_resource(caller: &signer) {
let greeting: String = utf8(b"Hello World!!!");
print(&greeting);
move_to(caller, MoveResource {
string: greeting
});
}
#[test(caller = @0x1)]
fun test_create_first_resource(caller: &signer) {
create_first_resource(caller);
}
}
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Building & Testing Contact
```rust
movement move build
```
Result:
```json
{
"Result": [
"3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world",
]
}
```
- Testing:
```bash
movement move test --filter hello_world
```
Result:
```json
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Running Move unit tests
[debug] "Hello World!!!"
[ PASS ]
0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::te
st_create_first_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
}
```

### Publish Contract & Interact on Blockchain
You can deploy your contract (modules) to the Movement blockchain using the following
command:
```bash
movement move publish
```
Success Result
```bash
Transaction submitted:
https://explorer.aptoslabs.com/txn/0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57
e70d09f6d13a77f?network=devnet
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

{
"Result": {
"transaction_hash":
"0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f",
"gas_used": 7260,
"gas_unit_price": 100,
"sender": "122d28da2607724405a4691e35f7fad06667ec32229781f8994c70f24ec59c58",
"sequence_number": 0,
"success": true,
"timestamp_us": 1727944927400079,
"version": 84201807,
"vm_status": "Executed successfully"
}
}
```
You can use the `transaction hash` to search for your contract on the Movement explorer:
```json
"transaction_hash":
"0xe019cffa060c50e067fa0522199cc5f667bab840998a30c57e70d09f6d13a77f"
```
![image.png](/content-images/install-movement-cli/image%201.png)
Alternatively, you can search for the account you generated earlier to view the modules you
have deployed.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

![image.png](/content-images/install-movement-cli/image%202.png)
In each module, you can call the available functions to test or verify them directly through the
user interface.
![image.png](/content-images/install-movement-cli/image%203.png)
## Call function with Movement CLI
You can easily use the CLI to call functions on the blockchain after publishing, without needing
to access the explorer, by using the `movement move run` command
```json
movement move run --function-id
"<module_onwer_address>::<module_name>>::<function_name>" --args <type>:<value>
--sender-account <address_account>
```
In the case of the `hello_world` module, we can call it through the CLI as follows:
```json
movement move run
"0x3d4dd145c51722b2b236bf544a2f12718450f4e7ab4f70c789160a5829e73586::hello_world::c
reate_first_resource"
```
# Functions, view Functions & Visibility
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

## Function
### Overview
Function syntax in Move is shared between module functions and script functions. Functions
inside of modules are reusable, whereas script functions are only used once to invoke a
transaction.
### Declaring Address Variables
```rust
fun name(params: type): return_type {
todo!()
}
// example
fun plus(what_plus: u64): u64 {
let result = 0 + what_plus;
return result;
}
```
--## View Function

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### Definition
A view function is a function that retrieves data from the blockchain without making any
changes. It is used to read and display data stored on the blockchain.
### Importance
View functions are important in the Movement blockchain because:
- They allow external applications to access and display data on the blockchain without direct
access to the blockchain.
- They improve the efficiency and security of the blockchain network.
### Benefits
- Create a GET API structure to display complex states of smart contracts.
- Simplify the process of retrieving complex data, saving time and resources.
- Significantly improve the usability of the Aptos blockchain.
- Make the blockchain more accessible to developers.
### How to Use
Use the `#[view]` decorator to define a view function:
```rust
#[view]
public fun get_todos(todo_address: address): vector<String> acquires TodoStore {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

borrow_global<TodoStore>(todo_address).todos
}
```
### Advantages
- Retrieve complex states from smart contracts more efficiently.
- Define functions that return specific data from smart contracts.
- Provide a simple API for external invokers to retrieve data from the blockchain.
- Receive specific required data instead of the entire database with each query.
### Conclusion
Significantly improving its usability and accessibility. They help developers create more efficient
applications by simplifying the process of retrieving data from the blockchain.
--## Function Visibilities
### Private
- The functions can only be used within the module where they are defined.
- Think of them as "module-only" functions. No other module or script can access them.
```python
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

module movement::PrivModule {
fun pri_func(): u8 {
return 0;
}
}
module movement::PublModule {
fun other_func(): u8 {
// This will error
let result: u8 = movement::PrivModule::pri_func(); // Error
return result;
}
}
```
### Public
- The functions can be used by any other module or script.
- They are like "open to everyone" functions.
```rust
module movement::PrivModule {
use std::debug::print;
fun pri_func(): u8 {
return 0
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
fun call_public_func() {
let result = movement::PublModule::public_func();
print(&result);
}
#[test]
fun test_call_public_func() {
call_public_func();
}
}
module movement::PublModule {
public fun public_func(): u8 {
return 0
}
}
```
### Public(friend)
- The functions can be used by the module where they are defined and by specific modules
listed as "friends." - It’s like having "VIP access" that only selected friends can use these
functions.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
module movement::PrivModule {
use std::debug::print;
fun call_public_func() {
// This will error
let result = movement::PublModule::public_func(); // Error
// This will error
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid call to
// This will error
'(movement=0xDB8A45E0E06D2BD305CDB824FDA101CEC6A24721CB03188C5543A5E5A8
C3F3B0)::PublModule::public_func'
print(&result);
}
}
module movement::PublModule {
public(friend) fun public_func(): u8 {
return 0
}
}
```
To allow `PrivModule` to call `public(friend)` from within `PublModule`, we need to add
`PrivModule` to the friend list of `PublModule` by doing the following:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
module movement::PrivModule {
use std::debug::print;
fun call_public_func() {
let result = movement::PublModule::public_func();
print(&result);
}
#[test]
fun test_call_public_func() {
call_public_func();
}
}
module movement::PublModule {
friend movement::PrivModule;
public(friend) fun public_func(): u8 {
return 0
}
}
```
### Entry
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- These are special functions where the Move program starts running or where the user can call
into the contract.
- You can combine "entry" with "public" or "public(friend)" to specify who can initiate execution.
Example:
```rust
module movement::FunctionVisibilities {
use std::string::utf8;
use std::debug::print;
public(friend) entry fun internal_transfer() { // public friend entry
print(&utf8(b"internal transfer"));
}
public entry fun pub_transfer() { // public entry
print(&utf8(b"public transfer"));
}
entry fun transfer(){ // private entry
print(&utf8(b"transfer"));
}
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Movement CLI
```bash
movement move publish --named-addresses movement=default
```
- Result
```json
{
"Result": {
"transaction_hash":
"0x995bff9d25cbb2863b1171d097e3af93c2c1867b0325ceeb1bd3ec44c841270a",
"gas_used": 1280,
"gas_unit_price": 100,
"sender": "bcbcad47635cf19f831e82a0abd0775b4892cb79bb8600592a99e73c727f717c",
"sequence_number": 0,
"success": true,
"timestamp_us": 1726818525771069,
"version": 17512651,
"vm_status": "Executed successfully"
}
}
```
Call Entry Function
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```bash
movement move run --function-id 'default::FunctionVisibilities::internal_transfer'
movement move run --function-id 'default::FunctionVisibilities::pub_transfer'
movement move run --function-id 'default::FunctionVisibilities::transfer'
```
```json
{
"Result": {
"transaction_hash":
"0xdf1e9661d7408034273fa49a8cecb4ca7acc2656705b348e0aee76a2a4799ce7",
"gas_used": 3,
"gas_unit_price": 100,
"sender": "e084b2010bb36fb4802d2c8bad7c66ade3728b202a30e330e58cd1904d65a043",
"sequence_number": 2,
"success": true,
"timestamp_us": 1726819967229264,
"version": 2034,
"vm_status": "Executed successfully"
}
}
# Resources on Move & Ability of Resource
## Movement modules

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

In Move, code is structured into modules, which are then deployed on the Movement
blockchain. These modules serve as the building blocks of smart contracts, allowing users to
interact with them by executing their functions through transactions. Modules are bundled
together into packages, and when developers deploy their code, they upload an entire package
to the blockchain at once. This package can contain one or multiple modules. To keep things
straightforward in this course, we'll focus on working with a package that consists of just one
module.
```rust
module 0xAddress::module_name {
}
```
Every Move module is uniquely identified by combining its deployment address and module
name. The complete identifier is structured as `<address>::<module_name>`. Typically, the
module name follows `snake_case` convention. For demonstration purposes, we use 0xcafe as
the address in our examples. However, it's important to note that when you deploy a module to
the blockchain, you'll need to use an address for which you possess the private key. We'll
explore this concept in more detail that later.
## Resources & Struct Abilities
In Move, Resources are represented as structs if they have key attributes. All data is stored in
global storage. For now, take a look at the simple example below:
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

module 0xAddress::module_name {
// All structures that are saved to global storage must include the key attribute
struct ResourceName has key {
data: u64,
store_abilitiy: ResourceAbilities
}
// Value can be stored in global storage or other resouces
struct ResourceAbilities has key, store, copy, drop {
data: u64
}
}
```
- `key`: Value can be used as a key for global storage operations.
- `copy`: Value can be copied (or duplicated by value).
- `drop`: Value can be deleted when the scope ends.
- `store`: Value can be stored in global storage or other resources
## Initializing and Transferring Resources
Now that we have defined a Resource, we will define it as an NFT to demonstrate what you
have done. When initializing a Resource, you cannot initialize default values right from the start;
instead, you will do this through a function.
```rust
module 0xAddress::module_name {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

use std::signer;
// All structures that are saved to global storage must include the key attribute
struct ResourceName has key {
data: u64,
}
fun create_resource(owner: &signer, new_data: u64) {
move_to(owner, ResourceName{
data: new_data
});
}
}
```
All resources in Move need an address for storage; this address can be a user address or an
object address (which will be discussed later). The init_module function initializes a new
resource and then transfers it to the signer (this is a special data type in Move that will be
explained in more detail later). Essentially, it moves this resource to a specific address for
ownership and storage.
## Start Code
### Step 1: Initialize move file
Create a move file in the sources folder, and use the code above.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
module movement::movement_module {
use std::signer;
struct ResourceName has key {
data: u64
}
public entry fun create_resource(owner: &signer, new_data: u64) {
move_to(owner, ResourceName{
data: new_data
});
}
}
```
### Step 2: Configuration Move.toml
Edit the Move.toml file as shown below
```yaml
[package] # Includes packages metadata such as name version
name = "hello_blockchain" # Name of project
version = "1.0.0"
authors = []
# Optional
license = ""
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

[addresses]
movement = "0x{YOUR_ACCOUNT_ADDRESS}"
# movement = "0xefa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5"
[dev-addresses]
[dependencies.AptosFramework]
git = "<https://github.com/aptos-labs/aptos-core.git>"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
```
> Use `YOUR_ACCOUNT_ADDRESS` as the account to store modules, specifically the
MovementModule in the example above
>
### Step 3: Build the Contract
```bash
movement move build
```
```json
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

{
"Result": [
"efa4efe7f14204d86966070b5cc388498116bf6ef86485a54c3b5dae7502e0f5::movement_modul
e"
]
}
```
### Step 4: Publish & Create a Rosource
After completing the contract build and initializing the modules, you can use the CLI to call the
functions in the module as shown below with the structure
`address::module_name::function_name`
```bash
aptos move publish
```
```bash
aptos move run --function-id 'default::movement_module::create_resource' --args u64:50
```
# Conditionals & Loops
## Summary

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Conditionals in Move use `if-else` statements with boolean conditions and required curly
braces.
- Multiple conditions can be chained using `else if`.
- Move supports three types of loops: `while`, `for`, and infinite (`loop`).
- While loops execute code as long as a condition is true.
- For loops iterate over a range of values.
- Infinite loops use the `loop` keyword and continue until explicitly broken.
# Conditionals in Move
Conditionals are fundamental control structures in programming that allow you to execute
different code based on certain conditions. In move, the most common conditional structure is
the if-else statement.
## Basic Syntax
The basic syntax of an if-else statement in Move is as follows:
```rust
if (condition) {
// code to execute if condition is true
} else {
// code to execute if condition is false
}
```
## Key Points
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- The condition must be a boolean expression.
- Curly braces {} are required, even if the block contains only one line of code.
- The else block is optional.
## Multiple Conditions
You can chain multiple conditions using else if:
```rust
if (condition1) {
// code for condition1
} else if (condition2) {
// code for condition2
} else {
// code if no condition is true
}
```
# Loops
Loops are essential control structures in programming that allow you to repeat a block of code
multiple times. In Move, there are three main types of loops: while loops, for loops, and loop
(infinite loop).
## While Loops

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

While loops execute a block of code as long as a specified condition is true.
```rust
while (condition) {
// code to be executed
}
```
## For Loops
For loops are used to iterate over a range of values.
```rust
for (i in 1..n) {
// code to be executed
}
```
## Infinite Loops
The 'loop' keyword creates an infinite loop that continues until explicitly broken.
```rust
loop {
// code to be executed
if (condition) {
break;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
}
```
## Example: Sum of First N Natural Numbers
The code below demonstrates how to calculate the sum of the first N natural numbers using
different types of loops in Move:
```rust
module movement::loops {
use std::vector;
// Sum of first N natural numbers using while loop
fun sum_using_while(n: u64): u64 {
let sum = 0;
let i = 1;
while (i <= n) {
sum = sum + i;
i = i + 1;
};
sum
}
// Sum of first N natural numbers using for loop
fun sum_using_for(n: u64): u64 {
let sum = 0;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

for (i in 1..(n+1)) {
sum = sum + i;
};
sum
}
// Sum of first N natural numbers using infinite loop
fun sum_using_loop(n: u64): u64 {
let sum = 0;
let i = 1;
loop {
if (i > n) break;
sum = sum + i;
i = i + 1;
};
sum
}
// Sum of first N natural numbers using vector and fold
fun sum_using_vector(n: u64): u64 {
let numbers = vector::empty<u64>();
let i = 1;
while (i <= n) {
vector::push_back(&mut numbers, i);
i = i + 1;
};
vector::fold(numbers, 0, |acc, num| acc + num)
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
#[test_only]
use std::debug;
#[test]
fun test_sum_functions() {
let n = 10;
let expected_sum = 55; // Sum of 1 to 10
assert!(sum_using_while(n) == expected_sum, 0);
assert!(sum_using_for(n) == expected_sum, 1);
assert!(sum_using_loop(n) == expected_sum, 2);
assert!(sum_using_vector(n) == expected_sum, 3);
debug::print(&sum_using_while(n));
debug::print(&sum_using_for(n));
debug::print(&sum_using_loop(n));
debug::print(&sum_using_vector(n));
}
}
```
> Running test:
>
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

movement move test -f test_sum_functions
```
> Result:
>
```rust
Running Move unit tests
[debug] 55
[debug] 55
[debug] 55
[debug] 55
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::loops::test_sum
_functions
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
}
```
# Constants & Error Handling
## Key Takeaways
- Constants in Move provide immutable values with compile-time evaluation and memory
optimization.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Naming conventions for constants enhance code readability (e.g., uppercase for non-error
values, camel case with 'E' prefix for error codes).
- Error handling utilizes `abort` statements and `assert!` macros for precise control.
- Combining constants with error handling creates robust, self-documenting code.
- Advanced techniques include centralizing error codes in dedicated modules for improved
organization and reusability.
- Proper use of constants and error handling is crucial for building secure and maintainable
Move programs.
# Constants
## Overview
Constants in Move are a powerful way to define immutable values within a `module` or `script`.
They are declared using the `const` keyword and offer several advantages:
- Compile-time evaluation: The constant's value must be determinable at compilation, ensuring
efficiency.
- Memory optimization: Constants are stored directly in the compiled code, reducing runtime
memory usage.
- Value semantics: Each use of a constant creates a new copy, preserving data integrity across
different parts of your code.
By leveraging constants, developers can create more readable, maintainable, and performant
Move programs.
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

const <NAME>: <TYPE> = <EXPRESSION>;
```
## Naming Conventions
Naming conventions for constants in Move are designed to enhance code readability and
maintainability. Here are the key rules:
- Initial character: Constants must begin with an uppercase letter (A-Z).
- Subsequent characters: After the first letter, you can use:
- Uppercase letters (A-Z)
- Lowercase letters (a-z)
- Digits (0-9)
- Underscores (_)
This naming convention helps distinguish constants from other identifiers in your code, making it
easier to recognize and use them appropriately throughout your Move programs.
**Key Considerations for Constants in Move:**
- Type Restrictions: Constants are confined to fundamental data types such as `bool`, integer
variants (`u8` to `u256`), `address`, and `vector<u8>`.
- Naming Conventions:
- Error codes: Use upper camel case with an 'E' prefix (e.g., `EInsufficientFunds`)
- Non-error values: Employ upper snake case (e.g., `MAX_SUPPLY`)
- Scope Limitations: Constants are `module-specific` and cannot be declared as `public` or
accessed externally.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Visibility: The value of a constant is restricted to its defining module or script.
## Examples:
```rust
module movement::config {
const EOnlyAdmin: u64 = 1;
const ENotHavePermission: u64 = 2;
const VECTOR_U8: vector<u8> = b"hello";
}
```
# Error Handling
## Error Handling in Move
Move provides robust mechanisms for error handling, primarily through two key functions:
- **abort**: Immediately terminates execution with a specified error code
```rust
abort <error_code>; // error_code must be of type u64
```
- **assert!**: Evaluates a condition and aborts if it's false
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

assert!(<boolean_expression>, <error_code>)
```

These tools allow developers to implement precise error handling, enhancing the reliability and
debuggability of Move programs.
## Using in Real-World Projects
In real-world projects, error handling is frequently used. For large projects, we combine it with
constants to manage errors more optimally, as shown in the example above:
```rust
module movement::constants_error_handling_module {
const ENotHavePermission: u64 = 1;
const ENotEven: u64 = 2;
fun const_error(n: u64) {
if (n == 5) {
abort ENotHavePermission // throwing error as the given constant
}
}
fun is_even(num: u64) {
assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

#[test]
#[expected_failure(abort_code = 1)]
fun test_const_error() {
const_error(5);
}
#[test]
#[expected_failure(abort_code = 2)]
fun test_is_even_failed() {
is_even(5);
}
#[test]
fun test_is_even_success() {
is_even(4);
}
}
```
In the code above, we can see practical examples of error handling in Move using both the
`abort` statement and the `assert!` macro, combined with constant error codes. Let's break it
down:
### Abort Example
- The `ENotHavePermission` constant is defined with a value of 1, representing a specific error
condition.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- In the `const_error` function, there's a conditional check: if the input `n` equals 5, it triggers an
abort with the `ENotHavePermission` error code.
- The `abort` statement immediately halts the execution of the function and returns the specified
error code (1 in this case).
- A test function `test_const_error` is provided to verify this behavior. It's marked with
`#[expected_failure(abort_code = 1)]`, indicating that it's expected to fail with the specific abort
code 1.
### Assert Example
- The `ENotEven` constant is defined with a value of 2, representing another error condition.
- In the `is_even` function, the `assert!` macro is used to check if the input number is even.
- If the assertion fails (i.e., the number is odd), it aborts with the `ENotEven` error code.
- Two test functions are provided: `test_is_even_failed` expects failure with abort code 2, while
`test_is_even_success` expects successful execution.
This approach to error handling offers several benefits:
- Clear error identification: Using named constants for error codes improves code readability and
maintainability.
- Consistent error reporting: By centralizing error codes as constants, you ensure consistency
across your module.
- Testability: The `#[expected_failure]` attribute allows you to write tests that specifically check
for correct error handling.
- Flexibility: Developers can choose between `abort` for immediate termination or `assert!` for
condition-based checks.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

By combining constants with both the `abort` mechanism and `assert!` macro, Move developers
can create robust, self-documenting error handling systems that are easy to maintain, test, and
adapt to various scenarios.
# Error Handling Advanced
Note: Constants are `module-specific` and cannot be declared as `public` or accessed
externally.
In real-world projects, the number of error handling cases can be very large. Additionally, an
error may occur in multiple different modules. I have used functions to develop and optimize
error handling beyond Move's traditional methods. For example:
```rust
module movement::errors {
const ENotHavePermission: u64 = 1;
const ENotEven: u64 = 2;
public fun get_enot_have_permission(): u64 {
ENotHavePermission
}
public fun get_enot_even(): u64 {
ENotEven
}
}
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
module movement::constants_abort_error {
use movement::errors;
fun const_error(n: u64) {
if (n == 5) {
abort errors::get_enot_have_permission() // throwing error as the given constant
}
}
#[test]
#[expected_failure(abort_code = 1)]
fun test_const_error() {
const_error(5);
}
}
module movement::constants_assert_error {
use movement::errors;
fun is_even(num: u64) {
assert!(num % 2 == 0, errors::get_enot_even()); // throwing error as the given constant
}
#[test]
#[expected_failure(abort_code = 2)]
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

fun test_is_even_failed() {
is_even(5);
}
#[test]
fun test_is_even_success() {
is_even(4);
}
}
```
With this approach, you can separate error handling into a dedicated module, making it easier to
manage and resulting in cleaner code, as well as enabling reuse across different modules.
# Conclusion
In this comprehensive overview of constants and error handling in Move, we've explored several
key concepts:
- Constants provide immutable values, offering compile-time evaluation, memory optimization,
and value semantics.
- Proper naming conventions for constants enhance code readability and maintainability.
- Error handling in Move primarily relies on the `abort` statement and `assert!` macro.
- Combining constants with error handling creates a robust system for managing and reporting
errors.
- Advanced error handling techniques, such as centralizing error codes in a dedicated module,
can improve code organization and reusability.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

By mastering these concepts, developers can create more efficient, readable, and maintainable
Move programs. Constants and effective error handling are crucial for building robust smart
contracts and decentralized applications on blockchain platforms that support Move.
As the Move ecosystem continues to evolve, these fundamental practices will remain essential
for writing high-quality, secure code. Developers should strive to implement these patterns
consistently in their projects to ensure reliability and ease of maintenance in the long term.
# Generics Type & Phantom Type
## Generics in Move: Enhancing Code Flexibility and Reusability
Move's generics feature empowers developers to craft versatile code that adapts to various data
types, eliminating the need for type-specific implementations. This powerful concept, akin to
generics in languages like Rust or Java, enables the creation of flexible, widely applicable code
structures.
### Key Benefits of Generics
- Promotes code reusability across different data types
- Significantly reduces code duplication
- Enhances overall code maintainability and readability
- Facilitates the development of robust, type-safe abstractions
### Implementing Generics in Move

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

In Move, we typically refer to this concept as "generics" rather than type parameters and
arguments. Here's how to leverage this feature:
- Declaring Generic Types
- Use angle brackets <T> to define type parameters in function and struct signatures
- Example: struct Container<T> { item: T }
- Creating Generic Functions
- Place type parameters after the function name and before value parameters
- Example: public fun identity<T>(x: T): T { x }
- Utilize the type parameter T in parameter types, return types, and within the function body
By mastering generics, Move developers can create more efficient, flexible, and maintainable
code, elevating the quality of their blockchain applications.
### Generics Function
Example: In the code snippet below is a simple example to show the information of a token
created from the MoveToken struct.
```rust
module movement::generic_type {
use std::string::{String, utf8};
use std::debug::print;
use std::signer;
struct MoveToken has drop {
symbol: String,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

name: String,
decimal: u8,
total_supply: u128
}
fun show_token(token: MoveToken) {
print(&token);
}
#[test]
fun test_show_all() {
let token = MoveToken {
symbol: utf8(b"MOVE"),
name: utf8(b"Movement"),
decimal: 8,
total_supply: 1_000_000_000
};
show_token(token);
}
}
```
Let's imagine a scenario where your application accepts more than one Token for payment in its
functions. In this case, the code would be modified as follows.
```rust
module movement::generic_type {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

use std::string::{String, utf8};
use std::debug::print;
use std::signer;
struct MoveToken has drop {
symbol: String,
name: String,
decimal: u8,
total_supply: u128
}
struct MovementToken has drop {
symbol: String,
name: String,
decimal: u8,
total_supply: u128
}
fun show_token(token: MoveToken) {
print(&token);
}
fun show_movement_token(token: MovementToken) {
print(&token);
}
#[test]
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

fun test_show_all() {
let token = MoveToken {
symbol: utf8(b"MOVE"),
name: utf8(b"Movement"),
decimal: 8,
total_supply: 1_000_000_000
};
show_token(token);
let movetoken = MovementToken {
symbol: utf8(b"MOVEMOVE"),
name: utf8(b"Movement Tokens"),
decimal: 8,
total_supply: 1_000_000_000
};
show_movement_token(movetoken);
}
}
```
So if you have about 20 different tokens for payment, your code will be very long, so we will use
generic types to upgrade this code as shown below:
```rust
module movement::generic_type {
use std::string::{String, utf8};
use std::debug::print;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

use std::signer;
struct MoveToken has drop {
symbol: String,
name: String,
decimal: u8,
total_supply: u128
}
​
​
//a generic identity function that takes a value of any type and returns that value
unchanged
fun show_token<T: drop>(token: T) {
print(&token);
}
#[test]
fun test_show_all() {
let token = MoveToken {
symbol: utf8(b"MOVE"),
name: utf8(b"Movement"),
decimal: 8,
total_supply: 1_000_000_000
};
let movetoken = MoveToken {
symbol: utf8(b"MOVEMENT"),
name: utf8(b"Movement Tokens"),
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

decimal: 8,
total_supply: 1_000_000_000
};
show_token(token);
show_token(movetoken);
}
}
```
### Generics Structs
Type parameters for structures (structs) are placed after the struct name and can be used to
name the types of the fields.
```rust
struct Foo<T> has copy, drop { x: T }
struct Bar<T1, T2> has copy, drop {
x: T1,
y: vector<T2>,
}
```# Unit Test
Unit testing in Move introduces powerful annotations to enhance the testing process:
- `#[test]`: Designates a function as a test case
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- `#[test_only]`: Marks code for exclusive use in testing environments
- `#[expected_failure]`: Indicates a test that is anticipated to fail
These annotations revolutionize Move's testing capabilities:
- The `#[test]` annotation transforms functions into comprehensive test suites
- `#[test_only]` allows for the creation of modules, functions, or structures dedicated solely to
testing purposes, enhancing code organization
- With `#[expected_failure]`, developers can proactively identify and manage tests that are
designed to fail, improving overall test coverage and reliability
```rust
module movement::unit_testing {
use std::debug::print;
use std::signer;
const ENotHavePermission: u64 = 1;
const ENotEven: u64 = 2;
fun const_error(n: u64) {
if (n == 5) {
abort ENotHavePermission // throwing error as the given constant
}
}
fun is_even(num: u64) {
assert!(num % 2 == 0, ENotEven); // throwing error as the given constant
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
fun show_address(address: signer) {
print(&signer::address_of(&address))
}
#[test_only]
fun new_n(): u64 {
return 5
}
// This test function checks if const_error() correctly aborts with the expected error code
// when given the value 5. It uses #[expected_failure] to indicate that we expect this test to
fail.
#[test]
#[expected_failure(abort_code = 1)]
fun test_const_error() {
let new_n = new_n();
const_error(new_n);
}
// This test function verifies that is_even() correctly identifies odd numbers
// and aborts with the expected error code. We use #[expected_failure] here as well.
#[test]
#[expected_failure(abort_code = 2)]
fun test_is_even_failed() {
is_even(5);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
// This test function checks if is_even() correctly handles even numbers without aborting.
#[test]
fun test_is_even_success() {
is_even(4);
}
​
​
// This test function demonstrates how to use a custom signer in tests.
// It checks if show_address() correctly prints the signer's address.
#[test(myaccount = @0x1)]
fun test_show_address(myaccount: signer) {
show_address(myaccount);
}
}
```
There are multiple ways to run unit tests using the CLI. By utilizing the `--filter` option, you can
flexibly test with `module_name`, `function_name`, or `all`.
```rust
movement move test // Running all test function in source
movement move test --filter unit_testing // Running all test function in the module
movement move test --filter test_show_address // Running specific test function
```
```bash
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Running Move unit tests
[ PASS ] constants_error_handling_module::test_const_error
[ PASS ] constants_error_handling_module::test_is_even_failed
[ PASS ] constants_error_handling_module::test_is_even_success
[debug] @0x1
[ PASS ] constants_error_handling_module::test_show_address
Test result: OK. Total tests: 4; passed: 4; failed: 0
{
"Result": "Success"
}
```
# Integer
## Summary
- Move supports six unsigned integer types: u8, u16, u32, u64, u128, and u256.
- Direct mathematical operations between different integer types are not allowed.
- Type casting is necessary when performing operations with different integer types.
- It's recommended to cast smaller types to larger types to avoid overflow risks.
- The module demonstrates adding a u8 and a u64 by converting u8 to u64.
- A test function verifies the addition operation.
- The code can be tested using the Move test command.
## Overview

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Move supports six unsigned integer types: `u8`, `u16`, `u32`, `u64`, `u128`, and `u256`. Values
of these types range from 0 to a maximum that depends on the size of the type.
Although math can be done easily among integers of the same type, it's not possible to do math
directly between integers of different type
```rust
fun plus_two_types(): u64 {
let x: u8 = 10;
let y: u64 = 60;
// This will error
x + y // x and y are different types -> failed to compile
}
```
To make this expression correct, you need to use two identical data types; we will convert one of
the two data types to match the other.
```rust
fun plus_two_types(): u64 {
let x: u8 = 10;
let y: u64 = 60;
(x as u64) + y
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

> One of the things to pay attention to when using type casting, like the code above, is that we
should only cast smaller types to larger types, and not the other way around. This helps to limit
the risk of overflow.
>
# Code Start
This code defines a module in Move language that includes a function plus_two_types, which
adds a u8 and a u64 after converting the u8 to u64. The module also contains a test function
test_plus_two_types that verifies the addition operation.
```rust
module movement::integer_module {
use std::debug::print;
fun plus_two_integer(x: u64, y: u64): u64 {
x+y
}
fun plus_two_types(x: u8, y: u64): u64 {
(x as u64) + y
}
fun integer_type() {
let _a: u8 = 0;
let _b: u16 = 1;
let _c: u32 = 2;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let _d: u64 = 3;
let _e: u128 = 4;
let _f: u256 = 5;
}
#[test]
fun test_plus_two_types() {
let result = plus_two_types(5, 100);
print(&result);
}
#[test]
fun test_show_interger() {
integer_type();
}
#[test]
fun test_plus_two_integer() {
let result = plus_two_integer(5, 100);
print(&result);
}
}
```
> Execute test in the terminal
>

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```bash
movement move test --filter integer_module
```
```json
Running Move unit tests
[debug] 105
[ PASS ]
0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module
::test_plus_two_integer
[debug] 105
[ PASS ]
0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module
::test_plus_two_types[ PASS ]
0xc103109311944d8bae02fccf9273dcb4615be30653e85aec628f04b6ddd00fef::integer_module
::test_show_interger
Test result: OK. Total tests: 3; passed: 3; failed: 0
{
"Result": "Success"
}
```# Boolean
## Summary
- Boolean is a primitive data type in Move representing true or false values
- Essential for implementing logic and controlling program flow
- Declared using the bool type (e.g., `let a: bool = true`)
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Used in conditional statements and loops
- Can be printed and tested in Move modules
- Fundamental for effective programming and robust application development in Move
## Overview
Boolean types in Move are a primitive data type that represent two possible values: true and
false. They are essential for implementing logic in your programs, allowing you to control the
flow of execution based on conditions.
## Introduction
In programming, Boolean types are used to represent truth values. They are fundamental in
decision-making processes, enabling conditional statements and loops.
## Declaring Boolean Variables
You can declare Boolean variables using the bool type. Here’s how to do it:
```rust
let a: bool = true; // Declaration of a Boolean variable with value true
let b: bool = false; // Declaration of a Boolean variable with value false
```
## Example Code

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Here’s the complete example demonstrating the declaration, usage, and testing of Boolean
types in Move:
```rust
module movement::boolean_type {
use std::debug::print;
fun bool_types() {
let a: bool = true;
let b: bool = false;
print(&a); // Outputs: true
print(&b); // Outputs: false
}
#[test]
fun test_bool_types() {
bool_types(); // Calls the bool_types function to test its output
}
}
```
> Run test on terminal
>
```ruby
movement move test --filter boolean_type
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```json
Running Move unit tests
[debug] true
[debug] false
[ PASS ]
0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::MovementMo
dule::test_bool_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
}
```
## Conclusion
Boolean types are a fundamental aspect of programming in Move, enabling developers to
implement logic and control flow effectively. Understanding how to declare, use, and test
Boolean types will enhance your programming skills and improve your ability to write robust
Move applications.
> Read more [here](https://hack.movementlabs.xyz/ch04-01-primitive-types.html)
>
# Boolean

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

## Summary
- Boolean is a primitive data type in Move representing true or false values
- Essential for implementing logic and controlling program flow
- Declared using the bool type (e.g., `let a: bool = true`)
- Used in conditional statements and loops
- Can be printed and tested in Move modules
- Fundamental for effective programming and robust application development in Move
## Overview
Boolean types in Move are a primitive data type that represent two possible values: true and
false. They are essential for implementing logic in your programs, allowing you to control the
flow of execution based on conditions.
## Introduction
In programming, Boolean types are used to represent truth values. They are fundamental in
decision-making processes, enabling conditional statements and loops.
## Declaring Boolean Variables
You can declare Boolean variables using the bool type. Here’s how to do it:
```rust
let a: bool = true; // Declaration of a Boolean variable with value true
let b: bool = false; // Declaration of a Boolean variable with value false
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
## Example Code
Here’s the complete example demonstrating the declaration, usage, and testing of Boolean
types in Move:
```rust
module movement::boolean_type {
use std::debug::print;
fun bool_types() {
let a: bool = true;
let b: bool = false;
print(&a); // Outputs: true
print(&b); // Outputs: false
}
#[test]
fun test_bool_types() {
bool_types(); // Calls the bool_types function to test its output
}
}
```
> Run test on terminal
>
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```ruby
movement move test --filter boolean_type
```
```json
Running Move unit tests
[debug] true
[debug] false
[ PASS ]
0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::MovementMo
dule::test_bool_types
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
}
```
## Conclusion
Boolean types are a fundamental aspect of programming in Move, enabling developers to
implement logic and control flow effectively. Understanding how to declare, use, and test
Boolean types will enhance your programming skills and improve your ability to write robust
Move applications.
> Read more [here](https://hack.movementlabs.xyz/ch04-01-primitive-types.html)
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

>

# Address & Signer
## Address
### Summary
- Address is a 256-bit identifier representing locations in global storage in Move.
- Addresses can store Modules and Resources, but are intentionally opaque and don't support
arithmetic operations.
- Address syntax includes named and numerical forms, with @ prefix in expression contexts.
- Signer represents authority over blockchain resources and is used for transaction execution.
- Signer values are automatically generated by the Move VM and cannot be created through
literals.
- The `std::signer` module provides utility functions for working with signers.
- Addresses are primarily used for global storage operations, while signers are used for
transaction authorization.
### Address Overview
Address is an integrated data type in Move used to represent locations (sometimes referred to
as accounts) in global storage. An address value is a `256-bit` (`32-byte`) identifier. At a specific
address, two things can be stored: a `Module` and a `Resource`.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Although an address is a `256-bit` integer, Move addresses are designed to be intentionally
opaque; they cannot be derived from integers, do not support arithmetic operations, and cannot
be altered. While there may be interesting programs utilizing such features (for example, pointer
operators in C serve a similar role), Move does not allow such dynamic behavior as it is
designed from the ground up to support static verification.
You can use address values at runtime (address-type values) to access resources at that
address. You cannot access modules at runtime through address values.
### Address and Syntax:
Addresses have two forms: `named` or `numerical`. The syntax of named addresses follows the
same rules as any identifier name in Move. The syntax of numerical addresses is not limited to
hexadecimal values, and any valid u256 numeric value can be used as an address value; for
example, `40`, `0xCAFE`, and `2024` are all valid numeric address literals.
To distinguish when an address is being used in the context of an expression or not, the syntax
for using an address varies depending on the context in which it is used:
- When an address is used as an expression, it must be prefixed by the character @, for
example: `@<numerical_value>` or `@<named_address_identifier>`.
- Outside of expression contexts, an address can be written without the prefix @, for example:
`<numerical_value>` or `<named_address_identifier>`.
### Declaring Address Variables
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let addr1: address = @0x1;
//numerical address example
let addr2: address = @my_addrx; //named address example
```
### Primary purpose
- The primary purpose of addresses is to interact with global storage operations.
- Address values are used with the operations exists, borrow_global, borrow_global_mut, and
move_from.
- The only global storage operation that does not use an address is move_to, which uses a
signer instead.
--## Signer
### Signer Overview
Signer is a data type that represents the authority and control over a resource or asset on the
blockchain. The signer data type is used to designate which account or entity is responsible for
executing a specific transaction or operation on the blockchain.
You can think of its native implementation as follows:
`struct signer has drop { a: address }`

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### Declaring Signer Variables
Signer values are special because they cannot be created through literals or instruction-only
constructs that can be generated by the Move VM. Before the VM executes a script with
parameters of the signer type, it will automatically generate signer values and pass them into
the code:
```rust
module movement::address_and_signer {
use std::signer;
// All structures that are saved to global storage must include the key attribute
struct ResourceName has key {
data: u64,
}
fun create_resource(new_data: u64, owner: &signer) {
move_to(owner, ResourceName{
data: new_data
});
}
}
```
`signer` Operations: The package `std::signer` in the standard library module provides 2 utility
functions for signer:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- `signer::address_of(&signer)`: address - Returns the address wrapped by &signer.
- `signer::borrow_address(&signer)`: &address - Returns a reference to the address wrapped by
&signer.
```rust
module movement::address_and_signer {
use std::signer;
use std::debug::print;
// All structures that are saved to global storage must include the key attribute
struct ResourceName has key {
data: u64,
}
public entry fun create_resource(owner: &signer, new_data: u64) {
move_to(owner, ResourceName{
data: new_data
});
print(owner); // signer
print(&signer::address_of(owner)); // address of signer
}
#[test(account = @0x1)]
fun test_create_resource(account: &signer) {
create_resource(10, account);
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
```
> Running test
>
```ruby
movement move test -f address_and_signer
```
- Result:
```bash
Running Move unit tests
[debug] @0x1
[debug] signer(@0x1)
[ PASS ]
0xdb8a45e0e06d2bd305cdb824fda101cec6a24721cb03188c5543a5e5a8c3f3b0::address_and
_signer::test_create_resource
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

> Publish & call on blockchain
>
- Publish Modules
```ruby
movement aptos publish
```
- Call Function
```ruby
movement move run --function-id 'default::address_and_signer::create_resource' --args u64:10
```
- Check it on your account list with command:
```ruby
movement account list
```
- In the returned result, you will see an object similar to the one below:
```json
{
"0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::address_and_s
igner::ResourceName": {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

"data": "10"
}
}
```
# String & Vector
## Summary
- Move's primary collection type is `vector`<T>, a homogeneous, expandable/shrinkable
collection of T values.
- Vectors can be initialized with any data type, including primitive types, custom types, and
nested vectors.
- Key vector operations include adding elements, accessing by index, and removing elements.
- Vector behavior depends on the capabilities of its element type T, especially for destruction
and copying.
- Move provides various built-in functions for vector manipulation, such as `push_back`,
`pop_back`, and `borrow`.
- Strings in Move are represented as `vector<u8>`, with utility functions for conversion and
manipulation.
This document covers the fundamentals of working with vectors and strings in Move, including
creation, manipulation, and common operations.
## Vector Overview
- `vector<T>` is the only collection type provided by Move. A `vector<T>` is a homogeneous
collection of T values that can be expanded or shrunk by adding/removing values from its "end".
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- A `vector<T>` can be initialized with any data type as T. For example, `vector<u8>`,
`vector<address>`, `vector<0x42::MovementModule::ResourceType>`, and
`vector<vector<u8>>`
```rust
let byte_string_example: vector<u8> = b"Hello world"; //Byte strings are quoted string literals
prefixed by a b
let hex_string_example: vector<u8> = x"48656c6c6f20776f726c64"; //Hex strings are quoted
string literals prefixed by a x
```
### Add value into vector
The following code demonstrates how to add a value to the end of a vector in Move:
- The function `add_last_vec` takes a `u64` number as input and returns a `vector<u64>`.
- It creates an empty vector using `vector::empty<u64>()`.
- The `vector::push_back` function is used to add the input number to the end of the vector.
- The `test_add_last_vec` function demonstrates how to use this function and print the resulting
vector.
This example showcases basic vector operations in Move, including creation, adding elements,
and returning a vector from a function.
```rust
module movement::vector_type {
use std::vector;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

use std::debug::print;
fun add_last_vec(number: u64): vector<u64> {
let list = vector::empty<u64>();
vector::push_back(&mut list, number);
return list
}
#[test]
fun test_add_last_vec() {
let vec = add_last_vec(500);
print(&vec);
}
}
```
```rust
vector::push_back(&mut list, number);
```
Here's a breakdown of the arguments:
1. `&mut list`:
- This is the first argument to `push_back`.
- The `&mut` indicates a mutable reference to `list`.
- Mutable references allow the function to modify the original vector.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Using `&mut` is necessary because adding an element changes the vector's contents.
2. `number`:
- This is the second argument to `push_back`.
- It's the value being added to the end of the vector. The type depends on the vector created
earlier.
- In this case, it's the `u64` value passed into the `add_last_vec` function.
> Running test:
>
```rust
movement move test -f vector_type
```
> Result:
>
```rust
Running Move unit tests
[debug] [ 500 ]
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::tes
t_add_last_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
### Get Value in vector by index
The following code demonstrates how to retrieve a value from a vector by its index in Move:
- The function `get_value_by_index_vec` takes a `u64` index as input and returns a `u64` value.
- It creates a vector and populates it with three values: 10, 20, and 30.
- The `vector::borrow` function is used to access the element at the specified index. The `*`
operator dereferences the borrowed value.
- The `test_get_value_by_index_vec` function demonstrates how to use this function to retrieve
and print a value from the vector.
This example illustrates how to access elements in a vector by their index, which is a
fundamental operation when working with vectors in Move.
```rust
module movement::vector_type {
use std::vector;
use std::debug::print;
fun get_value_by_index_vec(index: u64): u64 {
let list = vector::empty<u64>();
vector::push_back(&mut list, 10);
vector::push_back(&mut list, 20);
vector::push_back(&mut list, 30);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

return *vector::borrow(&list, index)
}
#[test]
fun test_get_value_by_index_vec() {
let value = get_value_by_index_vec(1);
print(&value);
}
}
```
> Running test:
>
```rust
movement move test -f test_get_value_by_index_vec
```
> Result:
>
```rust
Running Move unit tests
[debug] 20
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::tes
t_get_value_by_index_vec
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
}
```
### Take last value from vector
The following code demonstrates how to remove and return the last value from a vector in
Move:
- The function `take_last_value_in_vec` creates a vector with three elements: 10, 20, and 30.
- It uses `vector::pop_back` to remove and return the last element (30) from the vector.
- The function returns a tuple containing the modified vector and the removed value.
- The `test_take_last_value_in_vec` function shows how to use this function and print both the
resulting vector and the removed value.
This example illustrates how to manipulate vectors by removing elements, which is a common
operation when working with dynamic collections in Move.
```rust
module movement::vector_type {
use std::vector;
use std::debug::print;
fun take_last_value_in_vec(): (vector<u64>, u64) {
let list = vector::empty<u64>();
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

vector::push_back(&mut list, 10);
vector::push_back(&mut list, 20);
vector::push_back(&mut list, 30);
let take_value: u64 = vector::pop_back(&mut list);
return (list, take_value)
}
#[test]
fun test_take_last_value_in_vec() {
let (list, take_value) = take_last_value_in_vec();
print(&list);
print(&take_value);
}
}
```
> Running test:
>
```rust
movement move test -f test_take_last_value_in_vec
```
> Result:
>

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
Running Move unit tests
[debug] [ 10, 20 ]
[debug] 30
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::tes
t_take_last_value_in_vec
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
}
```
### Destroying and Copying Vectors
- Some behaviors of `vector<T>` depend on the capabilities of the element type `T`. For
instance, vectors containing elements that can't be dropped can't be implicitly discarded like `v`
in the example above. Instead, they must be explicitly destroyed using `vector::destroy_empty`.
Note: `vector::destroy_empty` will trigger a runtime error if the vector is empty (contains zero
elements).
```rust
fun destroy_any_vector<T>(vec: vector<T>) {
vector::destroy_empty(vec) // deleting this line will cause a compiler error
}
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Example:
```rust
module movement::vector_type {
use std::vector;
use std::debug::print;
struct DropVector has drop {
data: u64
}
fun add_last_vec(number: u64): vector<DropVector> {
let list = vector::empty<DropVector>();
vector::push_back(&mut list, DropVector { data: number });
return list
}
#[test]
fun test_add_vector() {
let vec = add_last_vec(10);
print(&vec);
}
#[test]
#[expected_failure]
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

fun test_failed_drop_vector() {
let vec = add_last_vec(10);
vector::destroy_empty(vec);
}
#[test]
fun test_success_drop_vector() {
let vec = add_last_vec(10);
vector::pop_back(&mut vec);
vector::destroy_empty(vec);
}
}
```
> Running test:
>
```rust
movement move test -f vector_type
```
> Result:
>
```rust
Running Move unit tests
[debug] [
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::Dr
opVector {
data: 10
}
]
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::tes
t_add_vector
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::tes
t_failed_drop_vector
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::tes
t_success_drop_vectorTest result: OK. Total tests: 3; passed: 3; failed: 0
{
"Result": "Success"
}
```
### Copy a vector
Similarly, vectors cannot be copied (using `copy`) unless the element type has the `copy`
capability. In other words, a `vector<T>` is copyable only if `T` has the.
```rust
module movement::vector_type {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

use std::vector;
use std::debug::print;
struct DropVector has drop, copy {
data: u64
}
fun add_last_vec(number: u64): vector<DropVector> {
let list = vector::empty<DropVector>();
vector::push_back(&mut list, DropVector { data: number });
return list
}
#[test]
fun test_success_drop_vector() {
let vec = add_last_vec(10);
vector::pop_back(&mut vec);
vector::destroy_empty(vec);
}
#[test]
fun test_clone_vector() {
let vec = add_last_vec(10);
let vec_copy = copy vec;
}
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
> Running test:
>
```rust
movement move test -f vector_type
```
> Result:
>
```rust
Running Move unit tests
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::tes
t_clone_vector
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::vector_type::tes
t_success_drop_vectorTest result: OK. Total tests: 2; passed: 2; failed: 0
{
"Result": "Success"
}
```

🚨

<aside>

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Copying large `vectors` can be **expensive**, so the compiler requires explicit copies to make it
easy to see where they occur.
</aside>
## Additional Vector Functions
| **Function** | **Parameters** | **Description** | **Return Value** |
| --- | --- | --- | --- |
| `empty<T>` | None | Creates an empty vector that can store values of type `T` | `vector<T>` |
| `singleton<T>` | `t: T` | Creates a vector of size 1 containing `t` | `vector<T>` |
| `push_back<T>` | `v: &mut vector<T>, t: T` | Adds `t` to the end of `v` | None |
| `pop_back<T>` | `v: &mut vector<T>` | Removes and returns the last element in `v` | `T` |
| `borrow<T>` | `v: &vector<T>, i: u64` | Returns an immutable reference to the `T` at index `i` |
`&T` |
| `borrow_mut<T>` | `v: &mut vector<T>, i: u64` | Returns a mutable reference to the `T` at index
`i` | `&mut T` |
| `destroy_empty<T>` | `v: vector<T>` | Deletes `v` | None |
| `append<T>` | `v1: &mut vector<T>, v2: vector<T>` | Adds the elements in `v2` to the end of
`v1` | None |
| `contains<T>` | `v: &vector<T>, e: &T` | Returns true if `e` is in the vector `v`, otherwise false |
`bool` |
| `swap<T>` | `v: &mut vector<T>, i: u64, j: u64` | Swaps the elements at the `i`th and `j`th
indices in the vector `v` | None |
| `reverse<T>` | `v: &mut vector<T>` | Reverses the order of the elements in the vector `v` in
place | None |
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

| `index_of<T>` | `v: &vector<T>, e: &T` | Returns `(true, i)` if `e` is in the vector `v` at index `i`,
otherwise `(false, 0)` | `(bool, u64)` |
| `remove<T>` | `v: &mut vector<T>, i: u64` | Removes the `i`th element of the vector `v`, shifting
all subsequent elements | `T` |
| `swap_remove<T>` | `v: &mut vector<T>, i: u64` | Swaps the `i`th element with the last element
and then pops the element | `T` |
## Overview String
In Move, String is not a native data type. Data in the Move VM is stored as bytes, so when using
a string, the essence of the string will be a vector<u8>, a sequence of characters encoded as
bytes arranged adjacently to create a string
```rust
module movement::string_type {
use std::string::{String, utf8};
use std::signer;
use std::debug::print;
fun vec_string() {
let vec_string: vector<u8> = b"Hello by vector u8";
let by_string: String = utf8(b"Hello by String");
let by_vec: String = utf8(vec_string);
print(&vec_string);
print(&by_string);
print(&by_vec);
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

#[test]
fun test_vec_string() {
vec_string()
}
}
```
> Running test:
>
```rust
movement move test -f test_vec_string
```
> Result:
>
```rust
Running Move unit tests
[debug] 0x48656c6c6f20627920766563746f72207538
[debug] "Hello by String"
[debug] "Hello by vector u8"
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::string_type::test
_vec_string
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

{
"Result": "Success"
}
```
## Conclusion
Vectors and strings are fundamental data structures in Move that provide powerful capabilities
for handling collections and text data. Here are the key takeaways:
- Vectors (`vector<T>`) offer a flexible, homogeneous collection type that can be used with any
data type in Move.
- Vector operations like adding, removing, and accessing elements are efficient and
well-supported by built-in functions.
- The behavior of vectors depends on the capabilities of their element type, particularly for
operations like destruction and copying.
- Strings in Move are represented as `vector<u8>`, leveraging the vector structure for character
sequences.
- Move provides utility functions for string manipulation, including conversion between
vector<u8> and String types.
Understanding these concepts is crucial for effective programming in Move, as they form the
basis for many complex data structures and algorithms. Proper use of vectors and strings can
lead to more efficient and maintainable code in Move-based smart contracts and applications.
# Map (Simple Map)

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

## Overview
`0x1::simple_map`
This module provides a solution for map features. Maps will have the following characteristics:
- Keys point to Values: Each key is associated with a value.
- Each key must be unique: No two keys are duplicated.
- A Key can be found within O(Log N) time
- Data is stored in order sorted by Key: Elements in maps are arranged based on the key.
- Adding and removing elements takes O(N) time: The time to add or remove an element is
proportional to the number of elements in the map.
## Example:
The code below demonstrates the usage of a SimpleMap in the Move programming language:
1. It defines a module called `SimpleMapType` within the `movement` module.
2. The module imports necessary dependencies: `SimpleMap` from the `simple_map` module,
`print` from the `debug` module, and `signer` from the standard library.
3. A function `map_in_move` is defined that takes a signer reference as an argument and
returns a `SimpleMap` with address keys and u64 values.
4. Inside `map_in_move`, a new SimpleMap is created using `simple_map::create()`.
5. An element is added to the map using `simple_map::add()`, where the key is the signer's
address and the value is 10.
6. The function returns the created map.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

7. A test function `test_map_in_move` is defined using the `#[test]` attribute. It calls
`map_in_move` and prints the resulting map.
This example showcases how to create, populate, and use a SimpleMap in Move,
demonstrating its basic operations and integration with other Move concepts like signers and
testing.
```rust
module movement::simple_map_module {
use std::simple_map::{SimpleMap, Self};
use std::debug::print;
use std::signer;
fun map_in_move(sign: &signer): SimpleMap<address, u64> {
let mp: SimpleMap<address, u64> = simple_map::create();
simple_map::add(&mut mp, signer::address_of(sign), 10);
return mp
}
#[test(account = @0x1)]
fun test_map_in_move(account: &signer) {
let map = map_in_move(account);
print(&map);
}
}
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

> Running test:
>
```rust
movement move test -f test_map_in_move
```
> Result:
>
```rust
Running Move unit tests
[debug] 0x1::simple_map::SimpleMap<address, u64> {
data: [
0x1::simple_map::Element<address, u64> {
key: @0x1,
value: 10
}
]
}
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::simple_map_m
odule::test_map_in_move
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
```
## Additional SimpleMap Functions
| **Function** | **Description** | **Return Value** |
| --- | --- | --- |
| `length` | Gets the number of elements | `u64` |
| `new` | Creates an empty SimpleMap | `SimpleMap<K, V>` |
| `new_from` | Creates from key-value vectors | `SimpleMap<K, V>` |
| `create` | Deprecated alias for`new` | `SimpleMap<K, V>` |
| `borrow` | Borrows a value by key | `&V` |
| `borrow_mut` | Mutably borrows a value by key | `&mut V` |
| `contains_key` | Checks for key existence | `bool` |
| `destroy_empty` | Destroys an empty map | None |
| `add` | Adds a key-value pair | None |
| `add_all` | Adds multiple key-value pairs | None |
| `upsert` | Inserts or updates a pair | None |
| `keys` | Gets all keys | `vector<K>` |
| `values` | Gets all values | `vector<V>` |
| `to_vec_pair` | Converts to key-value vectors | `(vector<K, V>)` |
| `destroy` | Destroys map with lambdas | None |
| `remove` | Removes and returns a pair | `(K, V)` |
| `find` | Finds key index (internal) | `Option<u64>` |
# Using ExtendRef
## Summary
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- `ExtendRef` in Aptos Move allows generating a signer for an object after creation
- Key use cases include adding ownership capabilities and enhancing object functionality
- Implementation involves storing, retrieving, and using ExtendRef with
`object::generate_signer()`
- Important to use `ExtendRef` judiciously and protect it carefully
- Common pitfalls include exposing ExtendRef publicly and unnecessary usage
- Proper use of `ExtendRef` enables flexible and safe extension of object functionality
## Why ExtendRef?
`ExtendRef` allows us to generate a signer for an object after it has been created. This is crucial
because:
- A signer can only be created once using ConstructorRef when the object is initialized.
- After object creation, we lose access to ConstructorRef.
## Use Cases for ExtendRef
- Adding ownership capabilities to objects
- Enhancing object functionality post-creation
- Facilitating digital asset operations
## How to Use ExtendRef
1. Store ExtendRef: When creating an object, store ExtendRef in a field of the object.
2. Retrieve ExtendRef: Write a function to retrieve ExtendRef from the object.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

3. Use ExtendRef: Use `object::generate_signer()` to create a signer from ExtendRef.
In this example, we'll create an ExtendRef and store it in a separate resource, which we'll use
for future extension purposes.
```rust
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
extend_ref: ExtendRef
}
fun init_module(owner: &signer) {
let state_object_constructor_ref = &object::create_named_object(owner,
MOVEMENT_OBJECT_NAME);
let state_object_signer = &object::generate_signer(state_object_constructor_ref);
move_to(state_object_signer, MovementObject {
value: 10
});
let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
move_to(state_object_signer, ControllerObject { extend_ref });
}
```
In the code above, we initialize two resources: MovementObject and ControllerObject. We
create a separate object to store these two resources independently. In the future, if I want to
add more resources, I'll use the ExtendRef in ControllerObject to do so.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct NewObject has key {
new_value: u64
}
```
I'm creating an additional resource to add to the object address that I created in the
`init_module` function, and I'm creating a function to add this resource.
```rust
// This function adds a new object to an existing object using ExtendRef
// Parameters:
// - owner: The signer who owns the object
// - obj: The object to which we want to add a new object
// The function does the following:
public fun add_new_object(owner: &signer, obj: Object&lt;MovementObject&gt;) acquires
ControllerObject {
// 1. Verifies that the owner is indeed the owner of the object
let addr = address_of(owner);
assert!(object::is_owner(obj, addr), 1);
// 2. Retrieves the ExtendRef from the ControllerObject
let object_address = object::object_address(&obj);
let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// 3. Generates a signer for the object using the ExtendRef
let object_signer = object::generate_signer_for_extending(extend_ref);
// 4. Creates and moves a new NewObject to the object's address
move_to(&object_signer, NewObject { new_value: 50 });
}
```
The test case for this scenario will be:
```rust
#[test(account = @0x1)]
fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
test_init_module(account);
let addr = address_of(account);
let obj = get_object(addr);
add_new_object(account, obj);
let movement_object_address = get_object_address(addr);
assert!(exists<NewObject>(movement_object_address), 0);
let new_object_data = borrow_global<NewObject>(movement_object_address);
assert!(new_object_data.new_value == 50, 1);
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

## Important Considerations
- Only use ExtendRef when necessary.
- Protect ExtendRef carefully as it allows creating the object's signer.
- Thoroughly check access to functions using ExtendRef.
## Common Pitfalls to Avoid
- Don't expose ExtendRef publicly without proper safeguards.
- Avoid unnecessary use of ExtendRef when simpler alternatives exist.
- Don't forget to handle potential errors when using ExtendRef.
By leveraging ExtendRef, you can flexibly and safely extend object functionality in Move.
### Full Code
```ruby
module movement::object_module_entry {
use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
use std::signer::address_of;
use std::debug::print;
const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
value: u64
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct NewObject has key {
new_value: u64
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
extend_ref: ExtendRef
}
fun init_module(owner: &signer) {
let state_object_constructor_ref = &object::create_named_object(owner,
MOVEMENT_OBJECT_NAME);
let state_object_signer = &object::generate_signer(state_object_constructor_ref);
move_to(state_object_signer, MovementObject {
value: 10
});
let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
move_to(state_object_signer, ControllerObject { extend_ref });
}
#[test_only]
fun test_init_module(onwer: &signer) {
init_module(onwer);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
#[view]
public fun get_object_address(owner: address): address {
object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
}
#[view]
public fun get_object(owner: address): Object<MovementObject> {
object::address_to_object(get_object_address(owner))
}
public fun get_value(owner: address): u64 acquires MovementObject {
borrow_global<MovementObject>(get_object_address(owner)).value
}
#[view]
public fun get_owner_object(obj: Object<MovementObject>): address {
object::owner(obj)
}
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
let obj = get_object(owner);
assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can
transfer/modify it
let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
object_data.value = new_value;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
public fun transfer_obj(owner: &signer, new_owner: address) {
let owner_addr = address_of(owner);
let obj = get_object(owner_addr);
assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can
transfer/modify it
object::transfer(owner, obj, new_owner);
}
public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires
ControllerObject {
let addr = address_of(owner);
assert!(object::is_owner(obj, addr), 1);
let object_address = object::object_address(&obj);
let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
let object_signer = object::generate_signer_for_extending(extend_ref);
move_to(&object_signer, NewObject { new_value: 50 });
}
#[test(account = @0x1)]
fun test_add_new_object(account: &signer) acquires ControllerObject, NewObject {
test_init_module(account);
let addr = address_of(account);
let obj = get_object(addr);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

add_new_object(account, obj);
let movement_object_address = get_object_address(addr);
assert!(exists<NewObject>(movement_object_address), 0);
let new_object_data = borrow_global<NewObject>(movement_object_address);
assert!(new_object_data.new_value == 50, 1);
}
#[test(account = @0x1, new_owner = @0x2)]
fun test_transfer_object(account: &signer, new_owner: address) {
test_init_module(account);
transfer_obj(account, new_owner);
}
#[test(account = @0x1)]
fun test_get_owner_object_address(account: &signer) {
test_init_module(account);
let addr = address_of(account);
let obj = get_object(addr);
let get_owner = get_owner_object(obj);
print(&get_owner);
}
#[test(account = @0x1)]
fun test_get_object_address(account: &signer) {
test_init_module(account);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let addr = address_of(account);
let value = get_object_address(addr);
print(&value);
}
#[test(account = @0x1)]
fun test_get_object(account: &signer) acquires MovementObject {
test_init_module(account);
let addr = address_of(account);
let value = get_value(addr);
assert!(value == 10, 0);
}
#[test(account = @0x1)]
fun test_set_object(account: &signer) acquires MovementObject {
test_init_module(account);
let addr = address_of(account);
set_value(addr, 20);
let value = get_value(addr);
assert!(value == 20, 1);
}
}
```# Address Object & Create Object
## Summary

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Objects are a key feature in the `aptos_framework`, enhancing code flexibility and adaptability.
- They address limitations of structs such as lack of stable identity, limited extensibility, and data
overload.
- Objects maintain stable references, allow potential future extensions, and improve data
organization.
- Creation involves using functions like `object::create_object`, which generates a unique
address for storing resources.
- The process includes getting the owner's address, creating the object, generating an object
signer, and moving the object to its address.
- Different types of objects (normal, named, sticky) can be created with varying properties of
deletability and address determinism.
## What is Object?
Objects are one of the most exciting features of the aptos_framework. They make your code
extremely flexible and help developers be more adaptable in designing and developing
products. Objects are also used in many of Aptos' standard code implementations, such as
Digital Assets, Coins, and Fungible Tokens.
In this lesson, we will explore what objects are and how they work.
## Limitations of Structs
Reflecting on our previous lessons about structs, we can see that while using structs and a
resource-centric approach has made Move very flexible, there are still several limitations:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

1. Lack of Stable Identity: Structs can move freely between resources, making them difficult to
track consistently.
2. Limited Extensibility: Once defined, structs cannot be easily extended with new fields, even in
upgradable modules.
3. Data Overload: Storing numerous resources in accounts can lead to clutter, making it
challenging to locate relevant data for specific decentralized applications (dApps).
**Using objects in this way allows us to:**
1. Maintain a stable reference to our data via the object's address.
2. Potentially extend the object's functionality in future upgrades.
3. Keep related data grouped together, improving organization.
## Create a Object
```rust
module movement::object_module_entry {
use aptos_framework::object;
use std::debug::print;
use std::signer;
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ExampleObject has key {
value: u64
}
public entry fun example_object(user: &signer, value: u64) {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let owner_address = signer::address_of(user);
print(&owner_address);
let example_object_constructor_ref = &object::create_object(owner_address);
print(example_object_constructor_ref);
let object_signer = &object::generate_signer(example_object_constructor_ref);
print(object_signer);
move_to(object_signer, ExampleObject { value });
let address_object =
object::address_from_constructor_ref(example_object_constructor_ref);
print(&address_object);
}
#[test(account = @0x1)]
fun test_example_object(account: &signer) {
example_object(account, 10);
}
}
```

1. Function Signature:
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public entry fun example_object(user: &signer, value: u64)
```
This function takes two parameters: a reference to a signer (the user) and a u64 value.
1. Get the owner's address:
```rust
let owner_address = signer::address_of(user);
```
This step retrieves the address of the signer and prints it.
1. Create an object:
```rust
let example_object_constructor_ref = &object::create_object(owner_address);
```
Here, a new object is created using the`create_object`function from the`object`module. The
constructor reference is stored. This function returns a randomly generated and unique object
address. This address will be used to store resources instead of storing them directly in the
user's address. This approach reduces the storage burden on user accounts, making it more
optimized and flexible.
1. Generate an object signer:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
let object_signer = &object::generate_signer(example_object_constructor_ref);
```
This step generates a signer for the object using the constructor reference.
1. Move the ExampleObject to the object's address:
```rust
move_to(object_signer, ExampleObject { value });
```
This moves an instance of `ExampleObject` with the given value to the address of the object
signer.
1. Get the object's address:
```rust
let address_object = object::address_from_constructor_ref(example_object_constructor_ref);
```
Finally, the function retrieves the address of the created object using the constructor reference
and prints it.
```rust
[debug] @0x1 // Address Signer
[debug] 0x1::object::ConstructorRef { // Create address object
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

self: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a,
can_delete: true
}
[debug]
signer(@0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a) //
signer
[debug] @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
```
1. Additionally, instead of retrieving the object's address, you can also directly obtain the object
through this function:
```rust
let object_info =
object::object_from_constructor_ref<ExampleObject>(example_object_constructor_ref);
```
Finally, the test results will return additional inner objects of that struct:
```rust
[debug]
0x1::object::Object<0x6f409ba3234fa3b9a8baf7d442709ef51f39284f35dd7c06360fa0b55a0cd6
90::object_module_entry::ExampleObject> {
inner: @0xe46a3c36283330c97668b5d4693766b8626420a5701c18eb64026075c3ec8a0a
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

In addition to the `object::create_object` function, we have other functions to create objects:
- `object::create_object`: A **normal Object |** This type is `deletable` and has a `random
address`
- `object::create_named_object` : A **named Object |** This type is **`not** deletable` and has a
`deterministic address`
- `object::create_sticky_object` : A **sticky Object |** This type is also **`not** deletable` and
has a `random address`
# Object Permissions - ObjectRefs
## Summary
- ObjectRefs are permissions for object management in Move
- Three types: `ExtendRef`, `TransferRef`, and `DeleteRef`
- `ExtendRef` allows signer generation after object creation
- `TransferRef` enables object transfer without owner's signer
- `DeleteRef` is used for object deletion
- ObjectRefs are generated from `ConstructorRef` during object creation
- Practical example demonstrates generating and storing refs
- Understanding ObjectRefs is crucial for effective object management in Move
## Understanding ObjectRefs in Move
In this tutorial, we'll explore ObjectRefs, which are crucial for managing objects in Move. We'll
cover three types of ObjectRefs and their uses.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### What are ObjectRefs?
ObjectRefs are permissions or capabilities for object management, generated from
ConstructorRef during object creation. They're different from Object<T> references.
### Types of ObjectRefs
- **ExtendRef:** Allows signer generation after object creation.
- Can be stored for future use
- Offers more flexibility than ConstructorRef
- **TransferRef:** Enables object transfer without owner's signer.
- Can transfer object to a different address
- Can 'freeze' an object, preventing further transfers
- **DeleteRef:** Used for object deletion.
- Can be stored
- One-time use capability
### Practical Application
In the next section, we'll walk through a step-by-step example of generating and storing these
refs. This hands-on approach will help solidify your understanding of ObjectRefs and their
practical uses in Move programming.
```rust
use aptos_framework::object::{Self, Object, ExtendRef, DeleteRef, TransferRef};
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
value: u64,
extend_ref: ExtendRef,
transfer_ref: TransferRef,
delete_ref: DeleteRef
}
fun init_module(owner: &signer) {
let state_object_constructor_ref = &object::create_named_object(owner,
MOVEMENT_OBJECT_NAME);
let state_object_signer = &object::generate_signer(state_object_constructor_ref);
move_to(state_object_signer, MovementObject {
value: 10,
extend_ref: object::generate_extend_ref(state_object_constructor_ref),
transfer_ref: object::generate_transfer_ref(state_object_constructor_ref),
delete_ref: object::generate_delete_ref(state_object_constructor_ref)
});
}
```
# Named Objects
## Summary

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Named objects in Move allow for easy retrieval and manipulation of object data
- The module demonstrates creation, retrieval, and modification of a Object
- Named objects use a fixed address, making them more convenient than default or sticky
objects
- The module includes test functions to verify correct behavior of main functions
- Global storage methods like `borrow_global` and `borrow_global_mut` are used to access
object data
## Named Object
In the previous section, we learned about three types of Objects, among which named objects
will likely be the type we use most often because we can initialize an object address that is fixed
and can be easily retrieved through the Object Name Address. As for default objects and sticky
objects, both create a random address. This makes it difficult to use them for querying or listing
information, but they also have their uses in certain cases.
In this section, we will use named objects to easily obtain the address for storing an object.
```rust
module movement::object_module_entry {
use aptos_framework::object;
use std::signer::address_of;
use std::debug::print;
const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

struct MovementObject has key {
value: u64
}
fun init_module(owner: &signer) {
let state_object_constructor_ref = &object::create_named_object(owner,
MOVEMENT_OBJECT_NAME);
let state_object_signer = &object::generate_signer(state_object_constructor_ref);
move_to(state_object_signer, MovementObject {
value: 10
});
}
#[test_only]
fun test_init_module(onwer: &signer) {
init_module(onwer);
}
#[view]
public fun get_object_address(owner: address): address {
object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
}
#[test(account = @0x1)]
fun test_get_object_address(account: &signer) {
test_init_module(account);
let owner = address_of(account);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let addr = get_object_address(owner);
print(&addr);
}
}
```
```rust
[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622 //
Object Address
```
By using named objects, we can easily access the object and perform changes or view data.
### Modify & Retrieve Object Value
To modify and retrieve data from objects, we still use global storage methods like
`borrow_global` and `borrow_global_mut`.
```rust
public fun get_value(owner: address): u64 acquires MovementObject {
borrow_global<MovementObject>(get_object_address(owner)).value
}
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
spider_dna.value = new_value;
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
## Full Code
```rust
module movement::object_module_entry {
use aptos_framework::object;
use std::signer::address_of;
use std::debug::print;
const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
value: u64
}
fun init_module(owner: &signer) {
let state_object_constructor_ref = &object::create_named_object(owner,
MOVEMENT_OBJECT_NAME);
let state_object_signer = &object::generate_signer(state_object_constructor_ref);
move_to(state_object_signer, MovementObject {
value: 10
});
}
#[test_only]
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

fun test_init_module(onwer: &signer) {
init_module(onwer);
}
#[view]
public fun get_object_address(owner: address): address {
object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
}
public fun get_value(owner: address): u64 acquires MovementObject {
borrow_global<MovementObject>(get_object_address(owner)).value
}
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
let spider_dna = borrow_global_mut<MovementObject>(get_object_address(owner));
spider_dna.value = new_value;
}
#[test(account = @0x1)]
fun test_get_object_address(account: &signer) {
test_init_module(account);
let addr = address_of(account);
let value = get_object_address(addr);
print(&value);
}
#[test(account = @0x1)]
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

fun test_get_object(account: &signer) acquires MovementObject {
test_init_module(account);
let addr = address_of(account);
let value = get_value(addr);
assert!(value == 10, 0);
}
#[test(account = @0x1)]
fun test_set_object(account: &signer) acquires MovementObject {
test_init_module(account);
let addr = address_of(account);
set_value(addr, 20);
let value = get_value(addr);
assert!(value == 20, 1);
}
}
```
## Function Descriptions
### 1. init_module(owner: &signer)
This function initializes the module by creating a named object and setting its initial value.
- Creates a named object using `object::create_named_object`
- Generates a signer for the object using `object::generate_signer`
- Moves a `MovementObject` with an initial value of 10 to the object's address
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### 2. get_object_address(owner: address): address
This function retrieves the address of the named object for a given owner.
- Uses `object::create_object_address` to calculate the object's address
- Returns the calculated address
### 3. get_value(owner: address): u64
This function retrieves the current value stored in the MovementObject for a given owner.
- Calls `get_object_address` to get the object's address
- Uses `borrow_global` to access the MovementObject at the calculated address
- Returns the `value` field from the MovementObject
### 4. set_value(owner: address, new_value: u64)
This function updates the value stored in the MovementObject for a given owner.
- Calls `get_object_address` to get the object's address
- Uses `borrow_global_mut` to get a mutable reference to the MovementObject
- Updates the `value` field with the new value
### Test Functions
The module includes several test functions to verify the correct behavior of the main functions:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- `test_init_module`: Initializes the module for testing
- `test_get_object_address`: Tests the `get_object_address` function
- `test_get_object`: Tests the `get_value` function
- `test_set_object`: Tests the `set_value` function
# Using TransferRef
**Summary**
- TransferRef provides an alternative method for object transfer without the owner's signer.
- Objects can be frozen or unfrozen using `disable_ungated_transfer` and
`enable_ungated_transfer`.
- LinearTransferRef allows for controlled, one-time transfers of objects.
- `TransferRef` is a capability that gives you fine-grained control over object transfers. It allows
you to:
- Enable or disable transfers
- Implement controlled transfers
- Transfer objects without the owner's signer
## Transferring Objects Without the Owner's Signer
While ExtendRef allows for transfer functions without the owner's signer, TransferRef offers an
alternative method for object transfer.
```ruby
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

extend_ref: ExtendRef,
transfer_ref: TransferRef,
}
fun init_module(owner: &signer) {
let state_object_constructor_ref = &object::create_named_object(owner,
MOVEMENT_OBJECT_NAME);
let state_object_signer = &object::generate_signer(state_object_constructor_ref);
move_to(state_object_signer, MovementObject {
value: 10
});
let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
move_to(state_object_signer, ControllerObject {
extend_ref,
transfer_ref
});
}
```
We can then use `transfer_with_ref` to execute the object transfer:
```ruby
public fun transfer_new_object(owner: &signer, new_owner: address) acquires ControllerObject
{

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let transfer_ref =
&borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
let object_signer = object::generate_linear_transfer_ref(transfer_ref);
object::transfer_with_ref(object_signer, new_owner);
}
```
### **Freezing and Unfreezing Objects**
A key feature of TransferRef in real-world projects is managing object transferability. We can
freeze or unfreeze specific objects, which is particularly useful for protecting an object or using it
for a specific purpose.
```rust
fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
let transfer_ref =
&borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
object::disable_ungated_transfer(transfer_ref);
}
fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
let transfer_ref =
&borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
object::enable_ungated_transfer(transfer_ref);
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Let's break down the process of using TransferRef for object transfer:
1. **Create a TransferRef:** In the `init_module` function, generate a TransferRef using
`object::generate_transfer_ref(state_object_constructor_ref)`.
2. **Store the TransferRef:** Store this TransferRef in the ControllerObject struct, then move it
to the object's address.
3. **Implement the transfer function:** In the `transfer_new_object` function:
- a. Retrieve the TransferRef from the ControllerObject.
- b. Generate a linear transfer ref using `object::generate_linear_transfer_ref(transfer_ref)`.
- c. Use `object::transfer_with_ref` to transfer the object to the new owner.
1. **Freezing an object:** To disable transfers, use the `freeze_object` function:
- a. Retrieve the TransferRef from the ControllerObject.
- b. Call `object::disable_ungated_transfer(transfer_ref)` to freeze the object.
1. **Unfreezing an object:** To re-enable transfers, use the `unfreeze_object` function:
- a. Retrieve the TransferRef from the ControllerObject.
- b. Call `object::enable_ungated_transfer(transfer_ref)` to unfreeze the object.
By following these steps, you can effectively manage object transfers and control their
transferability using TransferRef.
## Implementing Controlled Transfers
For more precise control over transfers, you can use LinearTransferRef:
`linear_transfer_ref: Option&lt;LinearTransferRef&gt;` implements a controlled transfer
mechanism for objects in Aptos Move. Here's a breakdown:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- `LinearTransferRef`:
- A special type of transfer reference in Aptos Move.
- Allows for a single, one-time transfer of an object.
- Once used, the `LinearTransferRef` is consumed and cannot be reused.
- `Option<LinearTransferRef>`:
- `Option` is a Move type that allows a value to either exist or not.
- Using `Option` represents the state of the `LinearTransferRef`: either present (Some) or
absent (None).
```rust
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ObjectController has key {
transfer_ref: TransferRef,
linear_transfer_ref: Option<LinearTransferRef>,
}
fun allow_single_transfer(object: Object<ObjectController>) acquires ObjectController {
let object_address = object::object_address(&object);
let controller = borrow_global_mut<ObjectController>(object_address);
let linear_transfer_ref = object::generate_linear_transfer_ref(&controller.transfer_ref);
option::fill(&mut controller.linear_transfer_ref, linear_transfer_ref);
}
fun transfer(owner: &signer, object: Object<ObjectController>, new_owner: address) acquires
ObjectController {
let object_address = object::object_address(&object);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let controller = borrow_global_mut<ObjectController>(object_address);
let linear_transfer_ref = option::extract(&mut controller.linear_transfer_ref);
object::transfer_with_ref(linear_transfer_ref, new_owner);
}
```
Purpose of use:
1. Transfer Control:
- Using `Option&lt;LinearTransferRef&gt;` controls when transfers are allowed.
- When `linear_transfer_ref` is `None`, no transfer can occur.
- When it's `Some(LinearTransferRef)`, a single transfer can be executed.
2. One-time Transfer:
- Each `LinearTransferRef` can only be used once.
- After use, it's consumed, and `linear_transfer_ref` returns to the `None` state.
3. Security and Control:
- This mechanism enables implementation of complex transfer policies.
- For example, allowing transfers only under specific conditions or within a certain timeframe.
## Conclusion
TransferRef is a powerful tool in Aptos Move that provides fine-grained control over object
transfers. By leveraging TransferRef, you can implement sophisticated transfer logic, enhance
security, and create more flexible smart contracts.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Always consider the security implications when implementing transfer logic, and thoroughly test
your code before deployment.
# Using DeleteRef
## Summary
- Object deletion in Aptos Move is implemented using the `DeleteRef` concept.
- A `DeleteRef` must be created during object initialization for objects that can be deleted.
- The module demonstrates creating objects with customizable properties (transferrable,
controllable, deletable).
- `ExtendRef`, `TransferRef`, and `DeleteRef` are used to manage object behavior.
- Object deletion respects ownership, allowing only the owner to delete an object.
- This approach provides fine-grained control over object lifecycle and permissions in Aptos
Move smart contracts.
## Overview
Object deletion is a crucial feature in data management, serving two primary purposes:
decluttering your workspace and reclaiming storage resources. To facilitate this process, we
introduce the concept of a `DeleteRef`.
A `DeleteRef` is a specialized reference that must be established during the object's creation
phase. This preemptive approach ensures that only objects intended for potential deletion are
equipped with this capability. It's important to note that not all objects are eligible for deletion,
and attempting to create a `DeleteRef` for such non-deletable objects will result in an error.
## Defining Structs
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Next, let's define our structs:
```rust
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
value: u64,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
extend_ref: ExtendRef,
transfer_ref: TransferRef,
delete_ref: DeleteRef,
}
```
- `MovementObject` is our main object that holds a value.
- `ControllerObject` holds the references that control the object's behavior.
## Initializing the Module
The `init_module` function sets up our initial object:
```rust
fun init_module(owner: &signer) {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let state_object_constructor_ref = object::create_named_object(owner,
MOVEMENT_OBJECT_NAME);
let state_object_signer = object::generate_signer(&state_object_constructor_ref);
move_to(&state_object_signer, MovementObject {
value: 10
});
let extend_ref = object::generate_extend_ref(&state_object_constructor_ref);
let transfer_ref = object::generate_transfer_ref(&state_object_constructor_ref);
let delete_ref = object::generate_delete_ref(&state_object_constructor_ref);
move_to(&state_object_signer, ControllerObject {
extend_ref,
transfer_ref,
delete_ref,
});
}
```
This function creates a named object, moves a `MovementObject` to it, and then creates and
stores the control references in a `ControllerObject`.
This function allows you to:
- Create objects that may or may not be transferrable.
- Make objects controllable (by storing the control references).
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Optionally allow objects to be deletable.
Similar to TransferRef and ExtendRef, when you use DeleteRef, you'll retrieve it from within the
ControllerObject to execute the deletion.
```rust
public entry fun delete(
caller: &signer,
object: Object<ControllerObject>,
) acquires ControllerObject {
// Only let caller delete
let caller_address = signer::address_of(caller);
assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
let object_address = object::object_address(object);
// Retrieve the delete ref, it is consumed so it must be extracted
// from the resource
let ControllerObject {
extend_ref: _,
transfer_ref: _,
delete_ref,
} = move_from<ControllerObject>(object_address);
// Delete the object forever!
object::delete(delete_ref);
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
This function:
- Checks if the caller is the owner of the object.
- Retrieves and consumes the `ControllerObject`.
- Uses the `DeleteRef` to delete the object.
## Conclusion
This module demonstrates advanced object control in Aptos Move:
- We can create objects with customizable properties (transferrable, controllable, deletable).
- We use `ExtendRef`, `TransferRef`, and `DeleteRef` to manage object behavior.
- We implement a deletion mechanism that respects object ownership.
By using these techniques, you can create more flexible and secure smart contracts in Aptos
Move, giving you fine-grained control over object lifecycle and permissions.
## Full Code
```ruby
module movement::object_module_entry {
use aptos_framework::object::{Self, Object, ExtendRef, TransferRef, DeleteRef};
use std::signer::address_of;
use std::debug::print;

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
const E_NOT_OWNER: u64 = 0;
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
value: u64
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct NewObject has key {
new_value: u64
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ControllerObject has key {
extend_ref: ExtendRef,
transfer_ref: TransferRef,
delete_ref: DeleteRef
}
fun init_module(owner: &signer) {
let state_object_constructor_ref = &object::create_named_object(owner,
MOVEMENT_OBJECT_NAME);
let state_object_signer = &object::generate_signer(state_object_constructor_ref);
move_to(state_object_signer, MovementObject {
value: 10
});
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let extend_ref = object::generate_extend_ref(state_object_constructor_ref);
let transfer_ref = object::generate_transfer_ref(state_object_constructor_ref);
let delete_ref = object::generate_delete_ref(state_object_constructor_ref);
move_to(state_object_signer, ControllerObject {
extend_ref,
transfer_ref,
delete_ref
});
}
fun freeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
let transfer_ref =
&borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
object::disable_ungated_transfer(transfer_ref);
}
fun unfreeze_object(my_object: Object<MovementObject>) acquires ControllerObject {
let transfer_ref =
&borrow_global_mut<ControllerObject>(object::object_address(&my_object)).transfer_ref;
object::enable_ungated_transfer(transfer_ref);
}
#[test_only]
fun test_init_module(onwer: &signer) {
init_module(onwer);
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

#[view]
public fun get_object_address(owner: address): address {
object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
}
#[view]
public fun get_object(owner: address): Object<MovementObject> {
object::address_to_object(get_object_address(owner))
}
public fun get_value(owner: address): u64 acquires MovementObject {
borrow_global<MovementObject>(get_object_address(owner)).value
}
#[view]
public fun get_owner_object(obj: Object<MovementObject>): address {
object::owner(obj)
}
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
let obj = get_object(owner);
assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can
transfer/modify it
let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
object_data.value = new_value;
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public fun transfer_obj(owner: &signer, new_owner: address) {
let owner_addr = address_of(owner);
let obj = get_object(owner_addr);
assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can
transfer/modify it
object::transfer(owner, obj, new_owner);
}
public fun add_new_object(owner: &signer, obj: Object<MovementObject>) acquires
ControllerObject {
let addr = address_of(owner);
assert!(object::is_owner(obj, addr), 1);
let object_address = object::object_address(&obj);
let extend_ref = &borrow_global<ControllerObject>(object_address).extend_ref;
let object_signer = object::generate_signer_for_extending(extend_ref);
move_to(&object_signer, NewObject { new_value: 50 });
}
public fun transfer_new_object(owner: &signer, new_owner: address) acquires
ControllerObject {
let transfer_ref =
&borrow_global_mut<ControllerObject>(get_object_address(address_of(owner))).transfer_ref;
let object_signer = object::generate_linear_transfer_ref(transfer_ref);
object::transfer_with_ref(object_signer, new_owner);
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public entry fun delete(
caller: &signer,
object: Object<ControllerObject>,
) acquires ControllerObject {
// Only let caller delete
let caller_address = address_of(caller);
assert!(object::is_owner(object, caller_address), E_NOT_OWNER);
let object_address = object::object_address(&object);
// Retrieve the delete ref, it is consumed so it must be extracted
// from the resource
let ControllerObject {
extend_ref: _,
transfer_ref: _,
delete_ref,
} = move_from<ControllerObject>(object_address);
// Delete the object forever!
object::delete(delete_ref);
}
}
```
# Object Ownership & Transfer Object
## Summary
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Implements object ownership in a Rust module for creating and managing movement objects
- Sets owner address during object creation
- Implements ownership checks for functions like `set_value`
- Demonstrates how to retrieve the owner's address of an object
- Implements a `transfer_obj` function to change object ownership
- Includes test functions to verify object creation, value setting, and ownership transfer
## Implementing Object Ownership
Now that we understand the concept of object ownership, let's apply it to our movement creation
function. This will allow us to assign specific owners to each movement object we create.
### Step 1: Update the `set_value` function
First, let's modify the `set_value` function to include an owner parameter:
```rust
public fun set_value(owner: address, value: u64): Object<MovementObject> {
// ... existing code ...
}
```
### Step 2: Set the owner address
Next, we'll update the object creation to use the provided is_owner address:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
object::is_owner(owner, signer::address_of(owner)
```
### Step 3: Implement ownership checks
Now that we have assigned an owner, we can implement functions that only the owner can call.
For example, a function to train the movement object:
```rust
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
assert!(object::is_owner(owner, signer::address_of(owner)), 1); // Only the owner can transfer
it
let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
object_data.value = new_value;
}
```
Alternatively, you can easily check the owner of an object using the function:
`object::owner(movement_object)`
```rust
#[view]
public fun get_owner_object(obj: Object<MovementObject>): address {
object::owner(obj)
}
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

We'll add another test to demonstrate how to retrieve the address of the object we've created.
```rust
#[test(account = @0x1)]
fun test_get_owner_object_address(account: &signer) {
test_init_module(account);
let addr = address_of(account);
let value = get_object(addr);
let get_owner = get_owner_object(value);
print(&get_owner);
}
```
Result:
```rust
[debug] @0x52152ca68792cb72eb58f6497c1c8fbe69f5fc5d938edf2e74ed8da6ae816622
```
### Step 4: Transfer Object
To transfer an object, we need the following information:
`object::transfer(current_owner_address, movement_object, new_owner_address)`
```rust
public fun transfer_obj(owner: &signer, new_owner: address) {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let owner_addr = address_of(owner); // get current owner address
let obj = get_object(owner_addr); // get Object<MovementObject>
assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can
transfer/modify it
object::transfer(owner, obj, new_owner); // Transfer
}
#[test(account = @0x1, new_owner = @0x2)]
fun test_transfer_object(account: &signer, new_owner: address) {
test_init_module(account);
transfer_obj(account, new_owner);
}
```
By implementing these steps, we've successfully integrated object ownership into our
movement creation and training functions. This allows for more secure and personalized
interactions with the movement objects in our module.
## Full Code
```rust
module movement::object_module_entry {
use aptos_framework::object::{Self, Object};
use std::signer::address_of;
use std::debug::print;
const MOVEMENT_OBJECT_NAME: vector<u8> = b"MovementObjectName";
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementObject has key {
value: u64
}
fun init_module(owner: &signer) {
let state_object_constructor_ref = &object::create_named_object(owner,
MOVEMENT_OBJECT_NAME);
let state_object_signer = &object::generate_signer(state_object_constructor_ref);
move_to(state_object_signer, MovementObject {
value: 10
});
}
#[test_only]
fun test_init_module(onwer: &signer) {
init_module(onwer);
}
#[view]
public fun get_object_address(owner: address): address {
object::create_object_address(&owner, MOVEMENT_OBJECT_NAME)
}
#[view]
public fun get_object(owner: address): Object<MovementObject> {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

object::address_to_object(get_object_address(owner))
}
public fun get_value(owner: address): u64 acquires MovementObject {
borrow_global<MovementObject>(get_object_address(owner)).value
}
#[view]
public fun get_owner_object(obj: Object<MovementObject>): address {
object::owner(obj)
}
public fun set_value(owner: address, new_value: u64) acquires MovementObject {
let obj = get_object(owner);
assert!(object::is_owner<MovementObject>(obj, owner), 1); // Only the owner can
transfer/modify it
let object_data = borrow_global_mut<MovementObject>(get_object_address(owner));
object_data.value = new_value;
}
public fun transfer_obj(owner: &signer, new_owner: address) {
let owner_addr = address_of(owner);
let obj = get_object(owner_addr);
assert!(object::is_owner<MovementObject>(obj, owner_addr), 1); // Only the owner can
transfer/modify it
object::transfer(owner, obj, new_owner);
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

#[test(account = @0x1, new_owner = @0x2)]
fun test_transfer_object(account: &signer, new_owner: address) {
test_init_module(account);
transfer_obj(account, new_owner);
}
#[test(account = @0x1)]
fun test_get_owner_object_address(account: &signer) {
test_init_module(account);
let addr = address_of(account);
let obj = get_object(addr);
let get_owner = get_owner_object(obj);
print(&get_owner);
}
#[test(account = @0x1)]
fun test_get_object_address(account: &signer) {
test_init_module(account);
let addr = address_of(account);
let value = get_object_address(addr);
print(&value);
}
#[test(account = @0x1)]
fun test_get_object(account: &signer) acquires MovementObject {
test_init_module(account);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let addr = address_of(account);
let value = get_value(addr);
assert!(value == 10, 0);
}
#[test(account = @0x1)]
fun test_set_object(account: &signer) acquires MovementObject {
test_init_module(account);
let addr = address_of(account);
set_value(addr, 20);
let value = get_value(addr);
assert!(value == 20, 1);
}
}
```
# Local Storage & Global Storage Operations

💡

<aside>

## Summary
- Move is a Resource-Oriented Programming language focusing on resources rather than
accounts
- Local storage uses the `let` keyword for variables with limited scope and lifespan
- Global storage provides persistent data storage on the blockchain using a tree-like structure

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Global storage operations include `move_to`, `move_from`, `borrow_global`,
`borrow_global_mut`, and `exists`
- Resources in global storage require the `key` ability and must be owned by an address
- The `drop` ability allows resources to be removed from global storage
- Move programs can read from and write to global storage, but cannot access external
resources
</aside>
## Overview
Move is a Resource-Oriented Programming (`ROP`) language, where the entire system centers
around resources instead of accounts as in many traditional blockchains, also known as
`Resource-Centric`.
In the topic below, we will explore how Global Storage and Local Storage work in Move, and
how you can create data stored in these two storage types.
## Local Storage ( Local Variable )
In Move, local variables operate within a specific scope and have a limited lifespan. They are
declared using the `let` keyword and possess unique characteristics:
- Scope: Variables are confined to the block where they are defined
- Shadowing: New declarations can overshadow existing variables with the same name
- Mutability: Values can be modified directly or through mutable references
- Flexibility: They can hold various data types, from simple integers to complex structures

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```bash
module movement::local_storage {
fun local_variables(){
let b: u8;
let c = false;
let d = b"hello world";
let e: u64 = 10_000;
}
}
```
All the variables mentioned above are created within the `local_variables` function. As a result,
they only exist within the function's scope. When this function ends, all variables within it will be
`dropped`.
Additionally, we can create resources and structs as local storage through a struct ability in
`move` called "drop". This ability allows the struct or resource to be dropped after the function
ends, aligning with the characteristics of local variables you've read about above.
For example:
```rust
module movement::local_global_storage {
use std::debug::print;
use std::signer;
struct LocalData has drop {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

value: u64
}
public entry fun new_local(value: u64) {
let data = LocalData {
value: value
};
let local_var = b"Local Storage Data";
print(&data);
print(&local_var);
}
#[test]
fun test_new_local() {
new_local(10);
}
}
```
In the `new_local` function, you can see that after the `LocalData` resource is created, it's not
owned by anyone and isn't transferred anywhere. This means that when the new_local function
ends, `LocalData` will be dropped. For the Move compiler to allow this, `LocalData` must have
the `drop` ability and must not have the `key` ability.
### Global Storage
**Global storage in Move:**
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Enables persistent data storage on the blockchain
- Maintains long-term data accessibility across transactions and contracts
- Uses a tree-like structure for efficient organization and retrieval
- Key-value pairing system for precise data management
**Move programs interact with global storage by:**
1. Reading existing data
2. Writing new or updated information
**Limitations:**
- Cannot access external resources (e.g., filesystems, networks)
- Ensures data manipulations occur within the blockchain's controlled environment
- Maintains security and consistency across the system
```rust
struct GlobalStorage {
resources: Map<(address, ResourceType), ResourceValue>
modules: Map<(address, ModuleName), ModuleBytecode>
}
```
Let's examine the example below for a clearer understanding:
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

module movement::local_global_storage {
use std::debug::print;
struct GlobalData has key {
value: u64
}
public entry fun new_global(signer: &signer, value: u64) {
let data = GlobalData {
value: value
};
move_to(signer, data);
}
#[test(account = @0x1)]
fun test_new_global(account: &signer) {
new_global(account, 10);
}
}
```
In the code above, after initializing `GlobalData` and storing it in a variable called data, if you
stop here, the compiler will throw an error when you build. This is because `GlobalData`
contains the `key` ability. Consequently, this data needs to be stored in global storage. However,
to store it in global storage, you must assign this Resource an owner in the form of a Map. In
this case, we'll store it under the signer who called this function. The result of the function will
create a resource and transfer it to the address of the caller.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Here's the `GlobalStorage` data after you initialize it using the `new_global` function:
```json
{
"0x40264b8d01986e70c79999a189e4c4043aad3ec970d00a095cf29b2916eda04d::local_global
_storage::GlobalData": {
"value": "10"
}
}
```
For global data, you can only access it through these native functions provided by Move:
| Operation | Description | Aborts? |
| --- | --- | --- |
| `move_to<T>(&signer,T)` | Publish `T` under `signer.address` | If `signer.address` already
holds a `T` |
| `move_from<T>(address): T` | Remove `T` from `address` and return it | If `address` does not
hold a `T` |
| `borrow_global_mut<T>(address): &mut T` | Return a mutable reference to the `T` stored
under `address` | If `address` does not hold a `T` |
| `borrow_global<T>(address): &T` | Return an immutable reference to the `T` stored under
`address` | If `address` does not hold a `T` |
| `exists<T>(address): bool` | Return `true` if a `T` is stored under `address` | Never |

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### Example Code:
```ruby
module movement::local_global_storage {
use std::debug::print;
use std::signer::address_of;
struct GlobalData has key {
value: u64
}
const EResourceNotExist: u64 = 33;
public entry fun new_global(signer: &signer, value: u64) {
let data = GlobalData {
value: value
};
move_to(signer, data);
}
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires
GlobalData {
let addr = address_of(signer);
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
*value_reference = *value_reference + value;
}
public fun check_global_storage_exists(addr: address): bool {
exists<GlobalData>(addr)
}
#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = borrow_global<GlobalData>(addr);
value_reference.value
}
#[test(account = @0x1)]
fun test_new_global(account: &signer) {
new_global(account, 10);
}
}
```
### Delete Resource

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

The `move_from` function is a crucial part of resource management in Move. It allows for the
removal of a resource from an account or address. However, there's an important caveat: the
resource must have the "drop" ability to be used with `move_from`. This requirement serves as
a safety mechanism, preventing accidental or unauthorized deletion of resources.
Key points to understand:
- Resources without the "drop" ability cannot be removed, ensuring their permanence.
- This feature gives developers fine-grained control over resource lifecycle management.
- It's particularly useful for creating persistent resources that should remain intact throughout a
contract's lifetime.
By implementing this safeguard, Move enhances the security and predictability of smart
contracts, allowing developers to design more robust and controlled resource management
systems.
1. Drop Ability
```rust
struct GlobalData has key, drop {
value: u64
}
```
1. move_from
```ruby
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData
{
let rev = move_from<GlobalData>(address_of(account));
}
```
### Full Code
```ruby
module movement::local_global_storage {
use std::debug::print;
use std::signer::address_of;
struct GlobalData has key, drop {
value: u64
}
const EResourceNotExist: u64 = 33;
const ENotEqual: u64 = 10;
public entry fun new_global(signer: &signer, value: u64) {
let data = GlobalData {
value: value
};
move_to(signer, data);
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires
GlobalData {
let addr = address_of(signer);
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
*value_reference = *value_reference + value;
}
public fun check_global_storage_exists(addr: address): bool {
exists<GlobalData>(addr)
}
#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = borrow_global<GlobalData>(addr);
print(&value_reference.value);
value_reference.value
}
public entry fun remove_resource_from_global_storage(account: &signer) acquires
GlobalData {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let rev = move_from<GlobalData>(address_of(account));
}
#[test(account = @0x1)]
fun test_new_global(account: &signer) {
new_global(account, 10);
}
#[test(account = @0x1)]
fun test_change_value_global(account: &signer) acquires GlobalData {
new_global(account, 10);
change_value_from_global_storage(account, 10); // value should be equal 20
let value = get_value_from_global_storage(address_of(account));
assert!(value == 20, ENotEqual);
// remove resource
remove_resource_from_global_storage(account);
assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
}
}
```
> Running test:
>
```rust
movement move test -f local_global_storage
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

> Result:
>
```rust
Running Move unit tests
[debug] 20
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_sto
rage::test_change_value_global
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_sto
rage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
"Result": "Success"
}
```
## Understanding the 'acquires' Keyword in Move
The 'acquires' keyword in Move is an important concept related to global storage operations.
Here's what you need to know about it:
### Purpose of 'acquires'

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

The 'acquires' keyword is used to declare that a function may access (or "acquire") a specific
resource from global storage. It's a way of explicitly stating which global resources a function
intends to use.
### How it Works
1. Declaration: When you define a function that needs to access a global resource, you add
'acquires' followed by the resource type after the function signature.
2. Compiler Check: The Move compiler uses this information to ensure that the function only
accesses the declared resources, preventing unintended access to other global resources.
3. Safety: It helps in preventing race conditions and ensures safe concurrent execution of
transactions.
### Example Usage
```rust
public fun read_global_data(addr: address): u64 acquires GlobalData {
borrow_global<GlobalData>(addr).value
}
```
In this example, the function declares that it will acquire the 'GlobalData' resource from global
storage.
### Important Notes

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Multiple Resources: A function can acquire multiple resources by listing them after 'acquires',
separated by commas.
- Nested Calls: If a function calls another function that acquires a resource, the calling function
must also declare that it acquires that resource.
- Compiler Enforcement: The Move compiler will throw an error if a function tries to access a
global resource without declaring it with 'acquires'.
By using 'acquires', Move provides a clear and safe way to manage access to global storage,
enhancing the security and predictability of smart contracts.
# Deploy & Call function on-chain
## Summary
- Explores deploying modules and calling on-chain functions on the Movement testnet
- Covers setup of Movement environment and project initialization
- Demonstrates creating and publishing a Move smart contract
- Shows how to interact with deployed modules using the Movement explorer
- Focuses on understanding on-chain operations and global storage in Move
- Provides step-by-step instructions for developers new to the Movement ecosystem
## Overview
To better understand how on-chain operations or global storage work, we will explore together
the process of deploying modules (smart contracts) on the Movement testnet, and then try
calling on-chain functions through the explorer to gain a clearer understanding of them.
## 1. Setup Movement Environment
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

First, you need to set up your development environment. Follow the guide in the Movement
documentation to set up the Suzuka network.
https://docs.movementnetwork.xyz/devs/getstarted
## 2. Initialize Project
- **Initialize your Aptos profile** for package development and add Movement as a custom
network:
```ruby
aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
```
```bash
❯ aptos init --network custom --rest-url https://aptos.testnet.suzuka.movementlabs.xyz/v1
Configuring for profile default
Configuring for network Custom
Using command line argument for rest URL https://aptos.testnet.suzuka.movementlabs.xyz/v1
Enter your faucet endpoint [Current: None | No input: Skip (or keep the existing one if present) |
'skip' to not use a faucet]
No faucet url given, skipping faucet...
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or
keep one if present)]

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

No key given, generating key...
Account 0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 has
been initialized locally, but you must transfer coins to it to create the account onchain
--Aptos CLI is now set up for account
0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4 as profile
default!
See the account here:
https://explorer.aptoslabs.com/account/0x7d470166da365d4ab4ac22c0159827ca0502c0b971a
d2f9edda8e493332290c4?network=custom
Run `aptos --help` for more information about commands
{
"Result": "Success"
}
```
> In the returned result, we will have the account:
`0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4`. This will be
the account you'll use to execute default functions and deploy code. Alternatively, you can check
these details in the `/.aptos/config.yaml` file.
>
```yaml
--profiles:
default:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

network: Custom
private_key:
"0x7423d9d69830987a371836e6ea417a5a5626c119ab9c2a868e85cb890e114587"
public_key: "0x4d2491d2c2ead56335cd960c484cf8a3ab9c4a6476fc0b9b6ef6a8dfa1e7c566"
account: 7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4
rest_url: "https://aptos.testnet.suzuka.movementlabs.xyz/v1"
```
- Initialize your move project
```ruby
movement move init --name hello_blockchain
```
## 3. Create a Move file in sources/name.move
Initialize a .move file in the sources/ folder and copy the code from the previous topic into it:
```ruby
module movement::local_global_storage {
use std::debug::print;
use std::signer::address_of;
struct GlobalData has key {
value: u64
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

const EResourceNotExist: u64 = 33;
public entry fun new_global(signer: &signer, value: u64) {
let data = GlobalData {
value: value
};
move_to(signer, data);
}
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires
GlobalData {
let addr = address_of(signer);
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
*value_reference = *value_reference + value;
}
public fun check_global_storage_exists(addr: address): bool {
exists<GlobalData>(addr)
}
#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
if (!check_global_storage_exists(addr)) {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

abort EResourceNotExist
};
let value_reference = borrow_global<GlobalData>(addr);
value_reference.value
}
#[test(account = @0x1)]
fun test_new_global(account: &signer) {
new_global(account, 10);
}
}
```
1. Modify Move.toml
```toml
[package]
name = "move-101"
version = "1.0.0"
authors = []
[addresses]
# Change your address you created in step 1
movement =
"0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4"
[dev-addresses]
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dev-dependencies]
```
1. Publish your module to the blockchain
```bash
movement move publish --named-addresses movement=default
```
- If executed successfully, the result will appear as shown below:
```bash
Compiling, may take a little while to download git dependencies...
UPDATING GIT DEPENDENCY https://github.com/aptos-labs/aptos-core.git
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING move-101
package size 1945 bytes

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Transaction submitted:
https://explorer.aptoslabs.com/txn/0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941
b087908f6b17596?network=custom
{
"Result": {
"transaction_hash":
"0x852c187c3290dbf33eb1bff10f6e2a4639c44ada1aa2b0941b087908f6b17596",
"gas_used": 1689,
"gas_unit_price": 100,
"sender": "7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4",
"sequence_number": 0,
"success": true,
"timestamp_us": 1727447905936816,
"version": 258811098,
"vm_status": "Executed successfully"
}
}
```
1. Check the transaction on the Movement testnet explorer using this link:
https://explorer.movementlabs.xyz/?network=testnet
![Screenshot 2024-09-27 at
22.22.45.png](/content-images/Deploy%20&%20Call%20function%20on_chain/Screenshot_202
4-09-27_at_22.22.45.png)

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

2. Alternatively, you can search using the account address and navigate to the "Modules" tab:
`0x7d470166da365d4ab4ac22c0159827ca0502c0b971ad2f9edda8e493332290c4`
![Screenshot 2024-09-27 at
22.17.40.png](/content-images/Deploy%20&%20Call%20function%20on_chain/Screenshot_202
4-09-27_at_22.17.40.png)
3. Run and View will list the functions available in your module.
![Screenshot 2024-09-27 at
22.24.15.png](/content-images/Deploy%20&%20Call%20function%20on_chain/Screenshot_202
4-09-27_at_22.24.15.png)
# Writing/Reading resources to user accounts
## Summary

💡

<aside>

Key points about global storage in Move:
- Global storage allows persistent data storage associated with addresses
- Resources stored in global storage must have the 'key' ability
- Use 'move_to' to store data and 'borrow_global' to access it
- Always check if a resource exists before attempting to access it
- Mutable access requires `borrow_global_mut` and proper access control
- The 'acquires' keyword is necessary for functions that access global storage
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

</aside>
## Writing/Reading resources
Based on the previous topic, we've learned how to create a resource and store it in global
storage. Now, let's explore how to access and interact with data in global storage.
```ruby
module movement::local_global_storage {
use std::debug::print;
use std::signer::address_of;
struct GlobalData has key {
value: u64
}
const EResourceNotExist: u64 = 33;
public entry fun new_global(signer: &signer, value: u64) {
let data = GlobalData {
value: value
};
move_to(signer, data);
}
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires
GlobalData {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let addr = address_of(signer);
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
*value_reference = *value_reference + value;
}
public fun check_global_storage_exists(addr: address): bool {
exists<GlobalData>(addr)
}
#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = borrow_global<GlobalData>(addr);
value_reference.value
}
#[test(account = @0x1)]
fun test_new_global(account: &signer) {
new_global(account, 10);
}
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
> Running test:
>
```rust
movement move test -f test_new_global
```
> Result:
>
```rust
Running Move unit tests
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_sto
rage::test_new_globalTest result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
}
```
Let's break down the code and explain it step by step:
### 1. Struct Definition
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

struct GlobalData has key {
value: u64
}
```
Here, we define a struct called `GlobalData` with the `key` ability, allowing it to be stored in
global storage. It contains a single field `value` of type `u64`.
### 2. Error Constant
```rust
const EResourceNotExist: u64 = 33;
```
This defines an error code that will be used when a resource doesn't exist in global storage.
### 3. Function to Create Global Storage
```rust
public entry fun new_global(signer: &signer, value: u64) {
let data = GlobalData {
value: value
};
move_to(signer, data);
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

This function creates a new `GlobalData` instance and moves it to the signer's address in global
storage.
### 4. Function to Modify Global Storage
```rust
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires
GlobalData {
let addr = address_of(signer);
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = &mut borrow_global_mut&lt;GlobalData&gt;(addr).value;
*value_reference = *value_reference + value;
}
```
This function modifies the value in global storage. It first checks if the resource exists, then
borrows a mutable reference to update the value.
### 5. Function to Check Global Storage Existence
```rust
public fun check_global_storage_exists(addr: address): bool {
exists&lt;GlobalData&gt;(addr)
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
This function checks if `GlobalData` exists at a given address.
### 6. Function to Read from Global Storage
```rust
#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = borrow_global&lt;GlobalData&gt;(addr);
value_reference.value
}
```
This function reads the value from global storage. It first checks if the resource exists, then
borrows an immutable reference to read the value.
### Using Global Storage in Move
1. Create a new global storage entry:
- Use the `new_global` function, providing a signer and an initial value.
- This stores the data under the signer's address.
2. Check if global storage exists:
- Use the `check_global_storage_exists` function, passing an address.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- This returns a boolean indicating whether the data exists.
3. Modify data in global storage:
- Use the `change_value_from_global_storage` function.
- This function adds the provided value to the existing value in storage.
4. Read data from global storage:
- Use the `get_value_from_global_storage` function, passing an address.
- This returns the current value stored at that address.
By following these steps, you can effectively work with global storage in Move, ensuring proper
data management and access across your smart contract.
# Destroying a resource

💡

<aside>

**Key Takeaways:**
- The `move_from` function removes a resource from an account or address.
- Resources must have the "drop" ability to use `move_from`.
- The "drop" ability prevents unintentional deletion of resources.
- It allows control over whether resources can be deleted or should persist.
- The code demonstrates how to implement and use `move_from` in a Move module.
- The module includes functions for creating, modifying, and removing global storage.
</aside>
Among the provided functions in the previous topics, we haven't yet discussed `move_from`.
This function removes a resource from an account or address. It's crucial to note that to use
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

`move_from` for a resource, you must ensure the resource has the "drop" ability. Without this,
the compiler will throw an error. This safeguard prevents resources from being unintentionally
deleted, either accidentally or in cases where you want resources to remain permanent. It
allows you to control whether resources can be deleted or should persist indefinitely.
1. Drop Ability
```rust
struct GlobalData has key, drop {
value: u64
}
```
1. move_from
```ruby
public entry fun remove_resource_from_global_storage(account: &signer) acquires GlobalData
{
let rev = move_from<GlobalData>(address_of(account));
}
```
### Full Code
```ruby
module movement::local_global_storage {
use std::debug::print;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

use std::signer::address_of;
struct GlobalData has key, drop {
value: u64
}
const EResourceNotExist: u64 = 33;
const ENotEqual: u64 = 10;
public entry fun new_global(signer: &signer, value: u64) {
let data = GlobalData {
value: value
};
move_to(signer, data);
}
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires
GlobalData {
let addr = address_of(signer);
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
*value_reference = *value_reference + value;
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public fun check_global_storage_exists(addr: address): bool {
exists<GlobalData>(addr)
}
#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = borrow_global<GlobalData>(addr);
print(&value_reference.value);
value_reference.value
}
public entry fun remove_resource_from_global_storage(account: &signer) acquires
GlobalData {
let rev = move_from<GlobalData>(address_of(account));
}
#[test(account = @0x1)]
fun test_new_global(account: &signer) {
new_global(account, 10);
}
#[test(account = @0x1)]
fun test_change_value_global(account: &signer) acquires GlobalData {
new_global(account, 10);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

change_value_from_global_storage(account, 10); // value should be equal 20
let value = get_value_from_global_storage(address_of(account));
assert!(value == 20, ENotEqual);
// remove resource
remove_resource_from_global_storage(account);
assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
}
}
```
> Running test:
>
```rust
movement move test -f local_global_storage
```
> Result:
>
```rust
Running Move unit tests
[debug] 20
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_sto
rage::test_change_value_global

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::local_global_sto
rage::test_new_globalTest result: OK. Total tests: 2; passed: 2; failed: 0
{
"Result": "Success"
}
```
# Resource Groups

💡

<aside>

**Summary:**
- Resource groups in Move allow grouping of multiple resources with different fields.
- They function similarly to regular resources but offer more efficient storage.
- Resources in a group are stored close together in global storage memory.
- This proximity ensures quicker queries and reduced processing costs.
- The code example demonstrates creating and using resource groups with multiple fields.
- Resource groups are a current solution for complex resources, with `objects` feature planned
for future optimization.
</aside>
In real-world projects, sometimes one of your resources will have many different fields. Although
in the future we may use the `objects` feature to optimize complex resources (which will be
shared in upcoming topics), for now we can also create resources and group them together in a
group. Below is an example:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```ruby
module movement::resource_group {
use std::string::{utf8, String};
use std::signer::address_of;
#[resource_group(scope = global)]
struct MovementGroup {}
#[resource_group_member(group = MovementGroup)]
struct Group1 has key {
field1: u64,
field2: String,
field3: address,
field4: bool
}
#[resource_group_member(group = MovementGroup)]
struct Group2 has key {
field5: u64,
field6: String,
field7: address,
field8: bool
}
public entry fun create_group_resource(account: &signer) {
let addr = address_of(account);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let group1 = Group1 {
field1: 100,
field2: utf8(b"hello"),
field3: addr,
field4: true
};
move_to(account, group1);
let group2 = Group2 {
field5: 200,
field6: utf8(b"hello 2"),
field7: addr,
field8: false
};
move_to(account, group2);
}
#[view]
public fun get_gresource_one(addr: address): u64 acquires Group1 {
borrow_global<Group1>(addr).field1
}
#[view]
public fun get_gresource_two(addr: address): u64 acquires Group2 {
borrow_global<Group2>(addr).field5
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

#[test(account = @0x1)]
fun test_create_group(account: &signer){
create_group_resource(account);
}
}
```
> Running test:
>
```rust
movement move test -f test_create_group
```
> Result:
>
```rust
Running Move unit tests
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::resource_group:
:test_create_group
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
}
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

> In terms of functionality and usage, Resource groups are not different from regular
resources—they only support more efficient storage. In the memory of global storage, these
resources are stored close to each other, ensuring quick queries and reduced processing
costs/fee.
>
![image.png](/content-images/Resource%20Groups/image.png)
# Events
## Summary

🏆

<aside>

**Key Points:**
- Events are crucial functions in smart contracts for capturing and communicating occurrences
within modules.
- They enable back-end systems to differentiate activities and execute various tasks like sending
notifications or performing off-chain calculations.
- Event structs are defined with 'drop' and 'store' abilities, using the #[event] macro.
- The event::emit function is called after function execution to create an event.
- Events can contain specific information, such as values and executor addresses, visible in
transaction details.
- Implementation involves modifying existing functions to include event emission.
</aside>
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

## Overview
Events are one of the crucial functions in most smart contracts. They help back-end systems
capture events that have occurred and are occurring on your modules (smart contracts). You
can harness the power of Events to create distinct messages. These messages can contain
various information and data from your modules. Your back-end can use these messages to
differentiate activities and execute various tasks on your application, such as sending
notifications or performing off-chain calculations
**Returning to the example code for local and global storage:**
```ruby
module movement::local_global_storage {
use std::debug::print;
use std::signer::address_of;
struct GlobalData has key, drop {
value: u64
}
const EResourceNotExist: u64 = 33;
const ENotEqual: u64 = 10;
public entry fun new_global(signer: &signer, value: u64) {
let data = GlobalData {
value: value
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

};
move_to(signer, data);
}
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires
GlobalData {
let addr = address_of(signer);
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
*value_reference = *value_reference + value;
}
public fun check_global_storage_exists(addr: address): bool {
exists<GlobalData>(addr)
}
#[view]
public fun get_value_from_global_storage(addr: address): u64 acquires GlobalData {
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = borrow_global<GlobalData>(addr);
print(&value_reference.value);
value_reference.value
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
public entry fun remove_resource_from_global_storage(account: &signer) acquires
GlobalData {
let rev = move_from<GlobalData>(address_of(account));
}
#[test(account = @0x1)]
fun test_new_global(account: &signer) {
new_global(account, 10);
}
#[test(account = @0x1)]
fun test_change_value_global(account: &signer) acquires GlobalData {
new_global(account, 10);
change_value_from_global_storage(account, 10); // value should be equal 20
let value = get_value_from_global_storage(address_of(account));
assert!(value == 20, ENotEqual);
// remove resource
remove_resource_from_global_storage(account);
assert!(!check_global_storage_exists(address_of(account)), EResourceNotExist);
}
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

To create an event when executing a function, we need to define structs with the 'drop' and
'store' abilities. Additionally, we use the #[event] macro to inform the compiler that this struct is
intended for creating events.
```ruby
#[event]
struct EventChangeValue has drop, store {
value: u64,
executor: address
}
```
Then we call `event::emit` after the function has finished executing.
```ruby
public entry fun change_value_from_global_storage(signer: &signer, value: u64) acquires
GlobalData {
let addr = address_of(signer);
if (!check_global_storage_exists(addr)) {
abort EResourceNotExist
};
let value_reference = &mut borrow_global_mut<GlobalData>(addr).value;
*value_reference = *value_reference + value;
event::emit(EventChangeValue {
value,
executor: addr
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

});
}
```
After execution is complete, you can check the transaction and you will see an event with 2
pieces of information: executor and value
![Screenshot 2024-09-27 at
21.47.27.png](/content-images/Events/Screenshot_2024-09-27_at_21.47.27.png)
# Smart Vector
## Summary
- Smart Vector is an advanced data structure in the Aptos Framework designed to optimize data
management in large-scale applications.
- It combines the strengths of vectors, simple maps, and traditional tables while mitigating their
weaknesses.
- Smart Vector uses a bucket system to efficiently store and access large amounts of data,
potentially reducing gas fees and improving performance.
- The structure automatically divides elements into multiple buckets, optimizing both reading and
writing processes.
- Smart Vector offers a solution to performance bottlenecks often encountered when scaling
applications with conventional data structures.
- Implementation involves creating a SmartVector, adding elements, and storing it within a
custom struct in the account's storage.
## Overview
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

As you progress beyond the foundational P0 course, you'll encounter more complex data
management challenges. While vectors and simple maps serve well for small-scale projects,
they often fall short when handling larger datasets. To effectively scale your applications, it's
crucial to adopt more advanced data structures.
One common pitfall in software development is underestimating the performance impact of data
growth. As your application expands, operations that were once swift on vectors and simple
maps can become significant bottlenecks, leading to increased processing time and resource
consumption.
Conventional tables present an alternative strategy, offering pinpoint access to specific data
elements. While this granular control can be beneficial, it's essential to weigh the storage costs
associated with expanding these tables.
This is where smart tables and smart vector, a cutting-edge feature of the Aptos Framework,
come into play. These sophisticated data structures are engineered to harness the strengths of
vectors, simple maps, and traditional tables while mitigating their weaknesses. By leveraging
smart tables & smart vector, developers can streamline data management, potentially reducing
gas fees and boosting overall system performance.
## Create a Smart Vector
```ruby
module movement::smart_vector_module {
use aptos_std::smart_vector::{Self, SmartVector};

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

struct MovementObject has key {
value: SmartVector<u64>
}
fun init_module(caller: &signer) {
let smartvec = smart_vector::new<u64>();
smart_vector::push_back(&mut smartvec, 1);
smart_vector::push_back(&mut smartvec, 2);
smart_vector::push_back(&mut smartvec, 3);
move_to(caller, MovementObject {
value: smartvec
});
}
}
```
1. Module Declaration:
```ruby
module movement::smart_vector_module {
// Module contents
}
```
This declares a new module named "smart_vector_module" within the "movement" package.
1. Importing the Smart Vector:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```ruby
use aptos_std::smart_vector::{Self, SmartVector};
```
This line imports the SmartVector type and its associated functions from the Aptos standard
library.
1. Defining a Custom Struct:
```ruby
struct MovementObject has key {
value: SmartVector<u64>;
}
```
This defines a new struct called MovementObject with a SmartVector of unsigned 64-bit integers
(u64) as its value.
1. Initializing the Module:
```ruby
fun init_module(caller: &signer) {
// Function body
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

This function is called when the module is first published. It takes a reference to the signer
(account) publishing the module.
1. Creating a New Smart Vector:
```ruby
let smartvec = smart_vector::new<u64>();
```
This creates a new SmartVector that will hold u64 values.
1. Adding Elements to the Smart Vector:
```ruby
smart_vector::push_back(&mut smartvec, 1);
smart_vector::push_back(&mut smartvec, 2);
smart_vector::push_back(&mut smartvec, 3);
```
These lines add the values 1, 2, and 3 to the end of the SmartVector.
1. Creating and Storing the MovementObject:
```ruby
move_to(caller, MovementObject {
value: smartvec
});
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
This creates a new MovementObject with the SmartVector we just populated, and stores it in the
account's storage.
## Running Test
```ruby
module movement::smart_vector_module {
use aptos_std::smart_vector::{Self, SmartVector};
use std::debug::print;
use std::signer::address_of;
struct MovementObject has key {
value: SmartVector<u64>
}
fun init_module(caller: &signer) {
let smartvec = smart_vector::new<u64>();
smart_vector::push_back(&mut smartvec, 1);
smart_vector::push_back(&mut smartvec, 2);
smart_vector::push_back(&mut smartvec, 3);
move_to(caller, MovementObject {
value: smartvec
});
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

#[test_only]
fun test_init_module(caller: &signer) {
init_module(caller);
}
#[view]
public fun get_length(addr: address): u64 acquires MovementObject {
let vec = &borrow_global<MovementObject>(addr).value;
smart_vector::length(vec)
}
#[test(caller = @0x1)]
fun test_get_length(caller: &signer) acquires MovementObject {
test_init_module(caller);
let len = get_length(address_of(caller));
print(&len);
}
}
```
> Running test:
>
```rust
movement move test -f test_get_length
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

> Result:
>
```bash
Running Move unit tests
[debug] 3
[ PASS ]
0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_m
odule::test_get_length
Test result: OK. Total tests: 1; passed: 1; failed: 0
{
"Result": "Success"
}
```
## How Smart Vector works
If you deploy modules and create a smart vector object, you can check the account data and
you'll see an object like this:
```json
{
"0x5fdf6936671d4e4a89b686aff0b5a4dfe083babbaaa6e78f5daa8801f94938a6::smart_vector_
module::MovementObject": {
"value": {
"big_vec": {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

"vec": []
},
"bucket_size": {
"vec": []
},
"inline_capacity": {
"vec": []
},
"inline_vec": [
"1",
"2",
"3"
]
}
}
}
```
Here, the smart vector stores data in `bucket`s, allowing it to hold a large number of elements
while optimizing gas costs for users. Each `bucket` is a standard vector that stores the elements
of the smart vector.
```rust
module movement::smart_vector_module {
use aptos_std::smart_vector::{Self, SmartVector};
use std::debug::print;
use std::signer::address_of;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

struct MovementObject has key {
value: SmartVector<u64>
}
fun init_module(caller: &signer) {
let smartvec = smart_vector::new<u64>();
let i = 0;
while (i <= 1000) {
smart_vector::push_back(&mut smartvec, i);
i = i + 1;
};
move_to(caller, MovementObject {
value: smartvec
});
}
#[test_only]
fun test_init_module(caller: &signer) {
init_module(caller);
}
#[view]
public fun get_length(addr: address): u64 acquires MovementObject {
let vec = &borrow_global<MovementObject>(addr).value;
smart_vector::length(vec)
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

#[test(caller = @0x1)]
fun test_get_length(caller: &signer) acquires MovementObject {
test_init_module(caller);
let len = get_length(address_of(caller));
print(&len);
}
}
```
In the example above, I input 1000 elements using a `while loop`. When checking the result with
the command `movement account list`, you'll see the following output:
```json
{
"0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_vector_
module::MovementObject": {
"value": {
"big_vec": {
"vec": [
{
"bucket_size": "128",
"buckets": {
"inner": {
"handle":
"0xfb918a6dc3e0db1a6bef0ebdf53554f0fc759c01018c5012071fe2c4a86e8b80"
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

},
"length": "8"
},
"end_index": "983"
}
]
},
"bucket_size": {
"vec": []
},
"inline_capacity": {
"vec": []
},
"inline_vec": [
"0",
"1",
"2",
"3",
"4",
"5",
"6",
"7",
"8",
"9",
"10",
"11",
"12",
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

"13",
"14",
"15",
"16",
"17"
]
}
}
},
```
Here, the smart vector automatically divides elements into multiple buckets. For example, when
you access elements from 0-100, it only accesses the bucket containing those specific
elements. This approach optimizes both the reading and writing processes of the smart vector.
## Additional Smart Vector Functions
| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
| `new` | None | Creates an empty SmartVector | `SmartVector<T>` |
| `empty` | None | Creates an empty SmartVector (deprecated) | `SmartVector<T>` |
| `empty_with_config` | `inline_capacity: u64`, `bucket_size: u64` | Creates an empty
SmartVector with custom configuration | `SmartVector<T>` |
| `singleton` | `element: T` | Creates a SmartVector with a single element | `SmartVector<T>` |
| `destroy_empty` | `self: SmartVector<T>` | Destroys an empty SmartVector | None |
| `destroy` | `self: SmartVector<T>` | Destroys a SmartVector | None |
| `clear` | `self: &mut SmartVector<T>` | Clears all elements from a SmartVector | None |
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

| `borrow` | `self: &SmartVector<T>`, `i: u64` | Borrows the i-th element | `&T` |
| `borrow_mut` | `self: &mut SmartVector<T>`, `i: u64` | Mutably borrows the i-th element | `&mut
T` |
| `append` | `self: &mut SmartVector<T>`, `other: SmartVector<T>` | Moves all elements from
other to self | None |
| `add_all` | `self: &mut SmartVector<T>`, `vals: vector<T>` | Adds multiple values to the vector |
None |
| `to_vector` | `self: &SmartVector<T>` | Converts SmartVector to a native vector | `vector<T>` |
| `push_back` | `self: &mut SmartVector<T>`, `val: T` | Adds an element to the end | None |
| `pop_back` | `self: &mut SmartVector<T>` | Removes and returns the last element | `T` |
| `remove` | `self: &mut SmartVector<T>`, `i: u64` | Removes and returns the i-th element | `T` |
| `swap_remove` | `self: &mut SmartVector<T>`, `i: u64` | Swaps the i-th element with the last
and removes it | `T` |
| `swap` | `self: &mut SmartVector<T>`, `i: u64`, `j: u64` | Swaps the i-th and j-th elements |
None |
| `reverse` | `self: &mut SmartVector<T>` | Reverses the order of elements | None |
| `index_of` | `self: &SmartVector<T>`, `val: &T` | Finds the index of an element | `(bool, u64)` |
| `contains` | `self: &SmartVector<T>`, `val: &T` | Checks if an element exists | `bool` |
| `length` | `self: &SmartVector<T>` | Returns the number of elements | `u64` |
| `is_empty` | `self: &SmartVector<T>` | Checks if the vector is empty | `bool` |
| `for_each` | `self: SmartVector<T>`, `f: \|T\|` | Applies a function to each element, consuming
the vector | None |
| `for_each_reverse` | `self: SmartVector<T>`, `f: \|T\|` | Applies a function to each element in
reverse order, consuming the vector | None |
| `for_each_ref` | `self: &SmartVector<T>`, `f: \|&T\|` | Applies a function to a reference of each
element | None |

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

| `for_each_mut` | `self: &mut SmartVector<T>`, `f: \|&mut T\|` | Applies a function to a mutable
reference of each element | None |
| `enumerate_ref` | `self: &SmartVector<T>`, `f: \|(u64, &T)\|` | Applies a function to each
element with its index | None |
| `enumerate_mut` | `self: &mut SmartVector<T>`, `f: \|(u64, &mut T)\|` | Applies a function to
each mutable element with its index | None |
| `fold` | `self: SmartVector<T>`, `init: Accumulator`, `f: \|(Accumulator, T)\|Accumulator` | Folds
the vector into an accumulated value | `Accumulator` |
| `foldr` | `self: SmartVector<T>`, `init: Accumulator`, `f: \|(T, Accumulator)\|Accumulator` | Folds
the vector in reverse order into an accumulated value | `Accumulator` |
| `map_ref` | `self: &SmartVector<T1>`, `f: \|&T1\|T2` | Maps a function over references of the
elements | `SmartVector<T2>` |
| `map` | `self: SmartVector<T1>`, `f: \|T1\|T2` | Maps a function over the elements |
`SmartVector<T2>` |
| `filter` | `self: SmartVector<T>`, `p: \|&T\|bool` | Filters elements based on a predicate |
`SmartVector<T>` |
| `zip` | `self: SmartVector<T1>`, `v2: SmartVector<T2>`, `f: \|(T1, T2)\|` | Zips two SmartVectors
and applies a function to each pair | None |
| `zip_reverse` | `self: SmartVector<T1>`, `v2: SmartVector<T2>`, `f: \|(T1, T2)\|` | Zips two
SmartVectors in reverse and applies a function to each pair | None |
| `zip_ref` | `self: &SmartVector<T1>`, `v2: &SmartVector<T2>`, `f: \|(&T1, &T2)\|` | Zips
references of two SmartVectors and applies a function to each pair | None |
| `zip_mut` | `self: &mut SmartVector<T1>`, `v2: &mut SmartVector<T2>`, `f: \|(&mut T1, &mut
T2)\|` | Zips mutable references of two SmartVectors and applies a function to each pair | None |
| `zip_map` | `self: SmartVector<T1>`, `v2: SmartVector<T2>`, `f: \|(T1, T2)\|NewT` | Zips two
SmartVectors and maps a function over the pairs | `SmartVector<NewT>` |

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

| `zip_map_ref` | `self: &SmartVector<T1>`, `v2: &SmartVector<T2>`, `f: \|(&T1, &T2)\|NewT` |
Zips references of two SmartVectors and maps a function over the pairs | `SmartVector<NewT>`
|
# Smart Tables
## Summary
- Smart Table is a data structure in Move that stores data in multiple buckets for efficient access
and gas optimization.
- It operates similarly to Smart Vector, improving speed and cost-efficiency in data management.
- The module demonstrates how to initialize, update, and retrieve data from a SmartTable.
- The code includes test functions to verify the correct operation of SmartTable operations.
- SmartTable uses address as keys and u64 as values in this example, suitable for tracking user
points or balances.
## Overview
Similar to `Smart Vector`, which we explored in the previous article, `Smart Table` operates on
the same principle. Smart Table's data is divided into multiple `bucket`s for storage. Accessing,
writing, and reading data in `Smart Table` occurs independently within each `bucket` containing
that data. This organization improves speed and cost-efficiency while optimizing gas usage for
users.
## Example
```rust
module movement::smart_table_module {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

use aptos_std::smart_table::{Self, SmartTable};
struct MovementTableObject has key {
value: SmartTable<address, u64>
}
fun init_module(caller: &signer) {
let val = smart_table::new<address, u64>();
smart_table::add(&mut val, address_of(caller), 0);
move_to(caller, MovementTableObject {
value: val
});
}
}
```
Let's break down the code and explain each function step-by-step:
### 1. Module Declaration
```rust
module movement::smart_table_module {
// Module contents
}
```
This declares a new module named "smart_table_module" under the "movement" address.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### 2. Importing Required Modules
```rust
use aptos_std::smart_table::{Self, SmartTable};
```
This imports the SmartTable type and its associated functions from the aptos_std library.
### 3. Defining a Custom Struct
```rust
struct MovementTableObject has key {
value: SmartTable<address, u64>
}
```
This defines a new struct called MovementTableObject that contains a SmartTable. The
SmartTable uses address as keys and u64 as values.
### 4. Initialization Function
```rust
fun init_module(caller: &signer) {
// Function body
}
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

This function is called when the module is published. It takes a reference to the signer (the
account publishing the module) as an argument.
### 5. Creating a New SmartTable
```rust
let val = smart_table::new<address, u64>();
```
This creates a new SmartTable that uses address as keys and u64 as values.
### 6. Adding an Initial Entry
```rust
smart_table::add(&mut val, address_of(caller), 0);
```
This adds an initial entry to the SmartTable. The key is the address of the caller, and the value is
0.
### 7. Moving the SmartTable to Storage
```rust
move_to(caller, MovementTableObject {
value: val
});
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
This creates a new MovementTableObject with the SmartTable we just created and moves it to
the storage of the caller's account.
This initialization sets up a SmartTable in the caller's account, ready to be used for storing and
managing data efficiently.
## Full Example
```rust
module movement::smart_table_module {
use aptos_std::smart_table::{Self, SmartTable};
use std::debug::print;
use std::signer::address_of;
struct MovementTableObject has key {
value: SmartTable<address, u64>
}
fun init_module(caller: &signer) {
let val = smart_table::new<address, u64>();
smart_table::add(&mut val, address_of(caller), 0);
move_to(caller, MovementTableObject {
value: val
});
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

#[test_only]
fun test_init_module(caller: &signer) {
init_module(caller);
}
#[view]
fun get_amount_point(addr: address): u64 acquires MovementTableObject {
let table = &borrow_global<MovementTableObject>(addr).value;
*smart_table::borrow(table, addr)
}
fun plus_point(addr: address, value: u64) acquires MovementTableObject {
let table = &mut borrow_global_mut<MovementTableObject>(addr).value;
let point = *smart_table::borrow_mut(table, addr);
point = point + value;
smart_table::upsert(table, addr, point);
}
#[test(caller = @0x1)]
fun test_get_amount_point(caller: &signer) acquires MovementTableObject {
test_init_module(caller);
let amount = get_amount_point(address_of(caller));
print(&amount);
}
#[test(caller = @0x1)]
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

fun test_plus_amount_point(caller: &signer) acquires MovementTableObject {
test_init_module(caller);
plus_point(address_of(caller), 10);
let amount = get_amount_point(address_of(caller));
print(&amount);
}
}
```
### 1. init_module(caller: &signer)
This function initializes the module when it's published:
- Create a new SmartTable using `smart_table::new&lt;address, u64&gt;()`
- Add an initial entry to the table with the caller's address as the key and 0 as the value
- Create a new MovementTableObject with the SmartTable and move it to the caller's storage
### 2. test_init_module(caller: &signer)
This is a test-only function that calls init_module:
- It's annotated with `#[test_only]`, meaning it's only used for testing
- It simply calls the init_module function with the provided caller
### 3. get_amount_point(addr: address): u64
This function retrieves the point amount for a given address:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- It's annotated with `#[view]`, indicating it's a read-only function
- Borrow the SmartTable from the MovementTableObject stored at the given address
- Use `smart_table::borrow` to get the value associated with the address
- Return the borrowed value (point amount)
### 4. plus_point(addr: address, value: u64)
This function adds points to a given address:
- Borrow the SmartTable mutably from the MovementTableObject
- Get the current point value for the address using `smart_table::borrow_mut`
- Add the new value to the current point
- Update the SmartTable with the new point value using `smart_table::upsert`
### 5. test_get_amount_point(caller: &signer)
This is a test function for get_amount_point:
- It's annotated with `#[test(caller = @0x1)]`, setting up a test environment
- Call test_init_module to set up the initial state
- Call get_amount_point with the caller's address
- Print the retrieved amount
### 6. test_plus_amount_point(caller: &signer)
This is a test function for plus_point:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- It's also annotated with `#[test(caller = @0x1)]`
- Call test_init_module to set up the initial state
- Call plus_point to add 10 points to the caller's address
- Call get_amount_point to retrieve the updated point amount
- Print the new amount
These functions demonstrate how to initialize, update, and retrieve data from a SmartTable, as
well as how to set up tests for these operations.
## Running Test
> Running test:
>
```rust
movement move test -f smart_table_module
```
> Result:
>
```bash
Running Move unit tests
[debug] 0

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

[ PASS ]
0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_mo
dule::test_get_amount_point
[debug] 10
[ PASS ]
0x696e90758094efbf0e2e9dc7fb9fbbde6c60d479bed1b1984cf62575fc864d96::smart_table_mo
dule::test_plus_amount_point
Test result: OK. Total tests: 2; passed: 2; failed: 0
{
"Result": "Success"
}
```
## Additional SimpleMap Functions
| Function | Parameters | Description | Return Value |
| --- | --- | --- | --- |
| `new` | None | Creates an empty SmartTable with default configurations | `SmartTable<K, V>` |
| `new_with_config` | `num_initial_buckets: u64`, `split_load_threshold: u8`, `target_bucket_size:
u64` | Creates an empty SmartTable with customized configurations | `SmartTable<K, V>` |
| `destroy_empty` | `self: SmartTable<K, V>` | Destroys an empty table | None |
| `destroy` | `self: SmartTable<K, V>` | Destroys a table completely when V has `drop` | None |
| `clear` | `self: &mut SmartTable<K, V>` | Clears a table completely when T has `drop` | None |
| `add` | `self: &mut SmartTable<K, V>`, `key: K`, `value: V` | Adds a key-value pair to the table |
None |
| `add_all` | `self: &mut SmartTable<K, V>`, `keys: vector<K>`, `values: vector<V>` | Adds
multiple key-value pairs to the table | None |
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

| `unzip_entries` | `entries: &vector<Entry<K, V>>` | Unzips entries into separate key and value
vectors | `(vector<K>, vector<V>)` |
| `to_simple_map` | `self: &SmartTable<K, V>` | Converts a smart table to a simple_map |
`SimpleMap<K, V>` |
| `keys` | `self: &SmartTable<K, V>` | Gets all keys in a smart table | `vector<K>` |
| `keys_paginated` | `self: &SmartTable<K, V>`, `starting_bucket_index: u64`,
`starting_vector_index: u64`, `num_keys_to_get: u64` | Gets keys from a smart table, paginated
| `(vector<K>, Option<u64>, Option<u64>)` |
| `split_one_bucket` | `self: &mut SmartTable<K, V>` | Splits one bucket into two | None |
| `bucket_index` | `level: u8`, `num_buckets: u64`, `hash: u64` | Returns the expected bucket
index for a hash | `u64` |
| `borrow` | `self: &SmartTable<K, V>`, `key: K` | Borrows an immutable reference to the value
associated with the key | `&V` |
| `borrow_with_default` | `self: &SmartTable<K, V>`, `key: K`, `default: &V` | Borrows an
immutable reference to the value, or returns the default if key not found | `&V` |
| `borrow_mut` | `self: &mut SmartTable<K, V>`, `key: K` | Borrows a mutable reference to the
value associated with the key | `&mut V` |
| `borrow_mut_with_default` | `self: &mut SmartTable<K, V>`, `key: K`, `default: V` | Borrows a
mutable reference to the value, or inserts and returns default if key not found | `&mut V` |
| `contains` | `self: &SmartTable<K, V>`, `key: K` | Checks if the table contains a key | `bool` |
| `remove` | `self: &mut SmartTable<K, V>`, `key: K` | Removes and returns the value
associated with the key | `V` |
| `upsert` | `self: &mut SmartTable<K, V>`, `key: K`, `value: V` | Inserts a key-value pair or
updates an existing one | None |
| `length` | `self: &SmartTable<K, V>` | Returns the number of entries in the table | `u64` |
| `load_factor` | `self: &SmartTable<K, V>` | Returns the load factor of the hashtable | `u64` |

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

| `update_split_load_threshold` | `self: &mut SmartTable<K, V>`, `split_load_threshold: u8` |
Updates the split load threshold | None |
| `update_target_bucket_size` | `self: &mut SmartTable<K, V>`, `target_bucket_size: u64` |
Updates the target bucket size | None |
| `for_each_ref` | `self: &SmartTable<K, V>`, `f: \|&K, &V\|` | Applies a function to a reference of
each key-value pair | None |
| `for_each_mut` | `self: &mut SmartTable<K, V>`, `f: \|&K, &mut V\|` | Applies a function to a
mutable reference of each key-value pair | None |
| `map_ref` | `self: &SmartTable<K, V1>`, `f: \|&V1\|V2` | Maps a function over the values,
producing a new SmartTable | `SmartTable<K, V2>` |
| `any` | `self: &SmartTable<K, V>`, `p: \|&K, &V\|bool` | Checks if any key-value pair satisfies
the predicate | `bool` |
| `borrow_kv` | `self: &Entry<K, V>` | Borrows references to the key and value of an entry | `(&K,
&V)` |
| `borrow_kv_mut` | `self: &mut Entry<K, V>` | Borrows mutable references to the key and value
of an entry | `(&mut K, &mut V)` |
| `num_buckets` | `self: &SmartTable<K, V>` | Returns the number of buckets in the table | `u64`
|
| `borrow_buckets` | `self: &SmartTable<K, V>` | Borrows a reference to the buckets of the table
| `&TableWithLength<u64, vector<Entry<K, V>>>` |
| `borrow_buckets_mut` | `self: &mut SmartTable<K, V>` | Borrows a mutable reference to the
buckets of the table | `&mut TableWithLength<u64, vector<Entry<K, V>>>` |
# Resources Account
Resource accounts in Move offer a revolutionary approach to smart contract deployment and
resource management. Unlike traditional object code deployment, these accounts provide
enhanced control and flexibility for on-chain operations.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

At its core, a resource account in Move functions as an autonomous entity, separate from
user-controlled accounts. This separation allows for more robust module publishing and
sophisticated access control mechanisms.
Resource accounts serve two primary functions:
- Asset Isolation: They create a dedicated environment for hosting and managing specific
resources within a module, ensuring better organization and security.
- Autonomous Module Deployment: By establishing independent accounts for module
deployment, resource accounts enhance the decentralization of smart contracts. This approach
eliminates the need for private key management, with governance potentially handled through
separate modules.
## **Setup Process**
Developers can establish resource accounts through two main methods:
### Movement Command Line Interface (CLI)
Streamlined commands like `movement account create-resource-account` and `movement
move create-resource-account-and-publish-package` simplify the creation of resource accounts
and associated package publishing.
Here are the CLI commands to run for each method:
```bash
# For create_resource_account
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

movement account create-resource-account --seed hello
```
- Result
```json
Transaction submitted:
https://explorer.aptoslabs.com/txn/0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1e
d151988df98fa34?network=devnet
{
"Result": {
"resource_account":
"a7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e",
"transaction_hash":
"0x4b4628d7bb0c17754cfdfcd97a62c3191e31023f587191f1ed151988df98fa34",
"gas_used": 973,
"gas_unit_price": 100,
"sender": "3ebfa1047b74a82ee98b272abd6c83461007d4bc50ffe2ea363c61abe0ee89c9",
"sequence_number": 0,
"success": true,
"timestamp_us": 1728287140564035,
"version": 41288052,
"vm_status": "Executed successfully"
}
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Here, you will initialize a `resource_account` with the address:
`0xa7b49a0b410256e1f4e4fd5fbbbc39c6f75d754c26fb96714b484820a3dcd43e`. It functions
similarly to a regular account but lacks a `private key`. To interact with this account, you must go
through its owner—the default account that created it.
### Smart Contract Integration
Aptos Move provides functions such as `create_resource_account`,
`create_resource_account_and_fund`, and `create_resource_account_and_publish_package`
for programmatic management of resource accounts.
Each method provides distinct capabilities:
- `create_resource_account`: Generates an unfunded account, retaining signer access until
explicitly released.
- `create_resource_account_and_fund`: Establishes and funds the account, maintaining signer
access until voluntarily relinquished.
- `create_resource_account_and_publish_package`: Creates the account and immediately
withdraws access, ideal for deploying self-governing and immutable contracts.
## **Critical Aspects**
The creation of resource accounts in Aptos follows a unique protocol. It utilizes a SHA3-256
hash derived from the source address and additional seed data. This method guarantees the
uniqueness of each resource account and prevents duplicate creation for a given source and
seed pair.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Aptos implements protective measures for cases where an entity attempts to claim an address
matching a potential resource account. If such an account is identified, ownership transfers to
the resource account, provided the claimed account is transaction-free and lacks specific
capabilities.
# What is Fungible Asset (FA)
Fungible assets, or tokens, are digital representations of value on a blockchain platform. Here’s
a breakdown:
| Token Standards | Like ERC-20 (Ethereum) or BEP-20 (Binance Smart Chain). These are the
rules of the game, making sure tokens play nice with wallets and exchanges. |
| --- | --- |
| Smart Contracts/Modules | These are programs that manage tokens, specifying how they are
created, transferred, and held. |
| Decentralization | Tokens operate on a blockchain, a transparent and secure system
maintained by a network of computers. |
| Use Cases | Tokens can serve various purposes, like cryptocurrencies (e.g., Bitcoin), utility
tokens (access to services), Stablecoins (cryptocurrencies that are pegged to fiat) or
representing ownership of assets. |
| Transfers | Tokens can be sent to other blockchain addresses, with each transaction securely
recorded using cryptographic signatures. |
| Ownership | Your tokens are yours thanks to private keys. |
| Interoperability | Tokens can interact with other tokens and applications on the same
blockchain, enabling a wide range of functionalities. |

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Movement offers two ways to create and manage tokens: Coin and Fungible Asset. Coin is
considered the legacy standard, in this section we’ll focus on the new Fungible Asset standard.
The Fungible Asset standard allows you to:
- Create and manage your own fungible asset.
- Manage a user’s fungible store (like a digital wallet) for a specific asset.
- Set a maximum supply, preventing unlimited minting (a feature Coin doesn’t have).
- Customize permissions for actions like minting, burning, freezing, and forced transfers.
- Use a fully functional freezing feature, unlike the limited one in the Coin standard.
In summary, the Fungible Asset standard provides more control and flexibility than the original
Coin standard, offering enhanced capabilities for token management.
# Fungible Asset Framework Functions
## Summary
- Comprehensive framework for managing fungible assets in blockchain systems
- Core functions for token initialization, storage, and basic transactions
- Minting and burning capabilities for supply management
- Asset management functions for splitting, merging, and optimizing tokens
- Store management for lifecycle and state control of token stores
- Reference generation for establishing permissions and authorities
- Metadata management for retrieving and validating token information
- Advanced features for enhanced security, performance, and customization
## Core Functions
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

**Overview:**
Core functions represent the fundamental building blocks of the framework, essential for
establishing and managing fungible assets. These functions are utilized when:
- Initializing a new token type
- Creating token storage facilities (stores)
- Executing basic token transactions between stores
- Managing deposit/withdraw operations
This function group serves as the foundation for all other operations within the framework and
represents the most frequently used functionalities.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `add_fungibility` | constructor_ref: `&ConstructorRef`, `maximum_supply: Option<u128>`,
`name: String`, `symbol: String`, `decimals: u8`, `icon_uri: String`, `project_uri: String` | Makes
an existing object fungible by adding Metadata resource. Sets up maximum supply monitoring. |
Object<Metadata> |
| `create_store` | constructor_ref: `&ConstructorRef`, `metadata: Object<T>` | Creates a new
store for holding fungible assets with zero initial balance. | Object<FungibleStore> |
| `withdraw` | owner: `&signer`, `store: Object<T>`, `amount: u64` | Withdraws specified amount
from store owned by signer. | FungibleAsset |
| `deposit` | store: `Object<T>`, `fa: FungibleAsset` | Deposits fungible asset into specified store.
| void |
| `transfer` | sender: `&signer`, `from: Object<T>`, `to: Object<T>`, `amount: u64` | Transfers
fungible assets between stores. | void |
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

## Minting & Burning
**Overview:**
This group of functions handles token creation and destruction, commonly used in scenarios
involving:
- Issuing new tokens into circulation
- Managing total token supply
- Implementing tokenomics and emission schedules
- Handling token burning events and supply reduction
These functions typically have restricted access, limited to addresses with token issuance
authority (such as token owners).
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `mint` | ref: &MintRef, amount: u64 | Mints new fungible assets. | FungibleAsset |
| `mint_to` | ref: &MintRef, store: Object<T>, amount: u64 | Mints directly to specified store. |
void |
| `burn` | ref: &BurnRef, fa: FungibleAsset | Burns fungible assets. | void |
| `burn_from` | ref: &BurnRef, store: Object<T>, amount: u64 | Burns amount from specified
store. | void |
## Asset Management
**Overview:**
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Asset Management functions facilitate the manipulation and management of fungible assets.
These are particularly useful when:
- Splitting tokens into smaller denominations
- Consolidating multiple token fragments
- Managing zero-value tokens
- Optimizing token handling in complex applications
These functions are essential for building sophisticated features like liquidity pools, vaults, or
other DeFi mechanisms.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `extract` | fungible_asset: &mut FungibleAsset, amount: u64 | Extracts amount from existing
asset. | FungibleAsset |
| `merge` | dst_fungible_asset: &mut FungibleAsset, src_fungible_asset: FungibleAsset |
Merges two fungible assets. | void |
| `destroy_zero` | fungible_asset: FungibleAsset | Destroys zero-value asset. | void |
| `zero` | metadata: Object<T> | Creates zero-value asset. | FungibleAsset |
## Store Management
**Overview:**
Store Management functions handle the lifecycle and state of token stores. These functions are
essential when:
- Initializing and managing new wallets/stores
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Checking store states and balances
- Managing store freeze states
- Cleaning up and removing unused stores
These functions are crucial for maintaining store lifecycle and ensuring secure token storage.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `remove_store` | delete_ref: &DeleteRef | Removes empty store. | void |
| `store_exists` | store: address | Checks if store exists. | bool |
| `balance` | store: Object<T> | Gets store balance. | u64 |
| `is_frozen` | store: Object<T> | Checks if store is frozen. | bool |
## Reference Generation
**Overview:**
Reference Generation functions create capability references for fungible assets. These are
utilized when:
- Establishing mint/burn permissions
- Setting up token transfer authorities
- Implementing complex permission management
- Creating permission-limited smart contracts
These functions are vital for implementing tokenomics and permission management within the
system.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `generate_mint_ref` | constructor_ref: &ConstructorRef | Creates mint capability. | MintRef |
| `generate_burn_ref` | constructor_ref: &ConstructorRef | Creates burn capability. | BurnRef |
| `generate_transfer_ref` | constructor_ref: &ConstructorRef | Creates transfer capability. |
TransferRef |
## Metadata Management
**Overview:**
Metadata Management functions handle token descriptive information. These functions are
essential when:
- Retrieving token information
- Verifying supply limits and current circulation
- Displaying token information in UI/UX
- Validating token properties
These functions are crucial for external system integration and providing user information.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `metadata` | metadata: Object<T> | Gets metadata struct. | Metadata |
| `supply` | metadata: Object<T> | Gets current supply. | Option<u128> |
| `maximum` | metadata: Object<T> | Gets maximum supply. | Option<u128> |
| `name` | metadata: Object<T> | Gets asset name. | String |
| `symbol` | metadata: Object<T> | Gets asset symbol. | String |
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

| `decimals` | metadata: Object<T> | Gets decimal places. | u8 |
## Advanced Features
**Overview:**
Advanced Features provide enhanced functionality for fungible assets. These are implemented
when:
- Requiring specialized security mechanisms
- Optimizing performance with concurrent operations
- Establishing special transfer restrictions
- Upgrading token functionality
These functions are typically employed in complex applications or when specific advanced
features are needed.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `set_frozen_flag` | ref: &TransferRef, store: Object<T>, frozen: bool | Sets store frozen status. |
void |
| `upgrade_to_concurrent` | ref: &ExtendRef | Upgrades to concurrent supply. | void |
| `upgrade_store_to_concurrent` | owner: &signer, store: Object<T> | Upgrades store to
concurrent. | void |
| `set_untransferable` | constructor_ref: &ConstructorRef | Makes asset untransferable. | void |
## Dispatch Functions

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

**Overview:**
Dispatch Functions enable customization of fungible asset behavior. These are used when:
- Implementing custom transfer logic
- Adding operation hooks
- Creating derived calculations
- Implementing complex business rules
These functions are designed for advanced users who need to customize their token's
operational behavior.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `register_dispatch_functions` | constructor_ref: &ConstructorRef, withdraw_function:
Option<FunctionInfo>, deposit_function: Option<FunctionInfo>, derived_balance_function:
Option<FunctionInfo> | Registers dispatch hooks. | void |
| `register_derive_supply_dispatch_function` | constructor_ref: &ConstructorRef,
dispatch_function: Option<FunctionInfo> | Registers supply derivation. | void |
# Primary Fungible Store Framework Functions
## Executive Summary
The Primary Fungible Store Framework provides a comprehensive set of functions for managing
fungible assets with primary stores. Key aspects include:
- Store creation and management for fungible assets
- Query functions for accessing store information
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Basic operations for asset transfers and balance management
- Advanced operations for complex asset handling
- Reference-based operations for enhanced control and security
- Internal functions for optimized framework support
This framework emphasizes deterministic store creation, strong security measures, and flexible
asset management, making it suitable for various applications ranging from simple currency-like
tokens to complex asset management systems.
## Store Creation and Management
**Overview:**
These functions handle the creation and management of primary stores for fungible assets.
They are used when:
- Setting up new fungible assets with primary store support
- Creating and managing user primary stores
- Checking store existence and status
- Managing store references
These functions form the foundation for managing primary fungible asset stores.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `create_primary_store_enabled_fungible_asset` | constructor_ref: &ConstructorRef,
maximum_supply: Option<u128>, name: String, symbol: String, decimals: u8, icon_uri: String,

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

project_uri: String | Creates a fungible asset with primary store support for automatic store
creation during transfers. | void |
| `create_primary_store` | owner_addr: address, metadata: Object<T> | Creates a primary store
object for holding fungible assets for the given address. | Object<FungibleStore> |
| `ensure_primary_store_exists` | owner: address, metadata: Object<T> | Ensures primary store
exists for owner, creates if not. | Object<FungibleStore> |
| `may_be_unburn` | owner: &signer, store: Object<FungibleStore> | Unburns a store if it's
burned. | void |
## Query Functions
**Overview:**
These functions provide read-only access to store information. They are essential for:
- Checking store existence and location
- Querying balances and states
- Getting store addresses
- Verifying store conditions
These functions are commonly used in frontend integrations and for validation.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `primary_store_address` | owner: address, metadata: Object<T> | Gets address of primary
store for account. | address |
| `primary_store` | owner: address, metadata: Object<T> | Gets primary store object for account.
| Object<FungibleStore> |
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

| `primary_store_exists` | account: address, metadata: Object<T> | Checks if primary store
exists. | bool |
| `balance` | account: address, metadata: Object<T> | Gets balance of account's primary store. |
u64 |
| `is_balance_at_least` | account: address, metadata: Object<T>, amount: u64 | Checks if store
has sufficient balance. | bool |
| `is_frozen` | account: address, metadata: Object<T> | Checks if store is frozen. | bool |
## Basic Operations
**Overview:**
These functions provide core functionality for managing assets. Used for:
- Basic transfer operations
- Asset withdrawals and deposits
- Standard asset movements
- Balance management
Essential functions for day-to-day asset operations.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `withdraw` | owner: &signer, metadata: Object<T>, amount: u64 | Withdraws from owner's
primary store. | FungibleAsset |
| `deposit` | owner: address, fa: FungibleAsset | Deposits to owner's primary store. | void |
| `force_deposit` | owner: address, fa: FungibleAsset | Forces deposit to owner's store (friend
function). | void |
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

| `transfer` | sender: &signer, metadata: Object<T>, recipient: address, amount: u64 | Transfers
between primary stores. | void |
## Advanced Operations
**Overview:**
These functions provide enhanced control over assets. Used when:
- Implementing complex transfer logic
- Managing asset supply
- Handling special transfers
- Implementing security features
These functions are typically used in more sophisticated applications.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `mint` | mint_ref: &MintRef, owner: address, amount: u64 | Mints to owner's primary store. |
void |
| `burn` | burn_ref: &BurnRef, owner: address, amount: u64 | Burns from owner's primary store. |
void |
| `set_frozen_flag` | transfer_ref: &TransferRef, owner: address, frozen: bool | Sets frozen status
of store. | void |
| `transfer_assert_minimum_deposit` | sender: &signer, metadata: Object<T>, recipient:
address, amount: u64, expected: u64 | Transfers with minimum deposit assertion. | void |
## Reference-Based Operations
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

**Overview:**
These functions use references for enhanced control. Used for:
- Privileged operations
- Reference-based transfers
- Secure asset movements
- Special permissions handling
These functions provide additional security and control mechanisms.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `withdraw_with_ref` | transfer_ref: &TransferRef, owner: address, amount: u64 | Withdraws
ignoring frozen flag. | FungibleAsset |
| `deposit_with_ref` | transfer_ref: &TransferRef, owner: address, fa: FungibleAsset | Deposits
ignoring frozen flag. | void |
| `transfer_with_ref` | transfer_ref: &TransferRef, from: address, to: address, amount: u64 |
Transfers between stores ignoring frozen flags. | void |
## Internal/Inline Functions
**Overview:**
These functions provide internal support for the framework. Used for:
- Internal store operations
- Optimized lookups
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Internal validations
- Performance optimizations
These functions support the framework's internal operations.
| Function Name | Parameters | Description | Return Type |
| --- | --- | --- | --- |
| `primary_store_address_inlined` | owner: address, metadata: Object<T> | Gets store address
(inline version). | address |
| `primary_store_inlined` | owner: address, metadata: Object<T> | Gets store object (inline
version). | Object<FungibleStore> |
| `primary_store_exists_inlined` | account: address, metadata: Object<T> | Checks store
existence (inline version). | bool |
### Primary Use Cases:
1. Currency-like tokens requiring easy store management
2. Assets needing automatic store creation
3. Systems requiring deterministic store addresses
4. Applications needing unified asset management
5. Platforms requiring secure asset transfers
# Fungible Asset vs Primary Fungible Store: Details & Use Cases
## 1. Fungible Asset
### Key Characteristics

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
module aptos_framework::fungible_asset {
struct FungibleAsset {
metadata: Object<Metadata>,
amount: u64,
}
struct FungibleStore has key {
metadata: Object<Metadata>,
balance: u64,
frozen: bool,
}
}
```
### Functionality
1. **Low-level Operations**
- Direct token manipulation
- Custom store creation
- Flexible store management
2. **Direct Control**
- Manual store creation
- Explicit store handling
- Fine-grained control
3. **Advanced Features**
- Custom store implementations
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Complex token behaviors
- Specialized token logic
### Use Cases
1. **DeFi Protocols**
```rust
// Example: Custom liquidity pool store
struct LiquidityPoolStore has key {
store: FungibleStore,
pool_info: PoolInfo,
// Additional DeFi-specific fields
}
```
2. **Complex Token Systems**
```rust
// Example: Multi-tier token system
struct TieredStore has key {
base_store: FungibleStore,
tier_level: u8,
rewards_multiplier: u64,
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

3. **Protocol-Specific Implementations**
```rust
// Example: Staking contract
struct StakingStore has key {
tokens: FungibleStore,
lock_period: u64,
rewards_rate: u64,
}
```

## 2. Primary Fungible Store
### Functionality
1. **High-level Operations**
- Automatic store management
- Simplified transfers
- Standard token operations
2. **User-Focused**
- Automatic store creation
- Intuitive interfaces
- Standard workflows
3. **Standard Features**
- Basic transfer operations
- Standard balance management
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Common token functionalities
### Use Cases
1. **Standard Tokens**
```rust
// Example: Simple token transfer
public fun transfer(
from: &signer,
to: address,
amount: u64
){
primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
```
2. **User Wallets**
```rust
// Example: Check balance
public fun get_balance(account: address): u64 {
primary_fungible_store::balance(account, get_metadata())
}
```
3. **Simple Token Systems**
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
// Example: Basic token implementation
public fun mint_to(recipient: address, amount: u64) {
primary_fungible_store::mint(&mint_ref, recipient, amount);
}
```

## 3. When to Use
### Use Fungible Asset When:
1. **Custom Store Logic is Needed**
```rust
// Example: Custom store with special logic
struct CustomStore has key {
base_store: FungibleStore,
custom_data: vector<u8>,
special_rules: Rules,
}
```
2. **Implementing Complex Protocols**
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Example: AMM implementation
struct AMMStore has key {
token_a: FungibleStore,
token_b: FungibleStore,
lp_tokens: FungibleStore,
curve_parameters: CurveParams,
}
```
3. **Detailed Control is Required**
```rust
// Example: Custom transfer logic
public fun custom_transfer(
store: &mut FungibleStore,
amount: u64,
rules: &TransferRules
){
// Custom validation
validate_transfer(store, amount, rules);
// Custom transfer logic
perform_transfer(store, amount);
}
```

### Use Primary Fungible Store When:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

1. **Implementing Simple Tokens**
```rust
// Example: Basic token operations
public entry fun simple_transfer(
from: &signer,
to: address,
amount: u64
){
transfer(from, get_metadata(), to, amount);
}
```
2. **Focusing on User Experience**
```rust
// Example: User-friendly interface
public entry fun send_tokens(
user: &signer,
recipient: address,
amount: u64
){
// No need to create store - handled automatically
transfer(user, get_metadata(), recipient, amount);
}
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

3. **Implementing Standard Token Functionality**
```rust
// Example: Standard token implementation
public entry fun initialize_token(
admin: &signer,
name: String,
symbol: String,
decimals: u8
){
// Standard initialization with automatic store support
create_primary_store_enabled_fungible_asset(
admin,
name,
symbol,
decimals
);
}
```

## 4. Best Practices
### Fungible Asset Framework
1. **Custom Store Design**
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Clearly define store structure
- Implement specific rules
- Handle edge cases
2. **Security Considerations**
```rust
// Example: Secure custom store
struct SecureStore has key {
store: FungibleStore,
access_control: AccessControl,
audit_trail: AuditLog,
}
```

### Primary Fungible Store Framework
1. **Simplicity First**
- Use standard operations
- Leverage automatic store creation
- Focus on user experience
2. **Standard Patterns**
```rust
// Example: Standard token pattern
public fun initialize_standard_token(
admin: &signer,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

config: TokenConfig
){
// Use standard initialization
create_standard_token(admin, config);
}
```

## 5. Decision Matrix
| Criteria | Fungible Asset | Primary Fungible Store |
| --- | --- | --- |
| Complexity | High | Low |
| Flexibility | High | Moderate |
| User Experience | Custom | Standardized |
| Use Case | Complex DeFi/Custom Logic | Standard Tokens |
| Development Effort | High | Low |
| Maintenance | Complex | Simple |
| Integration | Custom | Standardized |
# Initialize a Fungible Asset
### Summary
- Fungible assets are interchangeable and divisible digital tokens, similar to cryptocurrencies.
- The initialization process involves setting up token configuration, creating metadata, and
implementing management structures.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Essential steps include defining token properties (name, symbol, decimals), creating a
metadata object, and generating management references.
- View functions are implemented to retrieve token metadata, check account balances, and
verify frozen status.
- Best practices include proper error handling, optimization techniques, and comprehensive
testing.
- Common pitfalls to avoid are related to initialization, view function implementation, and testing
procedures.
## Overview
Fungible assets are digital tokens that are interchangeable and divisible, such as
cryptocurrencies. This guide outlines the process of initializing a fungible asset on a blockchain
platform, focusing on:
- Setting up token configuration
- Creating metadata and management structures
- Implementing essential view functions
- Best practices for development and testing
The tutorial provides step-by-step instructions and code examples to help developers create a
robust and functional fungible asset system.
## 1. Introduction
This article provides detailed instructions on how to:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Initialize a Fungible Asset
- Set up management references
- Implement basic view functions
## 2. Token Configuration Structure
```
/// Token configuration constants
const TOKEN_NAME: vector&lt;u8&gt; = b"YourToken";
const TOKEN_SYMBOL: vector&lt;u8&gt; = b"YTK";
const TOKEN_DECIMALS: u8 = 6;
```
**Components:**
- `TOKEN_NAME`: Full name of the token
- `TOKEN_SYMBOL`: Short symbol (3–5 characters)
- `TOKEN_DECIMALS`: Number of decimal points (typically 6–8)
## 3. Token Initialization
### 3.1. Create Metadata Object
```
fun init_module(module_signer: &signer) {
let constructor_ref = &object::create_named_object(
module_signer,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

TOKEN_SYMBOL,
);
```
**Details:**
- `module_signer`: Module signer (typically the deployer)
- `constructor_ref`: Reference for creating related objects
- `create_named_object`: Creates an object with a deterministic address
### 3.2. Initialize Fungible Asset
```
primary_fungible_store::create_primary_store_enabled_fungible_asset(
constructor_ref,
option::none(),
// Maximum supply (none = unlimited)
string::utf8(TOKEN_NAME),
// Token name
string::utf8(TOKEN_SYMBOL), // Token symbol
TOKEN_DECIMALS,
// Decimals
string::utf8(b""),
// Icon URI
string::utf8(b""),
// Project URI
);
```
**Parameters:**
1. `constructor_ref`: Reference from the previous step
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

2. `maximum_supply`: Supply limit (option::none() = unlimited)
3. `name`: Token name
4. `symbol`: Token symbol
5. `decimals`: Number of decimals
6. `icon_uri`: Token icon URL
7. `project_uri`: Project URL
### 3.3. Create and Store Management References
```
// Generate refs
let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
// Store refs
let metadata_signer = &object::generate_signer(constructor_ref);
move_to(
metadata_signer,
TokenManagement {
mint_ref,
burn_ref,
transfer_ref,
}
);
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

**References:**
1. `mint_ref`: Authority to create new tokens
2. `burn_ref`: Authority to destroy tokens
3. `transfer_ref`: Authority to manage transfers and frozen status
## 4. Implement View Functions
### 4.1. Get Metadata Function
```
#[view]
public fun get_metadata(): object::Object&lt;fungible_asset::Metadata&gt; {
object::address_to_object(
object::create_object_address(&@module_addr, TOKEN_SYMBOL)
)
}
```
**Function:**
- Returns the token's metadata object
- Uses module address and token symbol to calculate the address
- Marked as a view function to optimize gas usage
### 4.2. Get Balance Function

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
#[view]
public fun get_balance(account: address): u64 {
if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
primary_fungible_store::balance(account, get_metadata())
} else {
0
}
}
```
**Flow:**
1. Check if the store exists
2. If the store exists, return the balance
3. If not, return 0
### 4.3. Check Frozen Status
```
#[view]
public fun is_frozen(account: address): bool {
if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
primary_fungible_store::is_frozen(account, get_metadata())
} else {
false
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
```
**Flow:**
1. Check if the store exists
2. If the store exists, return the frozen status
3. If not, return false
## 5. Usage Examples
### Check Token Info
```
// Get token metadata
let metadata = get_metadata();
// Check account balance
let balance = get_balance(@user);
// Check if account is frozen
let is_frozen = is_frozen(@user);
```
## 6. Best Practices
### 6.1. Error Handling
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
const ESTORE_NOT_FOUND: u64 = 1;
const EINVALID_METADATA: u64 = 2;
public fun safe_get_balance(account: address): u64 {
assert!(primary_fungible_store::primary_store_exists(account, get_metadata()),
ESTORE_NOT_FOUND
);
get_balance(account)
}
```
### 6.2. Optimization
```
// Cache metadata object for frequent use
let cached_metadata = get_metadata();
let balance1 = get_balance(addr1);
let balance2 = get_balance(addr2);
```
### 6.3. Testing
```
#[test]
fun test_view_functions() {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Initialize token
init_module(...)
// Test balance view
assert!(get_balance(@user) == 0, 1);
// Test frozen status
assert!(!is_frozen(@user), 2);
}
```
## 7. Common Pitfalls and Notes
1. **Initialization**
- Should only be called once when deploying the module
- Refs cannot be recreated after initialization
- URIs can be empty but should be provided in production
2. **View Functions**
- Always handle cases where the store doesn't exist
- Consider caching for improved performance
- Ensure appropriate error handling
3. **Testing**
- Test all edge cases
- Verify initialization success
- Check view function accuracy
# Full Code
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
module movement::fungible_token_tutorial {
use std::string;
use std::option;
use aptos_framework::object;
use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef};
use aptos_framework::primary_fungible_store;
// =================== Constants ===================
// Token configuration
const MOVEMENT_NAME: vector<u8> = b"Movement";
const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
const MOVEMENT_DECIMALS: u8 = 6;
// =================== Resources & Structs ===================
// Holds the refs for managing Movement
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementManagement has key {
mint_ref: MintRef,
burn_ref: BurnRef,
transfer_ref: TransferRef,
}
// =================== Initialization ===================
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Initialize the Movement token
fun init_module(module_signer: &signer) {
// Create metadata object with deterministic address
let constructor_ref = &object::create_named_object(
module_signer,
MOVEMENT_SYMBOL,
);
// Create the fungible asset with support for primary stores
primary_fungible_store::create_primary_store_enabled_fungible_asset(
constructor_ref,
option::none(), // No maximum supply
string::utf8(MOVEMENT_NAME),
string::utf8(MOVEMENT_SYMBOL),
MOVEMENT_DECIMALS,
string::utf8(b""), // Empty icon URI
string::utf8(b""), // Empty project URI
);
// Generate management references
let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
// Store the management refs in metadata object
let metadata_signer = &object::generate_signer(constructor_ref);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

move_to(
metadata_signer,
MovementManagement {
mint_ref,
burn_ref,
transfer_ref,
}
);
}
// =================== View Functions ===================
// Get the metadata object of Movement
#[view]
public fun get_metadata(): object::Object<fungible_asset::Metadata> {
object::address_to_object(
object::create_object_address(&@movement, MOVEMENT_SYMBOL)
)
}
// Get the balance of an account
#[view]
public fun get_balance(account: address): u64 {
if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
primary_fungible_store::balance(account, get_metadata())
} else {
0
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
}
// Check if account store is frozen
#[view]
public fun is_frozen(account: address): bool {
if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
primary_fungible_store::is_frozen(account, get_metadata())
} else {
false
}
}
}
```
# Management Functions trong Fungible Asset Framework
## 1. Overview
Management Functions are special functions used to manage tokens in the Fungible Asset
Framework. These functions are crucial for controlling the token supply and user access. Let's
explore the main management functions:
- Minting (creating new) tokens: This function allows authorized users to create and distribute
new tokens.
- Burning (destroying) tokens: This function removes tokens from circulation, which can be
useful for managing token supply or implementing certain economic models.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Managing the frozen status of accounts: This function allows administrators to restrict token
transfers for specific accounts, which can be useful for security or compliance purposes.
## 2. Events and Error Codes
Events and error codes are essential for tracking operations and handling exceptions in your
smart contract. Let's break them down:
### 2.1 Event Structures
Events are emitted when certain actions occur, allowing off-chain systems to track and react to
on-chain activities. Here are the main event structures:
```rust
// Event emitted when new tokens are minted
struct MintEvent has drop, store {
amount: u64,
// Amount of tokens minted
recipient: address, // Address receiving the minted tokens
}
// Event emitted when tokens are burned
struct BurnEvent has drop, store {
amount: u64, // Amount of tokens burned
from: address, // Address from which tokens were burned
}
// Event emitted when an account's frozen status changes
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

struct FreezeEvent has drop, store {
account: address, // Address of the affected account
frozen: bool, // New frozen status (true if frozen, false if unfrozen)
}
```
These events help in tracking token minting, burning, and account freezing operations.
### 2.2 Error Constants
Error constants are used to provide meaningful error messages when operations fail. Here are
the main error constants:
```rust
const EZERO_MINT_AMOUNT: u64 = 1; // Error when trying to mint zero tokens
const EZERO_BURN_AMOUNT: u64 = 2; // Error when trying to burn zero tokens
const ENOT_AUTHORIZED: u64 = 3; // Error when an unauthorized user attempts a restricted
operation
```
Using these error constants helps in providing clear feedback when operations fail, making it
easier to debug and handle exceptions.
## 3. Mint Function Implementation
The mint function is used to create new tokens and assign them to a specific address. Let's
break down its implementation:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### 3.1 Function Signature
```rust
public entry fun mint_to(
admin: &signer, // The administrator's signer reference
recipient: address, // The address to receive the minted tokens
amount: u64
// The amount of tokens to mint
) acquires MovementManagement
```
This function signature indicates that only an admin can call this function, and it requires access
to the MovementManagement resource.
### 3.2 Detailed Implementation
```rust
public entry fun mint_to(
admin: &signer,
recipient: address,
amount: u64
) acquires MovementManagement {
// 1. Validate amount
assert!(amount > 0, EZERO_MINT_AMOUNT);
// 2. Get management struct
let management = borrow_global<MovementManagement>(
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

object::object_address(&get_metadata())
);
// 3. Mint tokens
primary_fungible_store::mint(&management.mint_ref, recipient, amount);
// 4. Emit event
event::emit(MintEvent {
amount,
recipient,
});
}
```
**Flow Analysis:**
1. **Validation**
- The function first checks if the amount to be minted is greater than zero. This prevents
minting of zero tokens, which would be pointless and potentially confusing.
- The authorization check is implicit through the use of mint_ref, ensuring only authorized
users can mint tokens.
2. **Management Access**
- The function retrieves the MovementManagement struct, which contains references to
perform token operations.
- The mint_ref is accessed from this struct, providing the capability to mint tokens.
3. **Mint Operation**

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- The primary_fungible_store::mint function is called to actually create and assign the new
tokens.
- If the recipient doesn't have a token store, one is automatically created.
4. **Event Emission**
- After successful minting, a MintEvent is emitted to record the transaction.
- This event includes the amount minted and the recipient's address, allowing for easy
tracking and auditing of minting operations.
## 4. Burn Function Implementation
The burn function is used to destroy existing tokens, effectively removing them from circulation.
Here's a detailed look at its implementation:
### 4.1 Function Signature
```rust
public entry fun burn_from(
admin: &signer, // The administrator's signer reference
account: address, // The address from which to burn tokens
amount: u64
// The amount of tokens to burn
) acquires MovementManagement
```
Similar to the mint function, this function can only be called by an admin and requires access to
the MovementManagement resource.
### 4.2 Detailed Implementation
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
public entry fun burn_from(
admin: &signer,
account: address,
amount: u64
) acquires MovementManagement {
// 1. Validate amount
assert!(amount > 0, EZERO_BURN_AMOUNT);
// 2. Get management struct
let management = borrow_global<MovementManagement>(
object::object_address(&get_metadata())
);
// 3. Burn tokens
primary_fungible_store::burn(&management.burn_ref, account, amount);
// 4. Emit event
event::emit(BurnEvent {
amount,
from: account,
});
}
```
**Flow Analysis:**
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

1. **Validation**
- The function checks if the amount to be burned is greater than zero, preventing attempts to
burn zero tokens.
- The balance check is implicitly performed in the burn operation, ensuring the account has
sufficient tokens to burn.
2. **Management Access**
- The burn_ref is retrieved from the MovementManagement struct, providing the capability to
burn tokens.
- This step also verifies that the caller has the necessary authorization to perform the burn
operation.
3. **Burn Operation**
- The primary_fungible_store::burn function is called to destroy the specified amount of
tokens from the given account.
- This operation reduces the total supply of tokens in circulation.
4. **Event Emission**
- After successful burning, a BurnEvent is emitted to record the transaction.
- This event includes the amount burned and the source account, allowing for easy tracking
and auditing of burning operations.
## 5. Freeze Function Implementation
The freeze function is used to restrict or enable token transfers for specific accounts. This can
be useful for various purposes such as implementing security measures or complying with
regulations. Let's examine its implementation:
### 5.1 Function Signature
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
public entry fun set_frozen(
admin: &signer, // The administrator's signer reference
account: address, // The address to be frozen or unfrozen
frozen: bool // The new frozen status (true to freeze, false to unfreeze)
) acquires MovementManagement
```
As with the other management functions, this can only be called by an admin and requires
access to the MovementManagement resource.
### 5.2 Detailed Implementation
```rust
public entry fun set_frozen(
admin: &signer,
account: address,
frozen: bool
) acquires MovementManagement {
// 1. Get management struct
let management = borrow_global<MovementManagement>(
object::object_address(&get_metadata())
);
// 2. Set frozen status
primary_fungible_store::set_frozen_flag(
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

&management.transfer_ref,
account,
frozen
);
// 3. Emit event
event::emit(FreezeEvent {
account,
frozen,
});
}
```
**Flow Analysis:**
1. **Management Access**
- The function retrieves the transfer_ref from the MovementManagement struct, which
provides the capability to modify account frozen status.
- This step implicitly verifies that the caller has the necessary admin rights to perform the
operation.
2. **State Update**
- The primary_fungible_store::set_frozen_flag function is called to update the frozen status of
the specified account.
- If frozen is set to true, the account will be unable to transfer tokens. If false, transfers will be
allowed.
3. **Event Emission**

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- After successfully updating the frozen status, a FreezeEvent is emitted to record the
change.
- This event includes the affected account address and the new frozen status, allowing for
easy tracking of account restrictions.
## 6. Usage Examples
To better understand how these management functions work in practice, let's look at some
usage examples:
### 6.1 Minting Tokens
```rust
// Mint 1000 tokens to user
public entry fun mint_example(admin: &signer) acquires MovementManagement {
mint_to(admin, @user, 1000);
}
```
In this example, we're minting 1000 tokens and assigning them to the @user address. The
admin signer is required to authorize this operation.
### 6.2 Burning Tokens
```rust
// Burn 500 tokens from user
public entry fun burn_example(admin: &signer) acquires MovementManagement {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

burn_from(admin, @user, 500);
}
```
This example demonstrates burning 500 tokens from the @user address. Again, the admin
signer is needed to perform this operation.
### 6.3 Freezing Account
```rust
// Freeze user account
public entry fun freeze_example(admin: &signer) acquires MovementManagement {
set_frozen(admin, @user, true);
}
```
In this example, we're freezing the @user account, preventing it from making token transfers.
The admin signer authorizes this action.
These examples demonstrate how to use the management functions in your smart contract.
Remember to always handle these functions with care, as they have significant impacts on
token circulation and user access.
# Full Code
```rust
module movement::fungible_token_tutorial {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

use std::string;
use std::option;
use aptos_framework::object;
use aptos_framework::event;
use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore,
Metadata};
use aptos_framework::primary_fungible_store;
/// =================== Constants ===================
/// Token configuration
const MOVEMENT_NAME: vector<u8> = b"Movement";
const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
const MOVEMENT_DECIMALS: u8 = 6;
/// Error codes
const ENOT_AUTHORIZED: u64 = 1;
const EINSUFFICIENT_BALANCE: u64 = 2;
const ESTORE_FROZEN: u64 = 3;
const EZERO_MINT_AMOUNT: u64 = 4;
const EZERO_BURN_AMOUNT: u64 = 5;
/// =================== Resources & Structs ===================
/// Holds the refs for managing Movement
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementManagement has key {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

mint_ref: MintRef,
burn_ref: BurnRef,
transfer_ref: TransferRef,
}
/// Events
#[event]
struct MintEvent has drop, store {
amount: u64,
recipient: address,
}
#[event]
struct BurnEvent has drop, store {
amount: u64,
from: address,
}
#[event]
struct FreezeEvent has drop, store {
account: address,
frozen: bool,
}
/// =================== Initialization ===================
/// Initialize the Movement token
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

fun init_module(module_signer: &signer) {
// Create metadata object with deterministic address
let constructor_ref = &object::create_named_object(
module_signer,
MOVEMENT_SYMBOL,
);
// Create the fungible asset with support for primary stores
primary_fungible_store::create_primary_store_enabled_fungible_asset(
constructor_ref,
option::none(), // No maximum supply
string::utf8(MOVEMENT_NAME),
string::utf8(MOVEMENT_SYMBOL),
MOVEMENT_DECIMALS,
string::utf8(b""), // Empty icon URI
string::utf8(b""), // Empty project URI
);
// Generate management references
let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
// Store the management refs in metadata object
let metadata_signer = &object::generate_signer(constructor_ref);
move_to(
metadata_signer,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

MovementManagement {
mint_ref,
burn_ref,
transfer_ref,
}
);
}
/// =================== View Functions ===================
/// Get the metadata object of Movement
#[view]
public fun get_metadata(): object::Object<fungible_asset::Metadata> {
object::address_to_object(
object::create_object_address(&@movement, MOVEMENT_SYMBOL)
)
}
/// Get the balance of an account
#[view]
public fun get_balance(account: address): u64 {
if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
primary_fungible_store::balance(account, get_metadata())
} else {
0
}
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

/// Check if account store is frozen
#[view]
public fun is_frozen(account: address): bool {
if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
primary_fungible_store::is_frozen(account, get_metadata())
} else {
false
}
}
/// =================== Management Functions ===================
/// Mint new tokens to recipient
public entry fun mint_to(
admin: &signer,
recipient: address,
amount: u64
) acquires MovementManagement {
// Verify amount
assert!(amount > 0, EZERO_MINT_AMOUNT);
// Get management struct
let management = borrow_global<MovementManagement>(
object::object_address(&get_metadata())
);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Mint tokens
primary_fungible_store::mint(&management.mint_ref, recipient, amount);
// Emit event
event::emit(MintEvent {
amount,
recipient,
});
}
/// Burn tokens from an account
public entry fun burn_from(
admin: &signer,
account: address,
amount: u64
) acquires MovementManagement {
// Verify amount
assert!(amount > 0, EZERO_BURN_AMOUNT);
// Get management struct
let management = borrow_global<MovementManagement>(
object::object_address(&get_metadata())
);
// Burn tokens
primary_fungible_store::burn(&management.burn_ref, account, amount);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Emit event
event::emit(BurnEvent {
amount,
from: account,
});
}
/// Freeze or unfreeze an account
public entry fun set_frozen(
admin: &signer,
account: address,
frozen: bool
) acquires MovementManagement {
// Get management struct
let management = borrow_global<MovementManagement>(
object::object_address(&get_metadata())
);
// Set frozen status
primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
// Emit event
event::emit(FreezeEvent {
account,
frozen,
});
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

/// =================== Tests ===================
#[test_only]
use aptos_framework::account;
#[test(creator = @movement)]
fun test_init_and_mint(creator: &signer) acquires MovementManagement {
// Initialize token
init_module(creator);
// Create test account
let test_account = account::create_account_for_test(@0x123);
// Mint tokens
mint_to(creator, @0x123, 1000);
// Verify balance
assert!(get_balance(@0x123) == 1000, 1);
}
#[test(creator = @movement)]
fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
// Initialize
init_module(creator);
// Create test account
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let test_account = account::create_account_for_test(@0x123);
// Mint tokens
mint_to(creator, @0x123, 1000);
// Freeze account
set_frozen(creator, @0x123, true);
assert!(is_frozen(@0x123), 1);
// Unfreeze account
set_frozen(creator, @0x123, false);
assert!(!is_frozen(@0x123), 2);
}
}
```
# Transfer a Fungible Asset
## 1. Overview of Transfer Functions in Fungible Asset Systems
### 1.1. Purpose and Importance of User Functions
User Functions play a crucial role in fungible asset systems, providing essential capabilities for
end users to interact with their tokens. These functions are designed with user-friendliness and
security in mind, enabling individuals to:
- Perform token transfers: Move assets between accounts safely and efficiently
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Manage their tokens: Check balances, view transaction history, and handle asset-related tasks
- Interact with the token system: Engage in various token-related activities within the ecosystem
By offering these functionalities, User Functions empower users to have full control over their
digital assets while maintaining the integrity and security of the overall system.
### 1.2. Types of Transfer Functions
Transfer functions are a critical component of User Functions, allowing for the movement of
tokens between accounts. There are two primary types of transfer functions, each serving
different purposes and use cases:
1. **Regular Transfer**
- Definition: A standard token transfer initiated by the token owner
- Key characteristics:
- Sender must be the rightful owner of the tokens
- Respects the frozen status of accounts (cannot transfer from or to frozen accounts)
- Requires sufficient balance in the sender's account
- Use cases:
- Peer-to-peer transactions
- Payments for goods or services
- Moving tokens between personal accounts
2. **Force Transfer**
- Definition: A mandatory token transfer executed by an administrator
- Key characteristics:
- Admin-only privilege, restricted to authorized system administrators
- Bypasses frozen status, allowing transfers involving frozen accounts
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Can be executed without the token owner's consent
- Use cases:
- Regulatory compliance and legal orders
- Error correction and dispute resolution
- System maintenance and upgrades
- Important considerations:
- Should be used sparingly and only when absolutely necessary
- Requires robust governance and oversight to prevent misuse
- May have implications for user trust and system decentralization
## 2. Events and Error Handling
In Move programming, events and error handling are crucial for creating robust and
user-friendly smart contracts. Let's dive into these concepts with some practical examples.
### 2.1. Event Structure
Events in Move are used to emit important information about state changes. Here's an example
of a TransferEvent structure:
```
// This event is emitted when a transfer occurs
struct TransferEvent has drop, store {
amount: u64, // The amount of tokens transferred
from: address, // The address sending the tokens
to: address, // The address receiving the tokens
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Usage example:
event::emit(TransferEvent {
amount: 100,
from: @0x1234,
to: @0x5678,
});
```
In this example, we define a TransferEvent that captures the essential information of a token
transfer. The 'drop' and 'store' abilities allow this struct to be discarded and stored in global
storage, respectively.
### 2.2. Error Constants
Error constants help in providing clear and consistent error messages. Here's an expanded set
of error constants:
```
// Error constants for better error handling
const EINSUFFICIENT_BALANCE: u64 = 1;
const EZERO_AMOUNT: u64 = 2;
const EFROZEN_ACCOUNT: u64 = 3;
const EINVALID_RECIPIENT: u64 = 4;
const EUNAUTHORIZED: u64 = 5;
// Usage example:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

assert!(balance >= amount, EINSUFFICIENT_BALANCE);
```
These constants make your code more readable and maintainable. When an error occurs, you
can easily identify the issue based on the error code.
## 3. Regular Transfer Implementation
Now, let's implement a regular transfer function with detailed explanations and error handling.
### 3.1. Function Signature
```
public entry fun transfer(
from: &signer, // The account initiating the transfer
to: address, // The recipient's address
amount: u64 // The amount to transfer
)
```
This function signature defines a public entry function that can be called directly from outside
the module.
### 3.2. Detailed Implementation
```
public entry fun transfer(
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

from: &signer,
to: address,
amount: u64
){
// 1. Amount validation
assert!(amount > 0, EZERO_AMOUNT);
// 2. Check if the recipient address is valid
assert!(to != @0x0, EINVALID_RECIPIENT);
// 3. Get the sender's address
let sender = signer::address_of(from);
// 4. Check if the sender has sufficient balance
assert!(balance::get(sender) >= amount, EINSUFFICIENT_BALANCE);
// 5. Check if either account is frozen
assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
// 6. Perform transfer
primary_fungible_store::transfer(
from,
get_metadata(),
to,
amount
);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// 7. Emit transfer event
event::emit(TransferEvent {
amount,
from: sender,
to,
});
}
```
This implementation includes several important steps:
1. We validate that the amount is not zero.
2. We ensure the recipient address is valid.
3. We get the sender's address from the signer.
4. We check if the sender has sufficient balance.
5. We verify that neither account is frozen.
6. We perform the actual transfer using the primary_fungible_store module.
7. Finally, we emit a TransferEvent to log the transfer.
Each step includes error handling to ensure the transfer meets all requirements before
execution.
### 3.3. Flow Analysis
Let's break down the transfer function to understand its flow and key components. This analysis
will help newcomers grasp the intricacies of implementing a secure token transfer system.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### 3.3.1. Validation Steps
Before executing the transfer, we perform several crucial checks:
```rust
// Amount validation
assert!(amount > 0, EZERO_AMOUNT);
// Sender's balance check
let sender_balance = balance::get(sender);
assert!(sender_balance >= amount, EINSUFFICIENT_BALANCE);
// Frozen status check
assert!(!is_account_frozen(sender) && !is_account_frozen(to), EFROZEN_ACCOUNT);
// Recipient address validation
assert!(to != @0x0, EINVALID_RECIPIENT);
```
Let's examine each validation step:
1. Amount Validation: We ensure the transfer amount is greater than zero to prevent
meaningless transactions.
2. Balance Check: We verify that the sender has sufficient funds for the transfer.
3. Frozen Status: We check if either the sender's or recipient's account is frozen, preventing
transfers involving frozen accounts.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

4. Recipient Validation: We confirm that the recipient's address is valid and not the zero
address.
These checks help maintain the integrity and security of the transfer process.
### 3.3.2. Transfer Process
Once all validations pass, we proceed with the actual transfer:
```rust
// Transfer using primary store
primary_fungible_store::transfer(from, get_metadata(), to, amount);
```
This function call encapsulates several important steps:
1. Store Creation: If the recipient doesn't have a store for this token, one is automatically
created.
2. Withdrawal: The specified amount is withdrawn from the sender's account.
3. Deposit: The withdrawn amount is deposited into the recipient's account.
4. Error Handling: Any issues during these steps (e.g., insufficient balance) are automatically
handled.
After the transfer, we emit an event to log the transaction:
```rust
// Emit transfer event
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

event::emit(TransferEvent {
amount,
from: sender,
to,
});
```
This event emission is crucial for maintaining a transparent record of all transfers, which can be
used for auditing or providing transaction history to users.
### 3.3.3. Error Handling
Throughout the process, we use assert! statements for error handling. When an assertion fails,
it aborts the transaction with a specific error code. For example:
```rust
assert!(amount > 0, EZERO_AMOUNT);
```
If amount is zero or negative, the transaction will abort with the EZERO_AMOUNT error. This
approach ensures that invalid operations are caught early and prevented from executing.
## 4. Force Transfer Implementation
Force transfer is a powerful feature that allows authorized administrators to move tokens
between accounts without the sender's consent. This functionality is crucial for certain scenarios
but should be used with caution.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### 4.1. Function Signature
Let's break down the function signature for force transfer:
```rust
public entry fun force_transfer(
admin: &signer,
from: address,
to: address,
amount: u64
) acquires MovementManagement
```
Here's what each parameter means:
- admin: &signer - The administrator initiating the force transfer
- from: address - The address from which tokens will be taken
- to: address - The address receiving the tokens
- amount: u64 - The number of tokens to transfer
The 'acquires MovementManagement' clause indicates that this function will access the
MovementManagement resource.
### 4.2. Detailed Implementation
Now, let's examine the implementation step-by-step:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
public entry fun force_transfer(
admin: &signer,
from: address,
to: address,
amount: u64
) acquires MovementManagement {
// 1. Verify admin rights
assert!(is_admin(signer::address_of(admin)), EUNAUTHORIZED);
// 2. Amount validation
assert!(amount > 0, EZERO_AMOUNT);
// 3. Get management struct
let management = borrow_global&lt;MovementManagement&gt;(
object::object_address(&get_metadata())
);
// 4. Check if either account is frozen (optional for force transfer)
if (!is_force_transfer_allowed_when_frozen()) {
assert!(!is_account_frozen(from) && !is_account_frozen(to), EFROZEN_ACCOUNT);
}
// 5. Perform force transfer
primary_fungible_store::transfer_with_ref(
&management.transfer_ref,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

from,
to,
amount
);
// 6. Emit event
event::emit(TransferEvent {
amount,
from,
to,
});
// 7. Log force transfer for auditing
log_force_transfer(admin, from, to, amount);
}
```
Let's break down each step:
1. Verify admin rights: We first check if the signer is an authorized admin.
2. Amount validation: Ensure the transfer amount is greater than zero.
3. Get management struct: Retrieve the MovementManagement resource, which contains
necessary references for the transfer.
4. Frozen account check: Optionally check if accounts are frozen, based on system
configuration.
5. Perform force transfer: Use the transfer_with_ref function to move tokens without the sender's
signature.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

6. Emit event: Log the transfer event for transparency.
7. Audit logging: Record the force transfer details for future auditing.
This implementation ensures that only authorized admins can perform force transfers, maintains
proper event logging, and includes optional checks for frozen accounts. The use of
transfer_with_ref allows bypassing normal transfer restrictions.
### Regular Transfer Example
```rust
public entry fun transfer(
from: &signer,
to: address,
amount: u64
){
// Verify amount
assert!(amount > 0, EINSUFFICIENT_BALANCE);
// Perform transfer
primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
```
### Force Transfer Example
```rust
/// Force transfer (admin only)
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public entry fun force_transfer(
admin: &signer,
from: address,
to: address,
amount: u64
) acquires MovementManagement {
// Get management struct
let management = borrow_global<MovementManagement>(
object::object_address(&get_metadata())
);
// Perform force transfer
primary_fungible_store::transfer_with_ref(
&management.transfer_ref,
from,
to,
amount
);
// Emit event
event::emit(TransferEvent {
amount,
from,
to,
});
}
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

# Full Code
```rust
module movement::fungible_token_tutorial {
use std::string;
use std::option;
use aptos_framework::object;
use aptos_framework::event;
use aptos_framework::fungible_asset::{Self, MintRef, TransferRef, BurnRef, FungibleStore,
Metadata};
use aptos_framework::primary_fungible_store;
/// =================== Constants ===================
/// Token configuration
const MOVEMENT_NAME: vector<u8> = b"Movement";
const MOVEMENT_SYMBOL: vector<u8> = b"MOVE";
const MOVEMENT_DECIMALS: u8 = 6;
/// Error codes
const ENOT_AUTHORIZED: u64 = 1;
const EINSUFFICIENT_BALANCE: u64 = 2;
const ESTORE_FROZEN: u64 = 3;
const EZERO_MINT_AMOUNT: u64 = 4;
const EZERO_BURN_AMOUNT: u64 = 5;

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

/// =================== Resources & Structs ===================
/// Holds the refs for managing Movement
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementManagement has key {
mint_ref: MintRef,
burn_ref: BurnRef,
transfer_ref: TransferRef,
}
/// Events
#[event]
struct MintEvent has drop, store {
amount: u64,
recipient: address,
}
#[event]
struct BurnEvent has drop, store {
amount: u64,
from: address,
}
#[event]
struct TransferEvent has drop, store {
amount: u64,
from: address,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

to: address,
}
#[event]
struct FreezeEvent has drop, store {
account: address,
frozen: bool,
}
/// =================== Initialization ===================
/// Initialize the Movement token
fun init_module(module_signer: &signer) {
// Create metadata object with deterministic address
let constructor_ref = &object::create_named_object(
module_signer,
MOVEMENT_SYMBOL,
);
// Create the fungible asset with support for primary stores
primary_fungible_store::create_primary_store_enabled_fungible_asset(
constructor_ref,
option::none(), // No maximum supply
string::utf8(MOVEMENT_NAME),
string::utf8(MOVEMENT_SYMBOL),
MOVEMENT_DECIMALS,
string::utf8(b""), // Empty icon URI
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

string::utf8(b""), // Empty project URI
);
// Generate management references
let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
// Store the management refs in metadata object
let metadata_signer = &object::generate_signer(constructor_ref);
move_to(
metadata_signer,
MovementManagement {
mint_ref,
burn_ref,
transfer_ref,
}
);
}
/// =================== View Functions ===================
/// Get the metadata object of Movement
#[view]
public fun get_metadata(): object::Object<fungible_asset::Metadata> {
object::address_to_object(
object::create_object_address(&@movement, MOVEMENT_SYMBOL)
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

)
}
/// Get the balance of an account
#[view]
public fun get_balance(account: address): u64 {
if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
primary_fungible_store::balance(account, get_metadata())
} else {
0
}
}
/// Check if account store is frozen
#[view]
public fun is_frozen(account: address): bool {
if (primary_fungible_store::primary_store_exists(account, get_metadata())) {
primary_fungible_store::is_frozen(account, get_metadata())
} else {
false
}
}
/// =================== Management Functions ===================
/// Mint new tokens to recipient
public entry fun mint_to(
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

admin: &signer,
recipient: address,
amount: u64
) acquires MovementManagement {
// Verify amount
assert!(amount > 0, EZERO_MINT_AMOUNT);
// Get management struct
let management = borrow_global<MovementManagement>(
object::object_address(&get_metadata())
);
// Mint tokens
primary_fungible_store::mint(&management.mint_ref, recipient, amount);
// Emit event
event::emit(MintEvent {
amount,
recipient,
});
}
/// Burn tokens from an account
public entry fun burn_from(
admin: &signer,
account: address,
amount: u64
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

) acquires MovementManagement {
// Verify amount
assert!(amount > 0, EZERO_BURN_AMOUNT);
// Get management struct
let management = borrow_global<MovementManagement>(
object::object_address(&get_metadata())
);
// Burn tokens
primary_fungible_store::burn(&management.burn_ref, account, amount);
// Emit event
event::emit(BurnEvent {
amount,
from: account,
});
}
/// Freeze or unfreeze an account
public entry fun set_frozen(
admin: &signer,
account: address,
frozen: bool
) acquires MovementManagement {
// Get management struct
let management = borrow_global<MovementManagement>(
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

object::object_address(&get_metadata())
);
// Set frozen status
primary_fungible_store::set_frozen_flag(&management.transfer_ref, account, frozen);
// Emit event
event::emit(FreezeEvent {
account,
frozen,
});
}
/// =================== User Functions ===================
/// Transfer tokens from sender to recipient
public entry fun transfer(
from: &signer,
to: address,
amount: u64
){
// Verify amount
assert!(amount > 0, EINSUFFICIENT_BALANCE);
// Perform transfer
primary_fungible_store::transfer(from, get_metadata(), to, amount);
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

/// Force transfer (admin only)
public entry fun force_transfer(
admin: &signer,
from: address,
to: address,
amount: u64
) acquires MovementManagement {
// Get management struct
let management = borrow_global<MovementManagement>(
object::object_address(&get_metadata())
);
// Perform force transfer
primary_fungible_store::transfer_with_ref(
&management.transfer_ref,
from,
to,
amount
);
// Emit event
event::emit(TransferEvent {
amount,
from,
to,
});
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
/// =================== Tests ===================
#[test_only]
use aptos_framework::account;
#[test(creator = @movement)]
fun test_init_and_mint(creator: &signer) acquires MovementManagement {
// Initialize token
init_module(creator);
// Create test account
let test_account = account::create_account_for_test(@0x123);
// Mint tokens
mint_to(creator, @0x123, 1000);
// Verify balance
assert!(get_balance(@0x123) == 1000, 1);
}
#[test(creator = @movement)]
fun test_freeze_unfreeze(creator: &signer) acquires MovementManagement {
// Initialize
init_module(creator);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Create test account
let test_account = account::create_account_for_test(@0x123);
// Mint tokens
mint_to(creator, @0x123, 1000);
// Freeze account
set_frozen(creator, @0x123, true);
assert!(is_frozen(@0x123), 1);
// Unfreeze account
set_frozen(creator, @0x123, false);
assert!(!is_frozen(@0x123), 2);
}
}
```
# AMM and Constant Product Formula: The Foundation of DEX
## 1. Traditional Markets vs AMM
### Traditional Markets
In traditional markets (such as stock exchanges):
- Buyers and sellers place orders
- Orders are matched when prices align
- Participants must wait for a matching counterparty
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- An order book system is used
Example of an order book:
```
Buy Orders: Sell Orders:
$10.00 - 100 $10.20 - 150
$9.90 - 200 $10.30 - 100
$9.80 - 150 $10.40 - 200
```
In this example, buyers are willing to buy at $10.00 or lower, while sellers are asking $10.20 or
higher. A trade occurs when these prices meet.
### AMM Approach
In Automated Market Makers (AMM):
- No order book is used
- Buyers and sellers don't need to be matched
- Trades occur against a liquidity pool
- Prices are determined by a mathematical formula
- Instant trades are available at any time
Let's look at a simple AMM example:
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Simple AMM swap function
fun swap(amount_in: u64, reserve_in: u64, reserve_out: u64): u64 {
let fee = 3; // 0.3% fee (3 basis points)
let amount_in_with_fee = amount_in * (1000 - fee) / 1000;
let numerator = (amount_in_with_fee as u128) * (reserve_out as u128);
let denominator = (reserve_in as u128) + (amount_in_with_fee as u128);
((numerator / denominator) as u64)
}
```
This code demonstrates a basic AMM swap. Users can trade instantly without waiting for a
counterparty, and the price is determined by the ratio of tokens in the pool.
## 2. Understanding Liquidity Pools
### 2.1 Basic Concept
Imagine a liquidity pool as two interconnected water tanks:
```
Tank X [1000 X] ←→ Tank Y [1000 Y]
```
- Adding X yields Y
- Adding Y yields X
- The ratio between X and Y determines the price

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

This code demonstrates how a liquidity pool maintains balance and adjusts prices based on
trades.
### 2.2 Simple Example
Initial pool:
```
Pool X: 1000 tokens
Pool Y: 1000 tokens
Price: 1 X = 1 Y
```
After swapping 100 X:
```
Pool X: 1100 tokens
Pool Y: 909.09 tokens (approximately)
Price: 1 X = 0.826 Y
```
Let's calculate this swap step-by-step:
```rust
fun swap_tokens(
initial_x: u64,
initial_y: u64,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

swap_amount: u64
): (u64, u64, FixedPoint32) {
let new_y = (initial_x as u128) * (initial_y as u128) / ((initial_x + swap_amount) as u128);
let y_out = initial_y - (new_y as u64);
let new_x = initial_x + swap_amount;
let new_price = FixedPoint32::create_from_rational(new_y as u64, new_x)
(y_out, new_y as u64, new_price)
}
```
This code shows how to calculate the exact amounts for a swap and the resulting price change.
Understanding these calculations is crucial for grasping how AMMs work.
## 3. Constant Product Formula Deep Dive
### 3.1 The Basic Formula
The core of AMM is the constant product formula:
```
x*y=k
```
Where:
- x and y are the quantities of two tokens in the pool
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- k is a constant that remains the same before and after trades
Here's how we can represent this in Move code:
```rust
fun check_constant_product(
x1: u64,
// initial amount of token X
y1: u64,
// initial amount of token Y
x2: u64,
// final amount of token X
y2: u64
// final amount of token Y
): bool {
let k1 = (x1 as u128) * (y1 as u128);
let k2 = (x2 as u128) * (y2 as u128);
k1 == k2
}
```
This function checks if the product of token amounts remains constant before and after a trade.
We use u128 to avoid overflow in multiplication.
### 3.2 Real-world Examples
### Example 1: Small Trade
Let's start with a simple pool:
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Pool X = 1000 tokens
Pool Y = 1000 tokens
k = 1,000,000
```
Now, let's say a user wants to swap 10 X tokens. We can calculate how many Y tokens they'll
receive:
```
(1000 + 10) * (1000 - y) = 1,000,000
1010 * (1000 - y) = 1,000,000
y ≈ 9.9 Y tokens (received)
```
Here's a Move function to calculate this:
```rust
public fun get_amount_out(
amount_in: u64,
reserve_in: u64,
reserve_out: u64
): u64 {
let amount_in_with_fee = (amount_in as u128) * 9975u128;
let numerator = amount_in_with_fee * (reserve_out as u128);
let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
((numerator / denominator) as u64)
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
This function calculates how many tokens a user will receive based on the amount they're
putting in and the current reserves. We use u128 for intermediate calculations to avoid overflow.
### 3.3 Understanding Price Impact
Price impact occurs because larger trades cause more significant price movements. Here's how
we can calculate it:
```rust
public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
(((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
```
This function calculates the percentage change in price caused by a trade. Here's a breakdown:
1. We calculate the initial price (reserve_out / reserve_in).
2. We determine how many tokens the user will receive (amount_out).
3. We calculate the new reserves after the trade.
4. We determine the new price after the trade.
5. Finally, we calculate the percentage difference between the initial and final prices.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Understanding price impact is crucial for traders, as it helps them anticipate how their trades will
affect the market and their returns.
## 4. Liquidity Provider Mechanics
### 4.1 Adding Liquidity
When adding liquidity to a pool, it's crucial to maintain the existing ratio of tokens. This ensures
the pool's balance and price remain stable. Here's how to calculate the amount of token Y you
need to add based on the amount of token X:
```
Amount Y to add = (Amount X to add * Pool Y) / Pool X
```
Let's break this down with a step-by-step example:
```
Initial Pool State:
Pool X: 1000 tokens
Pool Y: 2000 tokens
Current Price: 1 X = 2 Y
Step 1: Decide how much of token X you want to add
Let's say you want to add 100 X tokens.
Step 2: Calculate the required amount of Y tokens
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Y needed = (100 * 2000) / 1000 = 200 Y
Step 3: Add liquidity
You'll need to add 100 X tokens and 200 Y tokens to maintain the pool's ratio.
```
This calculation ensures that you're adding liquidity in the correct proportion, preserving the
pool's price equilibrium.
### 4.2 LP Token Distribution
Liquidity Provider (LP) tokens represent your share of the pool. They're crucial for tracking
ownership and distributing rewards. Let's explore how LP tokens are calculated for both the first
provider and subsequent providers.
For the first liquidity provider:
```rust
fun calculate_initial_lp_tokens(
amount_x: u64,
amount_y: u64
): u64 {
let product = (amount_x as u128) * (amount_y as u128);
let sqrt_product = math::sqrt(product);
((sqrt_product - MINIMUM_LIQUIDITY) as u64)
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Example usage:
let initial_x = 1000;
let initial_y = 2000;
let initial_lp_tokens = calculate_initial_lp_tokens(initial_x, initial_y);
```
This function calculates the initial LP tokens by taking the square root of the product of the two
token amounts. We subtract a small amount (MINIMUM_LIQUIDITY) to prevent the first provider
from owning 100% of the pool, which could lead to manipulation.
## 5. Real-world Scenarios
### 5.1 Trading Example
Let's walk through a complete trading scenario to understand how AMMs work in practice:
1. Initial Pool State:
```
Pool X: 10,000 tokens
Pool Y: 20,000 tokens
Initial Price: 1 X = 2 Y
// You can verify this price:
Price of X in terms of Y = Pool Y / Pool X = 20,000 / 10,000 = 2 Y per X
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

1. User wants to swap 1,000 X tokens:
```rust
// Step 1: Calculate Y tokens received before fee
// y = (Pool Y * Amount X) / (Pool X + Amount X)
// y = (20,000 * 1,000) / (10,000 + 1,000) = 1,818.18 Y
// Step 2: Apply the 0.25% fee
// y_after_fee = 1,818.18 * (1 - 0.0025) = 1,813.63 Y
// Let's implement this in code:
public fun get_amount_out(
amount_in: u64,
reserve_in: u64,
reserve_out: u64
): u64 {
assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
let amount_in_with_fee = (amount_in as u128) * 9975u128;
let numerator = amount_in_with_fee * (reserve_out as u128);
let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
((numerator / denominator) as u64)
}
```
1. Final Pool State:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
Pool X: 11,000 tokens (10,000 + 1,000)
Pool Y: 18,186.37 tokens (20,000 - 1,813.63)
New Price: 1 X = 1.65 Y (18,186.37 / 11,000)
// Verify the constant product:
Before trade: 10,000 * 20,000 = 200,000,000
After trade: 11,000 * 18,186.37 ≈ 200,050,070 (slight increase due to fees)
```
This example demonstrates how a trade affects the pool's balance and price. The price of X in
terms of Y decreased because we added X to the pool and removed Y.
### 5.2 Providing Liquidity Example
1. Initial Pool:
```rust
// Pool X: 10,000 tokens
// Pool Y: 20,000 tokens
// LP Total Supply: 14,142 tokens (sqrt(10,000 * 20,000))
// Let's implement this in code:
fun calculate_initial_lp_supply(reserve_x: u64, reserve_y: u64): u64 {
let product = (reserve_x as u128) * (reserve_y as u128);
(math::sqrt(product) as u64)
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
```
1. Adding 1,000 X and 2,000 Y:
```rust
// Step 1: Calculate the share of the pool
// share = min((1,000 / 10,000), (2,000 / 20,000)) = 0.1 or 10%
// Step 2: Calculate new LP tokens
// new_lp_tokens = 0.1 * 14,142 = 1,414.2 LP tokens
// Let's implement this in code:
fun calculate_lp_tokens_to_mint(
amount_x: u64,
amount_y: u64,
reserve_x: u64,
reserve_y: u64,
total_supply: u64
): u64 {
let share_x = ((amount_x as u128) * (total_supply as u128)) / (reserve_x as u128);
let share_y = ((amount_y as u128) * (total_supply as u128)) / (reserve_y as u128);
min(share_x, share_y) as u64
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

This example shows how to calculate the number of LP tokens a liquidity provider receives
when adding to an existing pool. The provider receives LP tokens proportional to their share of
the pool's liquidity.
# Foundation and Basic Structures
### Key Points:
- This guide covers building a Decentralized Exchange (DEX) using Move on the Movement
blockchain
- Core data structures include LPToken, TokenPairMetadata, TokenPairReserve, and SwapInfo
- Constants and error codes are defined for consistency and error handling
- Module initialization sets up basic DEX infrastructure
- Event structures track important DEX operations
- The tutorial covers fundamental components and will progress to implementing core
functionalities
## Introduction
Welcome to our comprehensive guide on building a Decentralized Exchange (DEX) using Move,
the programming language for the Movement blockchain. In this tutorial, we'll break down the
fundamental components of a DEX, making it accessible for beginners while providing in-depth
explanations for more advanced concepts.
## Core Data Structures

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Let's start by exploring the essential data structures that form the backbone of our DEX. We'll
explain each structure in detail, providing examples and use cases to help you understand their
roles in the system.
### 1. LPToken Structure
```
struct LPToken<phantom X, phantom Y> has key {}
```
This structure represents Liquidity Provider (LP) tokens, which are given to users who provide
liquidity to the exchange. Let's break it down:
- `struct LPToken`: Defines a new type called LPToken.
- `&lt;phantom X, phantom Y&gt;`: These are generic type parameters representing the two
tokens in a trading pair. The `phantom` keyword means these types are used only for type
checking, not for data storage.
- `has key`: This ability allows the struct to be stored as a top-level item in global storage.
Example usage:
```
// Creating an LPToken for a BTC-ETH pair
let btc_eth_lp_token: LPToken<BTC, ETH>;
```
### 2. TokenPairMetadata Structure
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
struct TokenPairMetadata<phantom X, phantom Y> has key {
creator: address,
fee_amount: coin::Coin<LPToken<X, Y>>,
k_last: u128,
balance_x: coin::Coin<X>,
balance_y: coin::Coin<Y>,
mint_cap: coin::MintCapability<LPToken<X, Y>>,
burn_cap: coin::BurnCapability<LPToken<X, Y>>,
freeze_cap: coin::FreezeCapability<LPToken<X, Y>>
}
```
This structure stores crucial information about each trading pair. Let's examine each field:
- `creator`: The address of the account that created this trading pair.
- `fee_amount`: Accumulated trading fees in the form of LP tokens.
- `k_last`: The last recorded product of reserves, used for fee calculations in constant product
AMMs.
- `balance_x` and `balance_y`: Current balances of both tokens in the pair.
- `mint_cap`, `burn_cap`, `freeze_cap`: Capabilities for managing LP tokens.
Example usage:
```
let btc_eth_metadata = TokenPairMetadata<BTC, ETH> {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

creator: @0x1,
fee_amount: coin::zero(),
k_last: 1000000, // Initial k value
balance_x: coin::zero<BTC>(),
balance_y: coin::zero<ETH>(),
mint_cap: // ... obtain mint capability
burn_cap: // ... obtain burn capability
freeze_cap: // ... obtain freeze capability
};
```
### 3. TokenPairReserve Structure
```
struct TokenPairReserve<phantom X, phantom Y> has key {
reserve_x: u64,
reserve_y: u64,
block_timestamp_last: u64
}
```
This structure keeps track of the current state of liquidity reserves for a trading pair:
- `reserve_x` and `reserve_y`: Current reserves for both tokens in the pair.
- `block_timestamp_last`: Timestamp of the last update to the reserves.
### 4. SwapInfo Structure
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
struct SwapInfo has key {
signer_cap: account::SignerCapability,
fee_to: address,
admin: address,
pair_created: event::EventHandle<PairCreatedEvent>
}
```
This structure stores global configuration for the DEX:
- `signer_cap`: Capability to sign transactions on behalf of the DEX.
- `fee_to`: Address where trading fees are sent.
- `admin`: Address of the DEX administrator.
- `pair_created`: Event handle for tracking new trading pair creations.
## Constants and Error Codes
Constants and error codes are crucial for maintaining consistency and proper error handling in
your DEX. Let's break them down:
```
const ZERO_ACCOUNT: address = @0x0;
const DEFAULT_ADMIN: address = @movement;
const MINIMUM_LIQUIDITY: u128 = 1000;
const MAX_COIN_NAME_LENGTH: u64 = 32;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
These constants define important values used throughout the DEX:
- `ZERO_ACCOUNT`: Represents an empty or null address.
- `DEFAULT_ADMIN`: The default administrator address for the DEX.
- `MINIMUM_LIQUIDITY`: The smallest amount of liquidity required to create a new pool.
- `MAX_COIN_NAME_LENGTH`: Maximum allowed length for coin names.
Error codes:
```
const ERROR_ONLY_ADMIN: u64 = 0x0001;
const ERROR_ALREADY_INITIALIZED: u64 = 0x001;
// ... (other error codes)
```
These error codes help identify specific issues that may occur during DEX operations:
- `ERROR_ONLY_ADMIN`: Thrown when a non-admin tries to perform an admin-only action.
- `ERROR_ALREADY_INITIALIZED`: Thrown when trying to initialize an already initialized
component.
## Module Initialization
The initialization function sets up the basic DEX infrastructure:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
fun init_module(sender: &signer) {
let signer_cap = resource_account::retrieve_resource_account_cap(sender,
DEFAULT_ADMIN);
let resource_signer = account::create_signer_with_capability(&signer_cap);
move_to(&resource_signer, SwapInfo {
signer_cap,
fee_to: ZERO_ACCOUNT,
admin: DEFAULT_ADMIN,
pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
});
}
```
Let's break down this initialization process:
1. Retrieve the resource account capability using the sender and DEFAULT_ADMIN address.
2. Create a resource signer using the obtained capability.
3. Initialize the SwapInfo structure with default values.
4. Store the SwapInfo in the global storage using the resource signer.
## Event Structures
Events are crucial for tracking important operations in your DEX. Let's examine the event
structures:
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

struct PairCreatedEvent has drop, store {
user: address,
token_x: string::String,
token_y: string::String
}
struct PairEventHolder<phantom X, phantom Y> has key {
add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
swap: event::EventHandle<SwapEvent<X, Y>>
}
```
These structures enable event tracking for various DEX operations:
- `PairCreatedEvent`: Emitted when a new trading pair is created.
- `PairEventHolder`: Holds event handles for liquidity operations and swaps.
## Next Steps
Now that we've covered the fundamental structures and initialization of our DEX, in the next part
of this tutorial, we'll delve into implementing core functionalities:
- Creating and managing trading pairs
- Implementing liquidity provision and removal
- Developing the token swap mechanism
- Calculating and distributing fees
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Stay tuned for Part 2, where we'll build upon these foundations to create a fully functional DEX!
# Creating Trading Pairs in a DEX
### Key points covered:
- Understanding the `create_pair` function and its parameters
- Performing initial checks and setup for pair creation
- Generating a unique name for the LP (Liquidity Provider) token
- Initializing the LP token with specific attributes
- Setting up pool state data structures
- Configuring event tracking for liquidity and swap actions
- Emitting a PairCreatedEvent to notify listeners
- Registering the ability to hold LP tokens
## Introduction to Creating Trading Pairs in a DEX
Welcome to this beginner-friendly tutorial on creating trading pairs in a Decentralized Exchange
(DEX). We'll explore the `create_pair` function, which is the foundation of setting up liquidity
pools for token trading. Don't worry if some terms are unfamiliar - we'll break everything down
step-by-step!
## 1. Understanding the create_pair Function
Let's start by looking at the basic structure of our `create_pair` function:
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public fun create_pair<X, Y>(sender: &signer) acquires SwapInfo {
// Implementation will go here
}
```
Here's what each part means:
- `public fun`: This function can be called by anyone
- `<X, Y>`: These are generic type parameters representing our two tokens
- `sender: &signer`: The user creating the pair must sign the transaction
- `acquires SwapInfo`: This function will access global state information
## 2. Initial Checks and Setup
Before creating a new pair, we need to perform some checks and setup:
```
assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
let sender_addr = signer::address_of(sender);
let swap_info = borrow_global_mut<SwapInfo>(DEFAULT_ADMIN);
let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
```
Let's break this down:
- We first check if the pair already exists. If it does, we stop the process.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- We get the address of the sender for later use.
- We borrow the global SwapInfo to access shared state.
- We create a special "resource signer" that allows the contract to manage resources.
## 3. Creating the LP Token Name
LP stands for "Liquidity Provider". We need to create a unique name for our LP token:
```
let lp_name: string::String = string::utf8(b"movement-");
let name_x = coin::symbol<X>();
let name_y = coin::symbol<Y>();
string::append(&mut lp_name, name_x);
string::append_utf8(&mut lp_name, b"-");
string::append(&mut lp_name, name_y);
string::append_utf8(&mut lp_name, b"-LP");
if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
lp_name = string::utf8(b"movement LPs");
};
```
This code does the following:
- Starts with "movement-"
- Adds the symbols of both tokens
- Ends with "-LP"
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- If the name is too long, it uses a generic "movement LPs" instead
## 4. Initializing the LP Token
Now we create the actual LP token:
```
let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
&resource_signer,
lp_name,
string::utf8(b"Move-LP"),
8,
true
);
```
This function call does several things:
- Creates a new token type `LPToken<X, Y>`
- Sets its name to our generated `lp_name`
- Sets its symbol to "Move-LP"
- Sets 8 decimal places
- Enables supply tracking
- Returns capabilities for burning, freezing, and minting these tokens
## 5. Setting Up the Pool State

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

We need to initialize some data structures to keep track of our trading pair:
```
move_to<TokenPairReserve<X, Y>>(
&resource_signer,
TokenPairReserve {
reserve_x: 0,
reserve_y: 0,
block_timestamp_last: 0
}
);
move_to<TokenPairMetadata<X, Y>>(
&resource_signer,
TokenPairMetadata {
creator: sender_addr,
fee_amount: coin::zero<LPToken<X, Y>>(),
k_last: 0,
balance_x: coin::zero<X>(),
balance_y: coin::zero<Y>(),
mint_cap,
burn_cap,
freeze_cap,
}
);
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

This initializes two important structures:
- `TokenPairReserve`: Keeps track of the current amounts of each token in the pool
- `TokenPairMetadata`: Stores various pieces of information about the pair, including who
created it, accumulated fees, and token balances
## 6. Setting Up Events and Finalizing
Lastly, we set up event tracking and finalize the pair creation:
```
move_to<PairEventHolder<X, Y>>(
&resource_signer,
PairEventHolder {
add_liquidity: account::new_event_handle<AddLiquidityEvent<X, Y>>(&resource_signer),
remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X,
Y>>(&resource_signer),
swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
}
);
let token_x = type_info::type_name<X>();
let token_y = type_info::type_name<Y>();
event::emit_event<PairCreatedEvent>(
&mut swap_info.pair_created,
PairCreatedEvent {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

user: sender_addr,
token_x,
token_y
}
);
register_lp<X, Y>(&resource_signer);
```
This final part:
- Sets up event handlers for adding liquidity, removing liquidity, and swapping
- Emits a "PairCreatedEvent" to notify listeners that a new pair has been created
- Registers the ability to hold LP tokens
## Conclusion
Congratulations! You've just learned about the intricate process of creating a trading pair in a
DEX. This function sets up the foundation for users to provide liquidity and trade tokens. In the
next part of this tutorial, we'll explore how to add liquidity to our newly created pair. Stay tuned!
# Adding Liquidity in a DEX
## Summary
- Adding liquidity in a DEX involves users providing token pairs to create trading pools
- The process is managed through the `add_liquidity` function, which handles token withdrawal,
deposit, and LP token minting
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Optimal amounts are calculated to maintain the pool's price ratio and prevent manipulation
- LP tokens are minted proportionally to the liquidity provided, with special considerations for
initial liquidity
- Safety measures include slippage protection, minimum liquidity requirements, and atomic state
updates
- Events are emitted for transparency and off-chain tracking of pool activities
- The process ensures fair distribution of LP tokens and maintains the constant product formula
## Introduction to Adding Liquidity in a DEX
Adding liquidity is a fundamental operation in any Decentralized Exchange (DEX). When users
provide token pairs to create trading pools, they receive Liquidity Provider (LP) tokens in return.
This process is crucial for maintaining the DEX's functionality and liquidity. Let's dive into the
detailed implementation of the `add_liquidity` function and its components, breaking it down for
beginners.
## 1. Understanding the Main Entry Point: add_liquidity
The `add_liquidity` function is the primary way users interact with the liquidity pool. Let's
examine its structure and purpose:
```rust
public fun add_liquidity<X, Y>(
sender: &signer,
amount_x: u64,
amount_y: u64
): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) =
add_liquidity_direct(
coin::withdraw<X>(sender, amount_x),
coin::withdraw<Y>(sender, amount_y)
);
let sender_addr = signer::address_of(sender);
let lp_amount = coin::value(&coin_lp);
assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
check_or_register_coin_store<LPToken<X, Y>>(sender);
coin::deposit(sender_addr, coin_lp);
coin::deposit(sender_addr, coin_left_x);
coin::deposit(sender_addr, coin_left_y);
let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
event::emit_event<AddLiquidityEvent<X, Y>>(
&mut pair_event_holder.add_liquidity,
AddLiquidityEvent<X, Y> {
user: sender_addr,
amount_x: a_x,
amount_y: a_y,
liquidity: lp_amount,
fee_amount: (fee_amount as u64),
}
);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

(a_x, a_y, lp_amount
}
```
### 1.1. Input Parameters Explained
- `sender: &signer`: This represents the account that's adding liquidity. In Move, a `signer` is a
special type that proves ownership of an account.
- `amount_x: u64`: The amount of token X the user wants to add to the pool. `u64` means it's an
unsigned 64-bit integer.
- `amount_y: u64`: The amount of token Y the user wants to add to the pool.
- Returns: `(u64, u64, u64)`: This function returns three values:
- The actual amount of token X used
- The actual amount of token Y used
- The number of LP tokens received
### 1.2. Understanding Coin Operations
The function starts by withdrawing tokens from the sender's account:
```rust
coin::withdraw<X>(sender, amount_x),
coin::withdraw<Y>(sender, amount_y)
```
- These operations move tokens from the user's account to the contract's control.
- The `coin::withdraw` function automatically checks if the user has sufficient balance.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- If the balance is insufficient, the operation will fail, preventing any further execution.
### 1.3. Processing Return Values
After adding liquidity, the function checks if LP tokens were successfully minted:
```rust
let lp_amount = coin::value(&coin_lp);
assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
```
- This verifies that a non-zero amount of LP tokens were minted.
- If no LP tokens were minted (lp_amount = 0), the function will abort with an error.
- This check ensures that users always receive LP tokens when adding liquidity, preventing
potential loss of funds.
### 1.4. Managing Token Stores
Before depositing LP tokens, the function ensures the user can receive them:
```rust
check_or_register_coin_store<LPToken<X, Y>>(sender);
```
Let's look at the helper function implementation:
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public fun check_or_register_coin_store<X>(sender: &signer) {
if (!coin::is_account_registered<X>(signer::address_of(sender))) {
coin::register<X>(sender);
};
}
```
- This function checks if the sender's account is registered to hold the LP token.
- If not registered, it automatically registers the account to receive the token.
- This prevents failures when trying to deposit LP tokens to an unregistered account.
## 2. Deep Dive into Direct Liquidity Addition
The core logic of adding liquidity is handled by the `add_liquidity_direct` function. Let's break it
down:
```rust
fun add_liquidity_direct<X, Y>(
x: coin::Coin<X>,
y: coin::Coin<Y>,
): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>)
acquires TokenPairReserve, TokenPairMetadata {
let amount_x = coin::value(&x);
let amount_y = coin::value(&y);
let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
// Calculate optimal amounts
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
(amount_x, amount_y)
} else {
calculate_optimal_amounts(amount_x, amount_y, reserve_x, reserve_y)
};
assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
let left_x = coin::extract(&mut x, amount_x - a_x);
let left_y = coin::extract(&mut y, amount_y - a_y);
deposit_x<X, Y>(x);
deposit_y<X, Y>(y);
let (lp, fee_amount) = mint<X, Y>();
(a_x, a_y, lp, fee_amount, left_x, left_y)
}
```
### 2.1. Calculating Optimal Amounts
The function handles two scenarios: initial liquidity and subsequent additions.
For initial liquidity (when the pool is empty):

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
if (reserve_x == 0 && reserve_y == 0) {
(amount_x, amount_y)
}
```
- When the pool is empty, all provided tokens are used.
- This sets the initial price ratio for the pool.
For subsequent additions:
```rust
let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
if (amount_y_optimal <= amount_y) {
(amount_x, amount_y_optimal)
} else {
let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
(amount_x_optimal, amount_y)
}
```
The `quote` function calculates the optimal amount to maintain the current price ratio:
```rust
public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
(((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
```
- This calculation ensures the constant product formula: (x + Δx)/(y + Δy) = x/y
- It prevents price manipulation by maintaining the current pool ratio.
- The function uses u128 (128-bit integers) for intermediate calculations to prevent overflow.
### 2.2. Depositing Tokens into the Pool
After calculating optimal amounts, the tokens are deposited into the pool:
```rust
fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
coin::merge(&mut metadata.balance_x, amount);
}
fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
coin::merge(&mut metadata.balance_y, amount);
}
```
- These functions update the pool's balances by merging the new tokens with existing reserves.
- The `borrow_global_mut` function allows modifying global storage.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Using separate functions for X and Y tokens ensures type safety and prevents mixing up token
types.
## 3. Understanding the LP Token Minting Process
After depositing tokens, the contract mints LP tokens for the liquidity provider:
```rust
fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve,
TokenPairMetadata {
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let (balance_x, balance_y) = (coin::value(&metadata.balance_x),
coin::value(&metadata.balance_y));
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
let total_supply = total_lp_supply<X, Y>();
let liquidity = calculate_liquidity_amount(
amount_x,
amount_y,
total_supply,
reserves
);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
update<X, Y>(balance_x, balance_y, reserves);
metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
(lp, fee_amount)
}
```
### 3.1. Initial Liquidity Calculation
For the first liquidity provider, LP tokens are calculated as follows:
```rust
if (total_supply == 0u128) {
let sqrt = math128::sqrt(amount_x * amount_y);
assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
let l = sqrt - MINIMUM_LIQUIDITY;
mint_lp_to<X, Y>(DEFAULT_ADMIN, (MINIMUM_LIQUIDITY as u64), &metadata.mint_cap);
l
}
```
- The geometric mean (square root of the product) of deposits is used to determine initial LP
tokens.
- A small amount (MINIMUM_LIQUIDITY) is locked forever to prevent the pool from being
drained completely.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- This approach helps in setting a fair initial price and prevents exploitation by the first liquidity
provider.
### 3.2. Subsequent Liquidity Calculation
For subsequent liquidity additions, LP tokens are calculated proportionally:
```rust
let liquidity = math128::min(
amount_x * total_supply / (reserves.reserve_x as u128),
amount_y * total_supply / (reserves.reserve_y as u128)
);
assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
```
- This calculation ensures fair distribution of LP tokens based on the proportion of liquidity
added.
- Using the minimum of the two ratios prevents dilution and maintains fairness.
- The assert statement ensures that some LP tokens are always minted, preventing zero-value
operations.
## 4. Event Emission for Transparency
The contract emits an event after successfully adding liquidity:
```rust
struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

user: address,
amount_x: u64,
amount_y: u64,
liquidity: u64,
fee_amount: u64
}
```
- This event records all relevant details of the liquidity addition.
- It includes the user's address, amounts of both tokens used, LP tokens received, and any fees
paid.
- Emitting events allows for off-chain tracking and analysis of pool activities.
## 5. Crucial Safety Considerations
1. **Slippage Protection:**
- The contract calculates optimal amounts to maintain the asset ratio.
- Any unused tokens are returned to the user, preventing unexpected losses.
2. **Minimum Requirements:**
- The contract enforces a non-zero liquidity check to prevent dust amounts.
- A minimum LP token amount is required to prevent exploitation.
3. **State Updates:**
- All operations are performed atomically to ensure consistency.
- The constant product (K value) is maintained throughout the process.
4. **Error Handling:**The contract uses clear error codes for different failure scenarios:
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 0x004;
const ERROR_INSUFFICIENT_AMOUNT: u64 = 0x006;
const ERROR_INVALID_AMOUNT: u64 = 0x008;
```
- These error codes help in identifying and debugging issues quickly.
- Each error corresponds to a specific failure case, improving error handling and user
feedback.
This detailed breakdown of the `add_liquidity` function and its components provides a
comprehensive understanding of how liquidity is added to a DEX. Next, we'll explore the
`remove_liquidity` function to complete our understanding of liquidity management in a DEX
# Removing Liquidity
### Key points:
- Allows Liquidity Providers (LPs) to withdraw tokens from the pool
- Involves burning LP tokens to receive proportional amounts of underlying tokens
- Requires careful calculations to ensure fair distribution of assets
- Includes processing of accrued fees before token extraction
- Updates pool reserves and k-value after removal
- Implements safety checks to prevent errors and maintain pool integrity
- Uses a public interface for user interaction and internal functions for core logic
- Crucial for maintaining flexibility and attractiveness of liquidity provision in DEXs
## Introduction

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Liquidity removal is a fundamental operation in a DEX that allows Liquidity Providers (LPs) to
withdraw their tokens from the pool. When an LP decides to exit their position, they need to burn
their LP tokens and receive a proportional amount of both token types from the pool. This
process is crucial for maintaining the flexibility and attractiveness of providing liquidity in a DEX.
## 1. Public Interface: The Entry Point
Let's break down the public function that initiates the liquidity removal process:
```rust
/// Remove liquidity from a pool
/// Returns (amount_x_received, amount_y_received)
/// Requirements:
/// - Must have sufficient LP tokens to burn
/// - Must receive minimum amounts of tokens
public fun remove_liquidity<X, Y>(
sender: &signer,
liquidity: u64,
): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
let amount_x = coin::value(&coins_x);
let amount_y = coin::value(&coins_y);
check_or_register_coin_store<X>(sender);
check_or_register_coin_store<Y>(sender);
let sender_addr = signer::address_of(sender);
coin::deposit<X>(sender_addr, coins_x);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

coin::deposit<Y>(sender_addr, coins_y);
// event
let pair_event_holder = borrow_global_mut<PairEventHolder<X, Y>>(DEFAULT_ADMIN);
event::emit_event<RemoveLiquidityEvent<X, Y>>(
&mut pair_event_holder.remove_liquidity,
RemoveLiquidityEvent<X, Y> {
user: sender_addr,
amount_x,
amount_y,
liquidity,
fee_amount: (fee_amount as u64)
}
);
(amount_x, amount_y)
}
```
This function is the main entry point for liquidity removal. Let's examine its components:
### Function Parameters:
- **sender: &signer** - This is a reference to the user's account that's initiating the liquidity
removal. It's used for several important operations:
- Verifying that the user owns the LP tokens they're trying to burn
- Withdrawing the LP tokens from the user's account
- Depositing the underlying tokens back into the user's account after the removal process

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- **liquidity: u64** - This parameter represents the amount of LP tokens the user wants to burn.
It's important to note that:
- The amount must be greater than 0 to perform a valid operation
- It cannot exceed the user's current LP token balance
- This value determines how many underlying tokens the user will receive back
### Return Values:
The function returns a tuple `(u64, u64)`, which represents:
- `amount_x`: The amount of token X the user receives
- `amount_y`: The amount of token Y the user receives
These amounts are calculated proportionally based on the ratio of LP tokens burned to the total
supply of LP tokens.
### Key Steps in the Implementation:
1. Withdrawing LP Tokens:
```rust
let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
```
This line withdraws the specified amount of LP tokens from the user's account. It uses generics
(`LPToken<X, Y>`) to ensure it's withdrawing the correct LP token for the specific token pair. If
the user doesn't have enough LP tokens, this operation will fail automatically.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

1. Core Liquidity Removal:
```rust
let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
```
This function call performs the actual liquidity removal. It takes the LP tokens and returns the
underlying tokens (X and Y) along with any accrued fees. This step ensures that the entire
operation is atomic, meaning it either completes fully or not at all.
1. Safety Checks:
```rust
check_or_register_coin_store<X>(sender);
check_or_register_coin_store<Y>(sender);
```
These lines perform crucial safety checks:
- They ensure that the user's account is set up to receive both token types
- If the user doesn't have a "coin store" for either token, it's automatically created
- This prevents potential issues where the removal succeeds but the tokens can't be deposited
1. Depositing Tokens and Emitting Events:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

The function then deposits the received tokens into the user's account and emits an event to
record the liquidity removal operation. This ensures transparency and allows for easy tracking of
DEX activities.
## 2. Direct Removal Implementation
```rust
/// Remove liquidity to token types.
fun remove_liquidity_direct<X, Y>(
liquidity: coin::Coin<LPToken<X, Y>>,
): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
burn<X, Y>(liquidity)
}
```
### Purpose:
This function serves as an important abstraction layer in our liquidity removal process. Let's
break it down for beginners:
- Separates concerns:
- Public interface (remove_liquidity): This is what users interact with. It handles user-specific
operations like withdrawing LP tokens from their account.
- Direct function (remove_liquidity_direct): This manages the core logic of liquidity removal.
It's an intermediate step that helps organize our code.
- Burn function: This handles the detailed implementation of actually burning LP tokens and
calculating token amounts to return.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

## 3. Core Burn Implementation
```rust
/// Burns LP tokens to withdraw liquidity
/// Returns withdrawn tokens proportional to LP tokens burned
/// Requirements:
/// - Must receive minimum amounts of both tokens
fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64)
acquires TokenPairMetadata, TokenPairReserve {
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let (balance_x, balance_y) = (coin::value(&metadata.balance_x),
coin::value(&metadata.balance_y));
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
let liquidity = coin::value(&lp_tokens);
let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
// Need to add fee amount which have not been minted.
let total_lp_supply = total_lp_supply<X, Y>();
let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as u64);
assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
let w_x = extract_x((amount_x as u64), metadata);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let w_y = extract_y((amount_y as u64), metadata);
update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
(w_x, w_y, fee_amount)
}
```
### Initial Setup:
Let's break down the initial setup of our liquidity removal function. This part is crucial as it sets
the stage for all subsequent operations.
```rust
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let (balance_x, balance_y) = (
coin::value(&metadata.balance_x),
coin::value(&metadata.balance_y)
);
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
let liquidity = coin::value(&lp_tokens);
```
### Metadata Access:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

The first line retrieves the metadata for our token pair. This is a critical step because the
metadata contains essential information about our liquidity pool.
- `borrow_global_mut`: This function is used to get a mutable reference to the pool metadata.
'Mutable' means we can change this data if needed.
- The metadata is stored at the `DEFAULT_ADMIN` address. This is a common pattern in Move
to have a central storage location for important data.
- The metadata contains crucial information like the current balances of both tokens, the total
supply of LP tokens, and other pool-specific data.
### Balance Retrieval:
Next, we retrieve the current balances of both tokens in the pool. This is necessary to calculate
how much of each token the user should receive when removing liquidity.
- We use `coin::value` to safely read the balance of each token in the pool.
- This function returns the numerical value of the coin, which we can use in our calculations.
- Getting accurate balances is crucial for maintaining the correct proportions when removing
liquidity.
### Fee Processing:
Before we calculate the amounts of tokens to return to the user, we need to process any
accrued fees. This is an important step in maintaining the economic model of the DEX.
```
let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
This line calls a function to calculate and mint the fees. Let's break down how this works:
### Fee Calculation Formula:
```
let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
let root_k_last = math128::sqrt(metadata.k_last);
if root_k > root_k_last {
let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
let denominator = root_k_last * 17u128 + root_k * 8u128;
let liquidity = numerator / denominator;
fee = liquidity as u64;
};
}
```
This might look complicated, but let's break it down step by step:
### Understanding the Fee Calculation:
1. Calculating root_k:
- We calculate the square root of the product of current reserves (reserve_x * reserve_y)
- This represents the current "size" of the pool
2. Retrieving root_k_last:
- This is the square root of the last recorded k value
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- It represents the pool size from the last operation
3. Comparing root_k and root_k_last:
- If root_k > root_k_last, it means the pool has grown
- This growth is what we use to calculate fees
4. Fee calculation:
- We use a complex formula to ensure fair fee distribution
- The numerator considers total supply and pool growth
- The denominator includes factors to balance the fee
- The result is a fair amount of new LP tokens to mint as fees
This fee calculation ensures that the protocol can sustain itself while providing fair returns to
liquidity providers.
### Amount Calculations:
```
let total_lp_supply = total_lp_supply<X, Y>();
let amount_x = ((balance_x as u128) * (liquidity as u128) /
(total_lp_supply as u128) as u64);
let amount_y = ((balance_y as u128) * (liquidity as u128) /
(total_lp_supply as u128) as u64);
```
### Understanding the Amount Calculations:
Now that we've processed fees, we need to calculate how many tokens the user will receive
when removing liquidity. The formula is straightforward but crucial:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
amount_token = (current_balance * lp_amount_to_burn) / total_lp_supply
```
Let's break this down:
1. Proportion calculation:
- We calculate based on the user's share of LP tokens
- This ensures fairness - you get back proportional to what you put in
- It automatically includes any fees or gains the pool has accumulated
2. Precision handling:
- We cast to u128 (a larger integer type) for the calculation
- This prevents potential overflow errors with large numbers
- It also maintains accuracy in the division operation
Here's a simple example to illustrate:
```
If:
- Pool has 1000 X, 2000 Y
- Total LP supply is 1000
- User burns 100 LP tokens (10%)
Then:
- amount_x = 1000 * 100 / 1000 = 100 X
- amount_y = 2000 * 100 / 1000 = 200 Y
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

In this example, the user would receive 100 X tokens and 200 Y tokens for their 10% share of
the pool.
### Validation and Execution:
```
assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
```
After calculating the amounts, we perform some crucial steps:
1. Safety Checks:
- We ensure that both amount_x and amount_y are greater than zero
- This prevents "dust" withdrawals that could potentially harm the pool
- If either amount is zero, we throw an error
2. LP Token Burning:
- We use the burn capability to destroy the LP tokens
- This reduces the total supply of LP tokens
- It's an irreversible operation, ensuring the integrity of the pool
### Token Extraction:
```
let w_x = extract_x((amount_x as u64), metadata);
let w_y = extract_y((amount_y as u64), metadata);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
Now we actually extract the tokens to return to the user:
1. Safety check:
```
assert!(coin::value&lt;X&gt;(&metadata.balance_x) > amount,
ERROR_INSUFFICIENT_AMOUNT);
```
- This verifies that the pool has enough tokens to fulfill the withdrawal
- It prevents potential underflow errors
- It's a double-check to ensure our previous calculations were correct
2. Actual extraction:
```
coin::extract(&mut metadata.balance_x, amount)
```
- This removes the calculated amount of tokens from the pool
- It creates a new Coin object with these tokens
- This Coin object will be returned to the user
### State Updates:
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
```
Finally, we need to update the state of our pool:
1. Reserve updates:
- We update the current reserves with the new balances
- This typically includes recording a timestamp for the update
- It's crucial for maintaining an accurate state of the pool
2. K value update:
- We calculate the new k value (product of reserves)
- This is stored for the next operation
- It's used in future fee calculations to detect pool growth
By following these steps, we ensure that liquidity removal is handled accurately, fairly, and
safely in our DEX. Each step plays a crucial role in maintaining the integrity and efficiency of the
system.
# Swapping Token
### Key Points:
This document provides a comprehensive explanation of token swapping in decentralized
exchanges, focusing on the implementation of the swap_exact_x_to_y function. Key points
covered include:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- The public interface and parameters of the swap function
- Step-by-step breakdown of the swap implementation
- Detailed explanation of the AMM (Automated Market Maker) formula
- Core swap logic including liquidity checks and token handling
- K value protection and price impact considerations
- Final verification to ensure the constant product formula is maintained
This guide is essential for developers looking to understand or implement token swapping
mechanisms in DeFi applications.
## Introduction
Swapping is a fundamental feature of decentralized exchanges (DEXs), allowing users to trade
one token for another. In this tutorial, we'll dive deep into the implementation of a common swap
type: swap_exact_x_to_y. This function enables users to exchange a specific amount of token X
for token Y, with the output amount determined by an Automated Market Maker (AMM) formula.
## 1. Public Interface: swap_exact_x_to_y
```
public fun swap_exact_x_to_y<X, Y>(
sender: &signer,
amount_in: u64,
to: address
): u64 acquires TokenPairReserve, TokenPairMetadata
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Let's break down this function signature to understand what each part means:
### Function Name and Generics
- **swap_exact_x_to_y**: This name clearly indicates the function's purpose - swapping an
exact amount of token X for token Y.
- **<X, Y>**: These are generic type parameters. They allow the function to work with any two
token types, making it flexible and reusable.
### Parameter Analysis:
1. **sender: &signer**
- This is a reference to the signer object, representing the user initiating the swap.
- The signer is crucial for several reasons:
- It allows the function to withdraw tokens from the user's account.
- It's used to verify that the user has the necessary permissions.
- It enables the function to register coin stores if they don't exist yet.
2. **amount_in: u64**
- This parameter specifies the exact amount of token X the user wants to swap.
- It must be greater than 0 to perform a valid swap.
- This amount is used in calculations to determine how much of token Y the user will receive.
- The size of amount_in affects the price impact of the swap on the liquidity pool.
3. **to: address**
- This is the address that will receive the output token Y.
- Interestingly, this can be different from the sender's address.
- This flexibility allows for direct transfers to other addresses.
- It's particularly useful when interacting with more complex smart contracts or routers.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### Return Value
The function returns a u64, which represents the amount of token Y that was output from the
swap. This allows the caller to know exactly how many tokens were received.
### Acquire Clause
The **acquires TokenPairReserve, TokenPairMetadata** clause indicates that this function will
access global storage to read or modify these resources. This is important for managing the
liquidity pool and swap calculations.
### Implementation Details:
Now, let's walk through the implementation step-by-step:
### Step 1: Withdraw Tokens
```
let coins = coin::withdraw<X>(sender, amount_in);
```
This line does several important things:
- It calls the withdraw function from the coin module, specifying token X as the type.
- It takes tokens directly from the sender's account.
- The exact amount_in is withdrawn.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- If the sender doesn't have enough balance, this operation will fail.
- The result is a new Coin object containing the withdrawn tokens.
### Step 2: Execute Swap
```
let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
```
This line is where the actual swap logic happens:
- It calls an internal function swap_exact_x_to_y_direct.
- The coins object (containing token X) is passed to this function.
- The function returns two Coin objects: coins_x_out and coins_y_out.
- coins_x_out will typically be empty (zero value) in this case.
- coins_y_out contains the tokens that resulted from the swap.
### Step 3: Prepare Deposit
```
let amount_out = coin::value(&coins_y_out);
check_or_register_coin_store<Y>(sender);
```
These lines prepare for the final transfer:
- The value of coins_y_out is extracted. This is how many tokens of Y were swapped for.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- The check_or_register_coin_store function ensures that the recipient can receive token Y.
- If the recipient doesn't have a coin store for token Y, one is automatically created.
### Step 4: Complete Transfer
```
coin::destroy_zero(coins_x_out);
coin::deposit(to, coins_y_out);
```
The final steps of the swap:
- coins_x_out is destroyed. This should be empty, as all X tokens were swapped.
- The resulting Y tokens (coins_y_out) are deposited to the specified 'to' address.
- The function implicitly returns amount_out, telling the caller how many Y tokens were received.
## 2. Direct Swap Implementation
Now, let's dive deeper into the core of our swap function: `swap_exact_x_to_y_direct`. This
function is where the magic happens - it's responsible for executing the actual token swap.
```
public fun swap_exact_x_to_y_direct<X, Y>(
coins_in: coin::Coin<X>
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Let's break down this function signature:
- It's a public function, meaning it can be called from outside the [module.It](http://module.It)
uses generic typesand, allowing it to work with any pair of [tokens.It](http://tokens.It) takes a
Coin as input (the tokens we're swapping).It returns two Coin objects: Coin(any leftover input)
and Coin(the swapped tokens).
- The 'acquires' keyword indicates it will access global storage for TokenPairReserve and
TokenPairMetadata.
### Core Logic:
Now, let's walk through the function step-by-step:
### Step 1: Get Input Amount
```
let amount_in = coin::value<X>(&coins_in);
```
This line retrieves the exact amount of tokens X that the user is swapping. It's crucial because:
- It tells us how many tokens we're working with.
- We need this value for our swap calculations later.
- It's a read-only operation, so it doesn't modify the coins_in object.
### Step 2: Deposit to Pool

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
deposit_x<X, Y>(coins_in);
```
This step is where we actually add the input tokens to the liquidity pool:
- The deposit_x function (not shown here) handles the mechanics of adding tokens to the pool.
- After this step, the pool's balance of token X has increased by amount_in.
- This is a critical step because it's where the user's tokens are actually transferred to the pool.
### Step 3: Get Reserves
```
let (rin, rout, _) = token_reserves<X, Y>();
```
Here, we're fetching the current state of the liquidity pool:
- rin represents the reserve of the input token (X in this case).
- rout represents the reserve of the output token (Y in this case).
- The underscore (_) suggests there's a third value returned that we're not using here.
- These reserve values are crucial for calculating the swap output.
### Step 4: Calculate Output
```
let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
This is where we determine how many Y tokens the user will receive:
- We use a utility function get_amount_out to perform the calculation.
- It takes into account the input amount and the current reserves of both tokens.
- The calculation ensures that the pool maintains its balance according to the AMM formula.
### AMM Formula Details:
Let's take a closer look at the get_amount_out function:
```
// In swap_utils
public fun get_amount_out(
amount_in: u64,
reserve_in: u64,
reserve_out: u64,
): u64 {
assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
let amount_in_with_fee = (amount_in as u128) * 997u128;
let numerator = amount_in_with_fee * (reserve_out as u128);
let denominator = (reserve_in as u128) * 1000u128 + amount_in_with_fee;
((numerator / denominator) as u64)
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
This function is the heart of our AMM. Let's break it down:
- First, we have two assert statements:
- They ensure that we have a valid input amount and that there's sufficient liquidity in the
pool.
- If these conditions aren't met, the function will abort with an error.
- Next, we calculate the input amount with the fee applied:
- We multiply the input by 997, which is equivalent to applying a 0.3% fee (3/1000).
- This fee goes to the liquidity providers as an incentive.
- The core of the calculation is based on the constant product formula:
- This formula ensures that the product of the two token reserves remains constant before
and after the swap.
- It's designed to provide a fair price and maintain pool stability.
- Finally, we return the calculated output amount:
- We cast the result back to u64, which may involve some rounding.
- This is the amount of Y tokens the user will receive.
Let's look at a concrete example to better understand this calculation:
```
Given:
- amount_in = 100
- reserve_in = 1000
- reserve_out = 2000

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Calculation:
1. amount_in_with_fee = 100 * 997 = 99,700
2. numerator = 99,700 * 2000 = 199,400,000
3. denominator = 1000 * 1000 + 99,700 = 1,099,700
4. amount_out = 199,400,000 / 1,099,700 ≈ 181
```
In this example, if a user wants to swap 100 of token X, they would receive approximately 181
of token Y.
### Execute Swap:
After calculating the output amount, we execute the actual swap:
```
let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
```
This line calls an internal swap function:
- We pass 0 for the X output because we're swapping all of X for Y.
- We pass our calculated amount_out for the Y output.
- The function returns two Coin objects, representing the results of the swap.
Finally, we have a safety check:
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

assert!(coin::value<X>(&coins_x_out) == 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
```
This assertion ensures that:
- We've swapped all of the input X tokens.
- There are no leftover X tokens from the swap.
- If this condition isn't met, it indicates an error in our calculations or swap execution.
## 3. Core Swap Implementation
Now, let's dive deep into the core swap implementation. This is where the actual token
exchange happens, and it's crucial to understand each step for anyone new to DeFi
development.
```
fun swap&lt;X, Y&gt;(
amount_x_out: u64,
amount_y_out: u64
): (coin::Coin&lt;X&gt;, coin::Coin&lt;Y&gt;) acquires TokenPairReserve, TokenPairMetadata
```
This function is the heart of our swap mechanism. Let's break it down:
- It's generic over two types, X and Y, representing our token pair.
- It takes two parameters: amount_x_out and amount_y_out, which are the amounts of tokens X
and Y to be swapped out.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- It returns two Coin objects, representing the swapped tokens.
- The 'acquires' keyword indicates it will access global storage for TokenPairReserve and
TokenPairMetadata.
### Initial Validation
```
assert!(amount_x_out > 0 || amount_y_out > 0, ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
```
This line is our first safety check:
- It ensures that we're actually swapping something. At least one of the output amounts must be
greater than zero.
- If both outputs are zero, it would mean we're not swapping anything, which doesn't make
sense in a swap operation.
- The assert! macro will cause the transaction to revert if this condition isn't met, protecting
against empty or invalid swaps.
```
let reserves = borrow_global_mut<<TokenPairReserve<X, Y>>(DEFAULT_ADMIN);
assert!(
amount_x_out < reserves.reserve_x &&
amount_y_out < reserves.reserve_y,
ERROR_INSUFFICIENT_LIQUIDITY
);
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

This block performs a crucial liquidity check:
- We first borrow the global TokenPairReserve resource, which holds the current reserves of
both tokens.
- Then, we check if the requested output amounts are less than the available reserves for each
token.
- This prevents a swap from draining the entire liquidity pool, which could destabilize the market.
- If there's not enough liquidity, the transaction will revert with an
`ERROR_INSUFFICIENT_LIQUIDITY` error.
### Token Handling
```
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(DEFAULT_ADMIN);
let coins_x_out = coin::zero<X>();
let coins_y_out = coin::zero<Y>();
if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
```
This section handles the actual token extraction:
- We start by borrowing the TokenPairMetadata, which contains additional information about the
token pair.
- We initialize two empty Coin objects, one for each token type.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Then, we check if we need to extract any of token X or Y (remember, one of them might be
zero in a single-sided swap).
- If we need to extract tokens, we use the extract_x or extract_y functions (not shown here) to
take tokens from the pool.
- The extracted tokens are then merged into our initially empty Coin objects.
### K Value Protection
```
let (balance_x, balance_y) = token_balances<X, Y>();
let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
balance_x - (reserves.reserve_x - amount_x_out)
} else { 0 };
let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
balance_y - (reserves.reserve_y - amount_y_out)
} else { 0 };
```
This part is crucial for maintaining the constant product formula (x * y = k):
- We first get the current balances of both tokens in the pool.
- Then, we calculate the actual amounts of tokens that were input into the swap.
- This calculation accounts for the possibility of a bidirectional swap, where both tokens might be
both input and output.
- If the current balance is higher than what it should be after output (reserves minus output), we
know some tokens were input.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- This step is essential for accurately updating the pool state after the swap.
### Price Impact Check
```
let prec = (PRECISION as u128);
let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;
```
This section prepares for the final K value check:
- We use a precision factor (PRECISION) to avoid dealing with fractional numbers.
- We calculate adjusted balances by subtracting a portion of the input amounts. This accounts
for the swap fee (0.25% in this case, as 25/10000 = 0.0025).
- We also adjust the reserves using the same precision factor.
- These adjustments allow us to perform accurate comparisons in the next step.
### Final Verification
```
let compare_result = if (balance_x_adjusted > 0 && reserve_x_adjusted > 0 &&
MAX_U128 / balance_x_adjusted > balance_y_adjusted &&
MAX_U128 / reserve_x_adjusted > reserve_y_adjusted) {
balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

} else {
let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
p >= k
};
assert!(compare_result, ERROR_K);
```
This final check ensures that the constant product formula is maintained:
- We first check if we can safely multiply the adjusted balances without overflow.
- If it's safe, we directly compare the product of adjusted balances with the product of adjusted
reserves.
- If there's a risk of overflow, we use larger u256 integers to perform the comparison.
- The key here is that the new product (p) should be greater than or equal to the old product (k).
- If this condition isn't met, it means the swap would adversely affect the pool's balance, and the
transaction is reverted.
Next, we'll explore the implementation of other swap types: swap_x_to_exact_y,
swap_exact_y_to_x, and swap_y_to_exact_x.
# DEX Full Code
```rust
module movement::swap {
use std::signer;
use std::option;
use std::string;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

use aptos_std::type_info;
use aptos_std::event;
use aptos_std::math128;
use aptos_framework::coin;
use aptos_framework::timestamp;
use aptos_framework::account;
use aptos_framework::resource_account;
use movement::swap_utils;
const ZERO_ACCOUNT: address = @0x0;
const DEFAULT_ADMIN: address = @movement;
const RESOURCE_ACCOUNT: address = @movement;
const DEV: address = @dev;
const MINIMUM_LIQUIDITY: u128 = 1000;
const MAX_COIN_NAME_LENGTH: u64 = 32;
// List of errors
const ERROR_ONLY_ADMIN: u64 = 0;
const ERROR_ALREADY_INITIALIZED: u64 = 1;
const ERROR_NOT_CREATOR: u64 = 2;
const ERROR_INSUFFICIENT_LIQUIDITY_MINTED: u64 = 4;
const ERROR_INSUFFICIENT_AMOUNT: u64 = 6;
const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 7;
const ERROR_INVALID_AMOUNT: u64 = 8;
const ERROR_TOKENS_NOT_SORTED: u64 = 9;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

const ERROR_INSUFFICIENT_LIQUIDITY_BURNED: u64 = 10;
const ERROR_INSUFFICIENT_OUTPUT_AMOUNT: u64 = 13;
const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 14;
const ERROR_K: u64 = 15;
const ERROR_X_NOT_REGISTERED: u64 = 16;
const ERROR_Y_NOT_REGISTERED: u64 = 16;
const ERROR_NOT_ADMIN: u64 = 17;
const ERROR_NOT_FEE_TO: u64 = 18;
const ERROR_NOT_EQUAL_EXACT_AMOUNT: u64 = 19;
const ERROR_NOT_RESOURCE_ACCOUNT: u64 = 20;
const ERROR_NO_FEE_WITHDRAW: u64 = 21;
const PRECISION: u64 = 10000;
/// Max `u128` value.
const MAX_U128: u128 = 340282366920938463463374607431768211455;
/// The LP Token type
struct LPToken<phantom X, phantom Y> has key {}
/// Stores the metadata required for the token pairs
struct TokenPairMetadata<phantom X, phantom Y> has key {
/// The admin of the token pair
creator: address,
/// fee amount , record fee amount which is not withdrawed
fee_amount: coin::Coin<LPToken<X, Y>>,
/// It's reserve_x * reserve_y, as of immediately after the most recent liquidity event
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

k_last: u128,
/// T0 token balance
balance_x: coin::Coin<X>,
/// T1 token balance
balance_y: coin::Coin<Y>,
/// Mint capacity of LP Token
mint_cap: coin::MintCapability<LPToken<X, Y>>,
/// Burn capacity of LP Token
burn_cap: coin::BurnCapability<LPToken<X, Y>>,
/// Freeze capacity of LP Token
freeze_cap: coin::FreezeCapability<LPToken<X, Y>>,
}
/// Stores the reservation info required for the token pairs
struct TokenPairReserve<phantom X, phantom Y> has key {
reserve_x: u64,
reserve_y: u64,
block_timestamp_last: u64
}
struct SwapInfo has key {
signer_cap: account::SignerCapability,
fee_to: address,
admin: address,
pair_created: event::EventHandle<PairCreatedEvent>
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

struct PairCreatedEvent has drop, store {
user: address,
token_x: string::String,
token_y: string::String
}
struct PairEventHolder<phantom X, phantom Y> has key {
add_liquidity: event::EventHandle<AddLiquidityEvent<X, Y>>,
remove_liquidity: event::EventHandle<RemoveLiquidityEvent<X, Y>>,
swap: event::EventHandle<SwapEvent<X, Y>>
}
struct AddLiquidityEvent<phantom X, phantom Y> has drop, store {
user: address,
amount_x: u64,
amount_y: u64,
liquidity: u64,
fee_amount: u64
}
struct RemoveLiquidityEvent<phantom X, phantom Y> has drop, store {
user: address,
liquidity: u64,
amount_x: u64,
amount_y: u64,
fee_amount: u64
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

struct SwapEvent<phantom X, phantom Y> has drop, store {
user: address,
amount_x_in: u64,
amount_y_in: u64,
amount_x_out: u64,
amount_y_out: u64
}
/*
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Please use swap_util::sort_token_type<X,Y>()
before using any function
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*/
fun init_module(sender: &signer) {
let signer_cap = resource_account::retrieve_resource_account_cap(sender, DEV);
let resource_signer = account::create_signer_with_capability(&signer_cap);
move_to(&resource_signer, SwapInfo {
signer_cap,
fee_to: ZERO_ACCOUNT,
admin: DEFAULT_ADMIN,
pair_created: account::new_event_handle<PairCreatedEvent>(&resource_signer),
});
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
/// Create the specified coin pair
public(friend) fun create_pair<X, Y>(
sender: &signer,
) acquires SwapInfo {
assert!(!is_pair_created<X, Y>(), ERROR_ALREADY_INITIALIZED);
let sender_addr = signer::address_of(sender);
let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
let resource_signer = account::create_signer_with_capability(&swap_info.signer_cap);
let lp_name: string::String = string::utf8(b"movement-");
let name_x = coin::symbol<X>();
let name_y = coin::symbol<Y>();
string::append(&mut lp_name, name_x);
string::append_utf8(&mut lp_name, b"-");
string::append(&mut lp_name, name_y);
string::append_utf8(&mut lp_name, b"-LP");
if (string::length(&lp_name) > MAX_COIN_NAME_LENGTH) {
lp_name = string::utf8(b"movement LPs");
};
// now we init the LP token
let (burn_cap, freeze_cap, mint_cap) = coin::initialize<LPToken<X, Y>>(
&resource_signer,
lp_name,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

string::utf8(b"Cake-LP"),
8,
true
);
move_to<TokenPairReserve<X, Y>>(
&resource_signer,
TokenPairReserve {
reserve_x: 0,
reserve_y: 0,
block_timestamp_last: 0
}
);
move_to<TokenPairMetadata<X, Y>>(
&resource_signer,
TokenPairMetadata {
creator: sender_addr,
fee_amount: coin::zero<LPToken<X, Y>>(),
k_last: 0,
balance_x: coin::zero<X>(),
balance_y: coin::zero<Y>(),
mint_cap,
burn_cap,
freeze_cap,
}
);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

move_to<PairEventHolder<X, Y>>(
&resource_signer,
PairEventHolder {
add_liquidity: account::new_event_handle<AddLiquidityEvent<X,
Y>>(&resource_signer),
remove_liquidity: account::new_event_handle<RemoveLiquidityEvent<X,
Y>>(&resource_signer),
swap: account::new_event_handle<SwapEvent<X, Y>>(&resource_signer)
}
);
// pair created event
let token_x = type_info::type_name<X>();
let token_y = type_info::type_name<Y>();
event::emit_event<PairCreatedEvent>(
&mut swap_info.pair_created,
PairCreatedEvent {
user: sender_addr,
token_x,
token_y
}
);
// create LP CoinStore , which is needed as a lock for minimum_liquidity
register_lp<X, Y>(&resource_signer);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
public fun register_lp<X, Y>(sender: &signer) {
coin::register<LPToken<X, Y>>(sender);
}
public fun is_pair_created<X, Y>(): bool {
exists<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT)
}
/// Obtain the LP token balance of `addr`.
/// This method can only be used to check other users' balance.
public fun lp_balance<X, Y>(addr: address): u64 {
coin::balance<LPToken<X, Y>>(addr)
}
/// Get the total supply of LP Tokens
public fun total_lp_supply<X, Y>(): u128 {
option::get_with_default(
&coin::supply<LPToken<X, Y>>(),
0u128
)
}
/// Get the current reserves of T0 and T1 with the latest updated timestamp
public fun token_reserves<X, Y>(): (u64, u64, u64) acquires TokenPairReserve {
let reserve = borrow_global<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

(
reserve.reserve_x,
reserve.reserve_y,
reserve.block_timestamp_last
)
}
/// The amount of balance currently in pools of the liquidity pair
public fun token_balances<X, Y>(): (u64, u64) acquires TokenPairMetadata {
let meta =
borrow_global<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
(
coin::value(&meta.balance_x),
coin::value(&meta.balance_y)
)
}
public fun check_or_register_coin_store<X>(sender: &signer) {
if (!coin::is_account_registered<X>(signer::address_of(sender))) {
coin::register<X>(sender);
};
}
public fun admin(): address acquires SwapInfo {
let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
swap_info.admin
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public fun fee_to(): address acquires SwapInfo {
let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
swap_info.fee_to
}
// ===================== Update functions ======================
/// Add more liquidity to token types. This method explicitly assumes the
/// min of both tokens are 0.
public(friend) fun add_liquidity<X, Y>(
sender: &signer,
amount_x: u64,
amount_y: u64
): (u64, u64, u64) acquires TokenPairReserve, TokenPairMetadata, PairEventHolder {
let (a_x, a_y, coin_lp, fee_amount, coin_left_x, coin_left_y) =
add_liquidity_direct(coin::withdraw<X>(sender, amount_x), coin::withdraw<Y>(sender,
amount_y));
let sender_addr = signer::address_of(sender);
let lp_amount = coin::value(&coin_lp);
assert!(lp_amount > 0, ERROR_INSUFFICIENT_LIQUIDITY);
check_or_register_coin_store<LPToken<X, Y>>(sender);
coin::deposit(sender_addr, coin_lp);
coin::deposit(sender_addr, coin_left_x);
coin::deposit(sender_addr, coin_left_y);
let pair_event_holder = borrow_global_mut<PairEventHolder<X,
Y>>(RESOURCE_ACCOUNT);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

event::emit_event<AddLiquidityEvent<X, Y>>(
&mut pair_event_holder.add_liquidity,
AddLiquidityEvent<X, Y> {
user: sender_addr,
amount_x: a_x,
amount_y: a_y,
liquidity: lp_amount,
fee_amount: (fee_amount as u64),
}
);
(a_x, a_y, lp_amount)
}
public(friend) fun add_swap_event<X, Y>(
sender: &signer,
amount_x_in: u64,
amount_y_in: u64,
amount_x_out: u64,
amount_y_out: u64
) acquires PairEventHolder {
let sender_addr = signer::address_of(sender);
let pair_event_holder = borrow_global_mut<PairEventHolder<X,
Y>>(RESOURCE_ACCOUNT);
event::emit_event<SwapEvent<X, Y>>(
&mut pair_event_holder.swap,
SwapEvent<X, Y> {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

user: sender_addr,
amount_x_in,
amount_y_in,
amount_x_out,
amount_y_out
}
);
}
public(friend) fun add_swap_event_with_address<X, Y>(
sender_addr: address,
amount_x_in: u64,
amount_y_in: u64,
amount_x_out: u64,
amount_y_out: u64
) acquires PairEventHolder {
let pair_event_holder = borrow_global_mut<PairEventHolder<X,
Y>>(RESOURCE_ACCOUNT);
event::emit_event<SwapEvent<X, Y>>(
&mut pair_event_holder.swap,
SwapEvent<X, Y> {
user: sender_addr,
amount_x_in,
amount_y_in,
amount_x_out,
amount_y_out
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

);
}
/// Add more liquidity to token types. This method explicitly assumes the
/// min of both tokens are 0.
fun add_liquidity_direct<X, Y>(
x: coin::Coin<X>,
y: coin::Coin<Y>,
): (u64, u64, coin::Coin<LPToken<X, Y>>, u64, coin::Coin<X>, coin::Coin<Y>) acquires
TokenPairReserve, TokenPairMetadata {
let amount_x = coin::value(&x);
let amount_y = coin::value(&y);
let (reserve_x, reserve_y, _) = token_reserves<X, Y>();
let (a_x, a_y) = if (reserve_x == 0 && reserve_y == 0) {
(amount_x, amount_y)
} else {
let amount_y_optimal = swap_utils::quote(amount_x, reserve_x, reserve_y);
if (amount_y_optimal <= amount_y) {
(amount_x, amount_y_optimal)
} else {
let amount_x_optimal = swap_utils::quote(amount_y, reserve_y, reserve_x);
assert!(amount_x_optimal <= amount_x, ERROR_INVALID_AMOUNT);
(amount_x_optimal, amount_y)
}
};
assert!(a_x <= amount_x, ERROR_INSUFFICIENT_AMOUNT);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

assert!(a_y <= amount_y, ERROR_INSUFFICIENT_AMOUNT);
let left_x = coin::extract(&mut x, amount_x - a_x);
let left_y = coin::extract(&mut y, amount_y - a_y);
deposit_x<X, Y>(x);
deposit_y<X, Y>(y);
let (lp, fee_amount) = mint<X, Y>();
(a_x, a_y, lp, fee_amount, left_x, left_y)
}
/// Remove liquidity to token types.
public(friend) fun remove_liquidity<X, Y>(
sender: &signer,
liquidity: u64,
): (u64, u64) acquires TokenPairMetadata, TokenPairReserve, PairEventHolder {
let coins = coin::withdraw<LPToken<X, Y>>(sender, liquidity);
let (coins_x, coins_y, fee_amount) = remove_liquidity_direct<X, Y>(coins);
let amount_x = coin::value(&coins_x);
let amount_y = coin::value(&coins_y);
check_or_register_coin_store<X>(sender);
check_or_register_coin_store<Y>(sender);
let sender_addr = signer::address_of(sender);
coin::deposit<X>(sender_addr, coins_x);
coin::deposit<Y>(sender_addr, coins_y);
// event
let pair_event_holder = borrow_global_mut<PairEventHolder<X,
Y>>(RESOURCE_ACCOUNT);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

event::emit_event<RemoveLiquidityEvent<X, Y>>(
&mut pair_event_holder.remove_liquidity,
RemoveLiquidityEvent<X, Y> {
user: sender_addr,
amount_x,
amount_y,
liquidity,
fee_amount: (fee_amount as u64)
}
);
(amount_x, amount_y)
}
/// Remove liquidity to token types.
fun remove_liquidity_direct<X, Y>(
liquidity: coin::Coin<LPToken<X, Y>>,
): (coin::Coin<X>, coin::Coin<Y>, u64) acquires TokenPairMetadata, TokenPairReserve {
burn<X, Y>(liquidity)
}
/// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
public(friend) fun swap_exact_x_to_y<X, Y>(
sender: &signer,
amount_in: u64,
to: address
): u64 acquires TokenPairReserve, TokenPairMetadata {
let coins = coin::withdraw<X>(sender, amount_in);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let (coins_x_out, coins_y_out) = swap_exact_x_to_y_direct<X, Y>(coins);
let amount_out = coin::value(&coins_y_out);
check_or_register_coin_store<Y>(sender);
coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
coin::deposit(to, coins_y_out);
amount_out
}
/// Swap X to Y, X is in and Y is out. This method assumes amount_out_min is 0
public(friend) fun swap_exact_x_to_y_direct<X, Y>(
coins_in: coin::Coin<X>
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
let amount_in = coin::value<X>(&coins_in);
deposit_x<X, Y>(coins_in);
let (rin, rout, _) = token_reserves<X, Y>();
let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
assert!(coin::value<X>(&coins_x_out) == 0,
ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
(coins_x_out, coins_y_out)
}
public(friend) fun swap_x_to_exact_y<X, Y>(
sender: &signer,
amount_in: u64,
amount_out: u64,
to: address
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

): u64 acquires TokenPairReserve, TokenPairMetadata {
let coins_in = coin::withdraw<X>(sender, amount_in);
let (coins_x_out, coins_y_out) = swap_x_to_exact_y_direct<X, Y>(coins_in, amount_out);
check_or_register_coin_store<Y>(sender);
coin::destroy_zero(coins_x_out); // or others ways to drop `coins_x_out`
coin::deposit(to, coins_y_out);
amount_in
}
public(friend) fun swap_x_to_exact_y_direct<X, Y>(
coins_in: coin::Coin<X>, amount_out: u64
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
deposit_x<X, Y>(coins_in);
let (coins_x_out, coins_y_out) = swap<X, Y>(0, amount_out);
assert!(coin::value<X>(&coins_x_out) == 0,
ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
(coins_x_out, coins_y_out)
}
/// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
public(friend) fun swap_exact_y_to_x<X, Y>(
sender: &signer,
amount_in: u64,
to: address
): u64 acquires TokenPairReserve, TokenPairMetadata {
let coins = coin::withdraw<Y>(sender, amount_in);
let (coins_x_out, coins_y_out) = swap_exact_y_to_x_direct<X, Y>(coins);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let amount_out = coin::value<X>(&coins_x_out);
check_or_register_coin_store<X>(sender);
coin::deposit(to, coins_x_out);
coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
amount_out
}
public(friend) fun swap_y_to_exact_x<X, Y>(
sender: &signer,
amount_in: u64,
amount_out: u64,
to: address
): u64 acquires TokenPairReserve, TokenPairMetadata {
let coins_in = coin::withdraw<Y>(sender, amount_in);
let (coins_x_out, coins_y_out) = swap_y_to_exact_x_direct<X, Y>(coins_in, amount_out);
check_or_register_coin_store<X>(sender);
coin::deposit(to, coins_x_out);
coin::destroy_zero(coins_y_out); // or others ways to drop `coins_y_out`
amount_in
}
public(friend) fun swap_y_to_exact_x_direct<X, Y>(
coins_in: coin::Coin<Y>, amount_out: u64
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
deposit_y<X, Y>(coins_in);
let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

assert!(coin::value<Y>(&coins_y_out) == 0,
ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
(coins_x_out, coins_y_out)
}
/// Swap Y to X, Y is in and X is out. This method assumes amount_out_min is 0
public(friend) fun swap_exact_y_to_x_direct<X, Y>(
coins_in: coin::Coin<Y>
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
let amount_in = coin::value<Y>(&coins_in);
deposit_y<X, Y>(coins_in);
let (rout, rin, _) = token_reserves<X, Y>();
let amount_out = swap_utils::get_amount_out(amount_in, rin, rout);
let (coins_x_out, coins_y_out) = swap<X, Y>(amount_out, 0);
assert!(coin::value<Y>(&coins_y_out) == 0,
ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
(coins_x_out, coins_y_out)
}
fun swap<X, Y>(
amount_x_out: u64,
amount_y_out: u64
): (coin::Coin<X>, coin::Coin<Y>) acquires TokenPairReserve, TokenPairMetadata {
assert!(amount_x_out > 0 || amount_y_out > 0,
ERROR_INSUFFICIENT_OUTPUT_AMOUNT);
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

assert!(amount_x_out < reserves.reserve_x && amount_y_out < reserves.reserve_y,
ERROR_INSUFFICIENT_LIQUIDITY);
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
let coins_x_out = coin::zero<X>();
let coins_y_out = coin::zero<Y>();
if (amount_x_out > 0) coin::merge(&mut coins_x_out, extract_x(amount_x_out, metadata));
if (amount_y_out > 0) coin::merge(&mut coins_y_out, extract_y(amount_y_out, metadata));
let (balance_x, balance_y) = token_balances<X, Y>();
let amount_x_in = if (balance_x > reserves.reserve_x - amount_x_out) {
balance_x - (reserves.reserve_x - amount_x_out)
} else { 0 };
let amount_y_in = if (balance_y > reserves.reserve_y - amount_y_out) {
balance_y - (reserves.reserve_y - amount_y_out)
} else { 0 };
assert!(amount_x_in > 0 || amount_y_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
let prec = (PRECISION as u128);
let balance_x_adjusted = (balance_x as u128) * prec - (amount_x_in as u128) * 25u128;
let balance_y_adjusted = (balance_y as u128) * prec - (amount_y_in as u128) * 25u128;
let reserve_x_adjusted = (reserves.reserve_x as u128) * prec;
let reserve_y_adjusted = (reserves.reserve_y as u128) * prec;

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// No need to use u256 when balance_x_adjusted * balance_y_adjusted and
reserve_x_adjusted * reserve_y_adjusted are less than MAX_U128.
let compare_result = if(balance_x_adjusted > 0 && reserve_x_adjusted > 0 && MAX_U128
/ balance_x_adjusted > balance_y_adjusted && MAX_U128 / reserve_x_adjusted >
reserve_y_adjusted){
balance_x_adjusted * balance_y_adjusted >= reserve_x_adjusted * reserve_y_adjusted
}else{
let p: u256 = (balance_x_adjusted as u256) * (balance_y_adjusted as u256);
let k: u256 = (reserve_x_adjusted as u256) * (reserve_y_adjusted as u256);
p >= k
};
assert!(compare_result, ERROR_K);
update(balance_x, balance_y, reserves);
(coins_x_out, coins_y_out)
}
/// Mint LP Token.
/// This low-level function should be called from a contract which performs important safety
checks
fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve,
TokenPairMetadata {
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
let (balance_x, balance_y) = (coin::value(&metadata.balance_x),
coin::value(&metadata.balance_y));
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
//Need to add fee amount which have not been mint.
let total_supply = total_lp_supply<X, Y>();
let liquidity = if (total_supply == 0u128) {
let sqrt = math128::sqrt(amount_x * amount_y);
assert!(sqrt > MINIMUM_LIQUIDITY, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
let l = sqrt - MINIMUM_LIQUIDITY;
// permanently lock the first MINIMUM_LIQUIDITY tokens
mint_lp_to<X, Y>(RESOURCE_ACCOUNT, (MINIMUM_LIQUIDITY as u64),
&metadata.mint_cap);
l
} else {
let liquidity = math128::min(amount_x * total_supply / (reserves.reserve_x as u128),
amount_y * total_supply / (reserves.reserve_y as u128));
assert!(liquidity > 0u128, ERROR_INSUFFICIENT_LIQUIDITY_MINTED);
liquidity
};
let lp = mint_lp<X, Y>((liquidity as u64), &metadata.mint_cap);
update<X, Y>(balance_x, balance_y, reserves);
metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

(lp, fee_amount)
}
fun burn<X, Y>(lp_tokens: coin::Coin<LPToken<X, Y>>): (coin::Coin<X>, coin::Coin<Y>, u64)
acquires TokenPairMetadata, TokenPairReserve {
let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
let (balance_x, balance_y) = (coin::value(&metadata.balance_x),
coin::value(&metadata.balance_y));
let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
let liquidity = coin::value(&lp_tokens);
let fee_amount = mint_fee<X, Y>(reserves.reserve_x, reserves.reserve_y, metadata);
//Need to add fee amount which have not been mint.
let total_lp_supply = total_lp_supply<X, Y>();
let amount_x = ((balance_x as u128) * (liquidity as u128) / (total_lp_supply as u128) as
u64);
let amount_y = ((balance_y as u128) * (liquidity as u128) / (total_lp_supply as u128) as
u64);
assert!(amount_x > 0 && amount_y > 0, ERROR_INSUFFICIENT_LIQUIDITY_BURNED);
coin::burn<LPToken<X, Y>>(lp_tokens, &metadata.burn_cap);
let w_x = extract_x((amount_x as u64), metadata);
let w_y = extract_y((amount_y as u64), metadata);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

update(coin::value(&metadata.balance_x), coin::value(&metadata.balance_y), reserves);
metadata.k_last = (reserves.reserve_x as u128) * (reserves.reserve_y as u128);
(w_x, w_y, fee_amount)
}
fun update<X, Y>(balance_x: u64, balance_y: u64, reserve: &mut TokenPairReserve<X, Y>)
{
let block_timestamp = timestamp::now_seconds();
reserve.reserve_x = balance_x;
reserve.reserve_y = balance_y;
reserve.block_timestamp_last = block_timestamp;
}
/// Mint LP Tokens to account
fun mint_lp_to<X, Y>(
to: address,
amount: u64,
mint_cap: &coin::MintCapability<LPToken<X, Y>>
){
let coins = coin::mint<LPToken<X, Y>>(amount, mint_cap);
coin::deposit(to, coins);
}
/// Mint LP Tokens to account
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

fun mint_lp<X, Y>(amount: u64, mint_cap: &coin::MintCapability<LPToken<X, Y>>):
coin::Coin<LPToken<X, Y>> {
coin::mint<LPToken<X, Y>>(amount, mint_cap)
}
fun deposit_x<X, Y>(amount: coin::Coin<X>) acquires TokenPairMetadata {
let metadata =
borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
coin::merge(&mut metadata.balance_x, amount);
}
fun deposit_y<X, Y>(amount: coin::Coin<Y>) acquires TokenPairMetadata {
let metadata =
borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
coin::merge(&mut metadata.balance_y, amount);
}
/// Extract `amount` from this contract
fun extract_x<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<X>
{
assert!(coin::value<X>(&metadata.balance_x) > amount,
ERROR_INSUFFICIENT_AMOUNT);
coin::extract(&mut metadata.balance_x, amount)
}
/// Extract `amount` from this contract

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

fun extract_y<X, Y>(amount: u64, metadata: &mut TokenPairMetadata<X, Y>): coin::Coin<Y>
{
assert!(coin::value<Y>(&metadata.balance_y) > amount,
ERROR_INSUFFICIENT_AMOUNT);
coin::extract(&mut metadata.balance_y, amount)
}
fun mint_fee<X, Y>(reserve_x: u64, reserve_y: u64, metadata: &mut TokenPairMetadata<X,
Y>): u64 {
let fee = 0u64;
if (metadata.k_last != 0) {
let root_k = math128::sqrt((reserve_x as u128) * (reserve_y as u128));
let root_k_last = math128::sqrt(metadata.k_last);
if (root_k > root_k_last) {
let numerator = total_lp_supply<X, Y>() * (root_k - root_k_last) * 8u128;
let denominator = root_k_last * 17u128 + (root_k * 8u128);
let liquidity = numerator / denominator;
fee = (liquidity as u64);
// record fee amount in metadata, in case of fee_to with register.
if (fee > 0) {
let coin = mint_lp(fee, &metadata.mint_cap);
coin::merge(&mut metadata.fee_amount, coin);
}
};
};
fee
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
public entry fun set_admin(sender: &signer, new_admin: address) acquires SwapInfo {
let sender_addr = signer::address_of(sender);
let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
swap_info.admin = new_admin;
}
public entry fun set_fee_to(sender: &signer, new_fee_to: address) acquires SwapInfo {
let sender_addr = signer::address_of(sender);
let swap_info = borrow_global_mut<SwapInfo>(RESOURCE_ACCOUNT);
assert!(sender_addr == swap_info.admin, ERROR_NOT_ADMIN);
swap_info.fee_to = new_fee_to;
}
}
module movement::swap_utils {
use std::string;
use aptos_std::type_info;
const EQUAL: u8 = 0;
const SMALLER: u8 = 1;
const GREATER: u8 = 2;
const ERROR_INSUFFICIENT_INPUT_AMOUNT: u64 = 0;
const ERROR_INSUFFICIENT_LIQUIDITY: u64 = 1;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

const ERROR_INSUFFICIENT_AMOUNT: u64 = 2;
const ERROR_INSUFFICIENT_OUTPOT_AMOUNT: u64 = 3;
const ERROR_SAME_COIN: u64 = 4;
public fun get_amount_out(
amount_in: u64,
reserve_in: u64,
reserve_out: u64
): u64 {
assert!(amount_in > 0, ERROR_INSUFFICIENT_INPUT_AMOUNT);
assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
let amount_in_with_fee = (amount_in as u128) * 9975u128;
let numerator = amount_in_with_fee * (reserve_out as u128);
let denominator = (reserve_in as u128) * 10000u128 + amount_in_with_fee;
((numerator / denominator) as u64)
}
public fun get_amount_in(
amount_out: u64,
reserve_in: u64,
reserve_out: u64
): u64 {
assert!(amount_out > 0, ERROR_INSUFFICIENT_OUTPOT_AMOUNT);
assert!(reserve_in > 0 && reserve_out > 0, ERROR_INSUFFICIENT_LIQUIDITY);
let numerator = (reserve_in as u128) * (amount_out as u128) * 10000u128;
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let denominator = ((reserve_out as u128) - (amount_out as u128)) * 9975u128;
(((numerator / denominator) as u64) + 1u64)
}
public fun quote(amount_x: u64, reserve_x: u64, reserve_y: u64): u64 {
assert!(amount_x > 0, ERROR_INSUFFICIENT_AMOUNT);
assert!(reserve_x > 0 && reserve_y > 0, ERROR_INSUFFICIENT_LIQUIDITY);
(((amount_x as u128) * (reserve_y as u128) / (reserve_x as u128)) as u64)
}
public fun get_token_info<T>(): vector<u8> {
let type_name = type_info::type_name<T>();
*string::bytes(&type_name)
}
}
```
## Understanding Pump4fun: A Beginner's Guide
### Summary
Pump4fun is a user-friendly DeFi platform that simplifies token creation and liquidity
management on the blockchain. It allows users to easily create custom tokens, manage liquidity,
and interact with decentralized exchanges. The platform aims to democratize access to DeFi by
automating complex processes, making it accessible to both beginners and experienced users
in the crypto space.
## What is Pump4fun?
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

[Pump4fun](http://pump.fun) is an innovative decentralized finance (DeFi) platform designed to
make token creation and liquidity management more accessible and efficient for users. It aims
to simplify the process of launching and managing tokens on the blockchain.
## How Does Pump4fun Work?
Pump4fun operates on a blockchain network, allowing users to create their own tokens, manage
liquidity, and interact with decentralized exchanges (DEXs) in a user-friendly manner. The
platform automates many complex processes that typically require deep technical knowledge.
## Why Does Pump4fun Matter?
Pump4fun matters because it democratizes token creation and management. It allows
individuals and small projects to participate in the DeFi ecosystem without needing extensive
blockchain development skills. This opens up new opportunities for innovation and participation
in the crypto space.
## Key Features and User Flow
- **Token Creation:** Users can easily create their own tokens with customizable parameters.
- **Liquidity Management:** The platform helps in adding and managing liquidity for the created
tokens.
- **DEX Integration:** Tokens can be automatically listed on decentralized exchanges when
certain conditions are met.
- **User-Friendly Interface:** The entire process is designed to be intuitive, even for blockchain
beginners.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

## Typical User Flow:
1. User connects their wallet to Pump4fun
2. They choose to create a new token, setting parameters like name, symbol, and supply
3. The platform guides them through adding initial liquidity
4. Users can monitor their token's performance and manage liquidity
5. When predefined goals are met, the token can be automatically listed on supported DEXs
## Functions We Will Build
- **create_token:** A function to mint new tokens with user-defined parameters
- **add_liquidity_curve:** Functionality to add liquidity to Curve, a popular decentralized
exchange
- **add_to_dex:** A feature to automatically list tokens on various decentralized exchanges
when certain requirements are met
These functions will form the core of Pump4fun's functionality, enabling users to go from token
creation to active trading with minimal technical barriers.
## Conclusion
Pump4fun is set to revolutionize how we interact with token creation and management in the
DeFi space. By simplifying complex processes and providing an intuitive platform, it opens up
new possibilities for both novice and experienced users in the blockchain world.
# Create a Fungible Assets

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### Overview
In this article, we will use the knowledge we've learned about Coins and Fungible Assets to
create a function that allows people to easily create an FA, and the admin (platform owner) will
receive an amount of $MOVE as fees. In this example, we will use 0.1 MOVE as the fee for
creating a token on MOVE.
## Admin Configuration
We will need an admin to control or receive fees when users create tokens, and to manage
functions that only the admin can execute. Here, we will initialize a resource that contains
information about the Fee and admin address.
```rust
struct AppConfig has key {
fees: u64,
admin: address
}
fun init_module(sender: &signer) {
let admin_addr = signer::address_of(sender);
move_to(sender, AppConfig {
fees: 10_000_000, // 1 APT = 100_000_000 octas
admin: admin_addr,
});
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
The `init_module` function is a module initialization function, called when the module is
deployed. It has the following characteristics:
- Parameter: Takes a parameter `sender` of type `&signer`, representing the module deployer.
- Function: Initializes and stores an `AppConfig` structure in the deployer's storage.
- Specifically:
- Gets the address of the deployer using `signer::address_of(sender)`.
- Creates an instance of `AppConfig` with:
- Fees set to 10,000,000 octas (equivalent to 0.1 APT).
- Admin address set to the deployer's address.
- Uses `move_to` to store `AppConfig` in the deployer's storage.
This function sets up the initial configuration for the application, including the fee amount and
admin address, which will be used to manage token creation and fee collection as described in
the overview.
## Create Token & Buy
### Create Token
Next, we will initialize a Function to help users easily create a token.
```rust
/// Creates a new token and buys an initial amount for the sender.
///
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

/// @param sender: The signer creating the token and making the initial purchase.
/// @param name: The name of the token.
/// @param symbol: The symbol or ticker of the token.
/// @param icon_uri: The URI for the token's icon.
/// @param project_url: The URL of the project associated with the token.
/// @param amount: The initial amount of tokens to mint and buy.
///
/// This function creates a new fungible asset (token) with the given parameters,
/// mints the specified amount, and transfers it to the sender. It also handles
/// the fee payment to the admin as configured in the AppConfig resource.
///
/// Acquires: AppConfig - to access the fee information and admin address.
public entry fun create_token_and_buy(
sender: &signer,
name: string::String,
symbol: string::String,
icon_uri: string::String,
project_url: string::String,
amount: u64
) acquires AppConfig {
// Implementation details go here
}
```
The `create_token_and_buy` function is a public function that allows users to create and buy a
new token.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- **Purpose:** Create a new token and buy an initial amount for the sender.
- **Parameters:**
- `sender`: The signer creating the token and executing the initial purchase transaction.
- `name`: The name of the token.
- `symbol`: The symbol or code of the token.
- `icon_uri`: The URI for the token's icon.
- `project_url`: The URL of the project related to the token.
- `amount`: The initial amount of tokens to create and buy.
- **Main functions:**
- Create a new fungible asset with the provided parameters.
- Mint the specified amount of tokens.
- Transfer the created tokens to the sender.
- Handle the fee payment to the admin according to the configuration in the AppConfig
resource.
- **Important features:**
- Uses the keyword `acquires AppConfig` to access information about fees and admin
address.
- Is an `entry` function, allowing it to be called directly from outside the module.
This function provides a simple and direct way for users to create their own tokens on the
platform, while ensuring that appropriate fees are collected and transferred to the system admin.
### Initializing a Fungible Asset Store
```rust
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
let object_signer = object::generate_signer(&constructor_ref);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

primary_fungible_store::create_primary_store_enabled_fungible_asset(
&constructor_ref,
option::some(1_000_000_000), // Total supply
name,
// Token Name
symbol,
// Token Symbol
8,
// Decimals
icon_uri,
// Icon URI (ex: https://icon.jpg)
project_url
// Project URL
);
```
This code snippet describes a part of the function to initialize a Fungible Asset on the Move
platform. This is an important part of the process of creating a new token. Let's analyze each
step:
1. Create a named object:
`let constructor_ref = object::create_named_object(sender, *string::bytes(&name));`
This line creates a new object with a name based on the provided 'name' parameter.
2. Create a signer for the object:
`let object_signer = object::generate_signer(&constructor_ref);`
Creates a 'signer' for the new object, allowing operations to be performed on behalf of this
object.
3. Create Fungible Asset:
`primary_fungible_store::create_primary_store_enabled_fungible_asset(...)`
This is the main step to create the token. This function takes the following parameters:
- Constructor reference
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Total supply: 1,000,000,000 (can be adjusted)
- Token name
- Token symbol
- Decimals: 8
- Icon URI
- Project URL
This code creates a new Fungible Asset with the specified attributes, allowing users to create
their own tokens with specific parameters. It also sets up the primary store for the token,
enabling efficient storage and management of the token.
### Mint & Deposit Tokens
```rust
let fa = fungible_asset::mint(&controller.mint_ref, amount);
primary_fungible_store::deposit(signer::address_of(account), fa);
```
Based on the selected code snippet, I can describe the functionality as follows:
This code snippet performs two important steps in the process of creating and distributing
tokens:
1. Create (mint) tokens:
`let fa = fungible_asset::mint(&controller.mint_ref, amount);`
This function creates a new amount of tokens (fungible asset) based on the specified amount. It
uses the mint reference (mint_ref) from the controller to perform the token creation.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

2. Deposit tokens into the account:
`primary_fungible_store::deposit(signer::address_of(account), fa);`
This function deposits the newly created tokens (fa) into the user's account. The account
address is obtained from the account object using `signer::address_of(account)`.
The purpose of this function is to allow users to create a new amount of tokens and immediately
deposit them into their account. This helps users to initialize and own tokens easily and quickly.
This function is an important part of the token creation process, allowing users not only to define
the token's attributes (as seen in previous sections with parameters like name, symbol, icon_uri,
project_url) but also to create and own a specific amount of tokens right from the start.
### Fungible Asset Controller
In the article about Object and Fungible Asset, we learned about FA Abilities such as MintRef,
BurnRef, TransferRef. So we will also use them to apply to this Function to initialize a resource
object containing these Abilities for the FA we just created.
```rust
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FAController has key {
dev_address: address,
mint_ref: MintRef,
burn_ref: BurnRef,
transfer_ref: TransferRef,
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Setup token controller
move_to(&object_signer, FAController {
dev_address: sender_addr,
mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
});
```
### Admin Fee
Another issue is that when initializing a token, the platform admin needs to receive a
corresponding fee. For this, we can use AptosCoin to use the Native coin of the Platform, which
in this case will be $MOVE on the Movement Network.
```rust
let app_config = borrow_global<AppConfig>(@movement);
let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
coin::deposit<AptosCoin>(app_config.admin, coins);
```
This function performs the following steps:
- Access the application configuration (AppConfig) from the Movement address to get
information about fees and admin address

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Withdraw an amount of coins (AptosCoin) from the sender's account based on the configured
fee
- Deposit the withdrawn coins into the admin's account
Note that this function uses AptosCoin, but in the context of the Movement Network, this will
correspond to $MOVE, which is the native coin of the platform.
## Full Code
```rust
module movement::pump_for_fun {
use std::string;
use std::option;
use std::signer;
use aptos_framework::object::{Self, Object};
use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
use aptos_framework::primary_fungible_store;
use aptos_framework::coin;
use aptos_framework::aptos_coin::AptosCoin;
const DECIMAIL :u8 = 8;
const MAX_SUPPLY: u128 = 1_000_000_000;
const FEE: u64 = 10_000_000;
struct AppConfig has key {
fees: u64,
admin: address,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FAController has key {
dev_address: address,
mint_ref: MintRef,
burn_ref: BurnRef,
transfer_ref: TransferRef,
}
fun init_module(sender: &signer) {
let admin_addr = signer::address_of(sender);
move_to(sender, AppConfig {
fees: FEE, // 0.1 APT = 100_000_000 octas
admin: admin_addr,
});
}
public entry fun create_token_and_buy(
sender: &signer,
name: string::String,
symbol: string::String,
icon_uri: string::String,
project_url: string::String,
amount: u64
) acquires AppConfig, FAController {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let app_config = borrow_global<AppConfig>(@movement);
let admin_addr = app_config.admin;
let sender_addr = signer::address_of(sender);
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
let object_signer = object::generate_signer(&constructor_ref);
let coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
coin::deposit<AptosCoin>(admin_addr, coins);
primary_fungible_store::create_primary_store_enabled_fungible_asset(
&constructor_ref,
option::some(1_000_000_000),
name,
symbol,
DECIMAIL,
icon_uri,
project_url
);
let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
// Setup token controller
move_to(&object_signer, FAController {
dev_address: sender_addr,
mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
});
mint_tokens(sender, fa_obj, amount);
}
/// Mint tokens to an account
fun mint_tokens(
account: &signer,
token: Object<Metadata>,
amount: u64,
) acquires FAController {
let token_addr = object::object_address(&token);
let controller = borrow_global<FAController>(token_addr);
let fa = fungible_asset::mint(&controller.mint_ref, amount);
primary_fungible_store::deposit(signer::address_of(account), fa);
}
}
```
## Initialize Liquidity in a Pump4fun
### Summary
This page explains how to initialize liquidity in a Pump4fun system, focusing on creating a
liquidity pool for a custom token pair and Move token. Key points include:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Definition of the LiquidityPool struct with fields for token and Move reserves, token address,
owner, and signer capability
- Step-by-step process to initialize a liquidity pool using the initialize_liquidity_pool function
- Creation of a resource account for the pool
- Registration of Move coin storage for the pool
- Minting of custom tokens and transfer of Move tokens to the pool
- Initialization of the LiquidityPool structure with provided data
- The function's role in setting up infrastructure for decentralized exchanges or DeFi protocols
## Overview
After successfully initializing the token, we will now use the token and Move Token that were
used to purchase tokens to initialize the Pool for the above Token Pair.
```rust
struct LiquidityPool has key {
token_reserve: u64,
move_reserve: u64,
token_address: Object<Metadata>,
owner: address,
signer_cap: SignerCapability,
}
```
The LiquidityPool struct includes the following fields:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- token_reserve: The amount of tokens in the pool
- apt_reserve: The amount of Move in the pool
- token_address: The address of the token metadata
- owner: The address of the pool owner
- signer_cap: The ability to sign transactions for the pool
To initialize a liquidity pool using this structure, you need to create an initialization function with
corresponding parameters. For example:
```rust
fun initialize_liquidity_pool(
sender: &signer,
token: Object<Metadata>,
move_amount: u64,
token_amount: u64
) acquires FAController {
let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
// Register APT coin store for pool
if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
coin::register<AptosCoin>(&pool_signer);
};
// Mint tokens to pool
mint_tokens(&pool_signer, token, token_amount);
// Transfer APT to pool
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(signer::address_of(&pool_signer), apt_coins);
// Initialize LP
move_to(&pool_signer, LiquidityPool {
token_reserve: token_amount,
move_reserve: move_amount,
token_address: token,
owner: signer::address_of(sender),
signer_cap,
});
}
```
I will describe in more detail the `initialize_liquidity_pool` function and its features:
**General purpose:**
This function is designed to initialize a liquidity pool for a custom token pair and Move token.
The main purpose is to create a foundation for exchange and provide liquidity in the system.
**Step-by-step details:**
1. Create resource account
```rust
let (pool_signer, signer_cap) = account::create_resource_account(sender, b"Liquidity_Pool");
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
- Use `account::create_resource_account` to create a new resource account for the pool
- Create a pool_signer and signer_cap to manage the pool
1. Register Move coin storage:
```rust
// Register APT coin store for pool
if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
coin::register<AptosCoin>(&pool_signer);
};
```
- Check if the pool has already registered AptosCoin storage
- If not, register AptosCoin storage for the pool
```rust
// Mint tokens to pool
mint_tokens(&pool_signer, token, token_amount);
// Transfer APT to pool
let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(signer::address_of(&pool_signer), apt_coins);
```
1. Mint custom token:
- Use the `mint_tokens` function to create and add custom tokens to the pool
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- The token amount is determined by the `token_amount` parameter
2. Transfer Move token:
- Withdraw Move tokens from the sender's account
- Transfer this amount of Move tokens to the pool's account
```rust
// Initialize LP
move_to(&pool_signer, LiquidityPool {
token_reserve: token_amount,
move_reserve: move_amount,
token_address: token,
owner: signer::address_of(sender),
signer_cap,
});
```
Initialize LiquidityPool:
- Create a new LiquidityPool structure
- Store information about the amount of tokens and Move, token address, owner, and signing
capability
- Use `move_to` to save this structure to the pool's storage
This function plays a crucial role in setting up the infrastructure for a decentralized exchange
(DEX) or a DeFi protocol, allowing users to create initial liquidity for a token-Move pair.
## Initialize Pool
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

After completing the function to initialize the Pool, we will call it immediately after successfully
initializing the token. I want to set the default initial value so that 1 Move can be exchanged for
50,000 Tokens. Subsequently, the price will be calculated based on the pool.
```rust
const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
const APT_DECIMALS: u8 = 8;
const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
// Calculate total tokens to be created
let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128) /
(APT_MULTIPLIER as u128);
assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128),
ERR_MAX_SUPPLY_EXCEEDED);
```
## Create & Buy Token Complete
```rust
module pump4fun::pump_for_fun {
use std::string;
use std::option;
use std::signer;
use aptos_framework::object::{Self, Object};
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
use aptos_framework::primary_fungible_store;
use aptos_framework::coin::{Self};
use aptos_framework::aptos_coin::{Self, AptosCoin};
use aptos_framework::account::{Self, SignerCapability};
const DECIMAL: u8 = 8;
const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
const FEE: u64 = 10_000_000; // 0.1 APT
const INITIAL_TOKEN_PER_APT: u64 = 5_000_000_000_000;
const APT_DECIMALS: u8 = 8;
const APT_MULTIPLIER: u64 = 100_000_000; // 10^8 for APT decimals
// Error codes
const INSUFFICIENT_LIQUIDITY: u64 = 1;
const INVALID_AMOUNT: u64 = 2;
const ERR_NOT_OWNER: u64 = 3;
const ERR_ZERO_AMOUNT: u64 = 4;
const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
struct AppConfig has key {
fees: u64,
admin: address,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FAController has key {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

dev_address: address,
mint_ref: MintRef,
burn_ref: BurnRef,
transfer_ref: TransferRef,
}
struct LiquidityPool has key {
token_reserve: u64,
move_reserve: u64,
token_address: Object<Metadata>,
owner: address,
signer_cap: SignerCapability,
}
fun init_module(sender: &signer) {
let admin_addr = signer::address_of(sender);
move_to(sender, AppConfig {
fees: FEE,
admin: admin_addr,
});
}
public entry fun create_token_and_buy(
sender: &signer,
name: string::String,
symbol: string::String,
icon_uri: string::String,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

project_url: string::String,
move_amount: u64 // Amount of APT in octas (10^8)
) acquires AppConfig, FAController {
assert!(move_amount > 0, ERR_ZERO_AMOUNT);
let app_config = borrow_global<AppConfig>(@pump4fun);
let admin_addr = app_config.admin;
let sender_addr = signer::address_of(sender);
// Collect token creation fee
let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
coin::deposit<AptosCoin>(admin_addr, fee_coins);
// Create new token
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
let object_signer = object::generate_signer(&constructor_ref);
// Initialize token
primary_fungible_store::create_primary_store_enabled_fungible_asset(
&constructor_ref,
option::some((MAX_SUPPLY as u128)),
name,
symbol,
DECIMAL,
icon_uri,
project_url
);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);
// Setup token controller
move_to(&object_signer, FAController {
dev_address: sender_addr,
mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
});
// Calculate total tokens to be created
let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_APT as u128)
/ (APT_MULTIPLIER as u128);
assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128),
ERR_MAX_SUPPLY_EXCEEDED);
// Mint tokens to user
mint_tokens(sender, fa_obj, (user_token_amount as u64));
// Create and initialize Liquidity Pool with same amount
initialize_liquidity_pool(
sender,
fa_obj,
move_amount, // APT from user
(user_token_amount as u64) // Same amount of tokens for pool
);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
fun mint_tokens(
account: &signer,
token: Object<Metadata>,
amount: u64,
) acquires FAController {
let token_addr = object::object_address(&token);
let controller = borrow_global<FAController>(token_addr);
let fa = fungible_asset::mint(&controller.mint_ref, amount);
primary_fungible_store::deposit(signer::address_of(account), fa);
}
fun initialize_liquidity_pool(
sender: &signer,
token: Object<Metadata>,
move_amount: u64,
token_amount: u64
) acquires FAController {
let (pool_signer, signer_cap) = account::create_resource_account(sender,
b"Liquidity_Pool");
// Register APT coin store for pool
if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
coin::register<AptosCoin>(&pool_signer);
};

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Mint tokens to pool
mint_tokens(&pool_signer, token, token_amount);
// Transfer APT to pool
let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(signer::address_of(&pool_signer), apt_coins);
// Initialize LP
move_to(&pool_signer, LiquidityPool {
token_reserve: token_amount,
move_reserve: move_amount,
token_address: token,
owner: signer::address_of(sender),
signer_cap,
});
}
}
```
## AMM & Swap Tokens
### Summary
- AMM (Automated Market Maker) and Constant Product Formula are used to create swap pairs
- Swap mechanism allows users to exchange MOVE for tokens and vice versa
- Key functions include swap_move_to_token, swap_token_to_move, and get_output_amount
- View functions provide previews of swap outcomes and pool information
- A 0.3% fee is applied to all swap transactions
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Pool reserves are dynamically updated after each swap to maintain balance
- The contract ensures efficient and transparent execution of swap transactions
## Overview
In this section, we have thoroughly examined the Swap mechanism. We use AMM (Automated
Market Maker) or Constant Product Formula to create a swap pair, with prices dependent on the
quantity of tokens in the pool.
```rust
// Swap APT for tokens
public entry fun swap_move_to_token(
sender: &signer,
pool: Object<Metadata>,
move_amount: u64
) acquires LiquidityPool {
assert!(move_amount > 0, ERR_ZERO_AMOUNT);
let pool_addr = object::object_address(&pool);
let lp = borrow_global_mut<LiquidityPool>(pool_addr);
// Calculate output tokens
let token_out = get_output_amount(
move_amount,
lp.move_reserve,
lp.token_reserve
);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
// Transfer APT to pool
let apt_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(pool_addr, apt_coins);
let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
// Transfer tokens to user
primary_fungible_store::transfer(
&pool_signer,
lp.token_address,
signer::address_of(sender),
token_out
);
// Update reserves
lp.move_reserve = lp.move_reserve + move_amount;
lp.token_reserve = lp.token_reserve - token_out;
}
// Swap tokens for APT
public entry fun swap_token_to_move(
sender: &signer,
pool: Object<Metadata>,
token_amount: u64
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

) acquires LiquidityPool {
assert!(token_amount > 0, ERR_ZERO_AMOUNT);
let pool_addr = object::object_address(&pool);
let lp = borrow_global_mut<LiquidityPool>(pool_addr);
// Calculate APT output
let apt_out = get_output_amount(
token_amount,
lp.token_reserve,
lp.move_reserve
);
assert!(apt_out > 0, INSUFFICIENT_LIQUIDITY);
// Transfer tokens to pool
primary_fungible_store::transfer(
sender,
lp.token_address,
pool_addr,
token_amount
);
let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
// Transfer APT to user
coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), apt_out);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Update reserves
lp.token_reserve = lp.token_reserve + token_amount;
lp.move_reserve = lp.move_reserve - apt_out;
}
// Calculate output amount based on AMM formula
fun get_output_amount(
input_amount: u64,
input_reserve: u64,
output_reserve: u64
): u64 {
let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
let numerator = input_amount_with_fee * (output_reserve as u128);
let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
((numerator / denominator) as u64)
}
// View Functions
/// Returns the amount of tokens you would receive for the given APT amount
#[view]
public fun get_token_output_amount(
move_amount: u64,
pool: Object<Metadata>
): u64 acquires LiquidityPool {
let pool_addr = object::object_address(&pool);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let lp = borrow_global<LiquidityPool>(pool_addr);
get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
}
/// Returns the amount of APT you would receive for the given token amount
#[view]
public fun get_apt_output_amount(
token_amount: u64,
pool: Object<Metadata>
): u64 acquires LiquidityPool {
let pool_addr = object::object_address(&pool);
let lp = borrow_global<LiquidityPool>(pool_addr);
get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
}
/// Returns the current pool reserves (token_reserve, move_reserve)
#[view]
public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
let pool_addr = object::object_address(&pool);
let lp = borrow_global<LiquidityPool>(pool_addr);
(lp.token_reserve, lp.move_reserve)
}
```
Based on the code above, we can describe the main functions related to token swapping as
follows:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- **swap_move_to_token**: Allows users to exchange MOVE for tokens. This function takes the
sender's address, pool object, and the amount of MOVE to swap.
- **swap_token_to_move**: The reverse of the above function, allowing users to exchange
tokens for MOVE. It takes similar parameters, but instead of MOVE amount, it takes the amount
of tokens to swap.
- **get_output_amount**: An internal function that calculates the output token amount based on
the AMM (Automated Market Maker) formula, accounting for a 0.3% fee.
- **get_token_output_amount**: A view function that allows users to preview the amount of
tokens they would receive when swapping a specific amount of MOVE.
- **get_apt_output_amount**: Similar to the above, this view function allows users to preview
the amount of MOVE they would receive when swapping a specific amount of tokens.
- **get_pool_info**: A view function that returns information about the pool's reserves, including
the current amounts of tokens and MOVE in the pool.
These functions are not directly related to creating new tokens. Instead, they focus on managing
and executing swap transactions between MOVE and an existing token in a liquidity pool. To
create a new token, you would need different functions related to token creation and
management.
### 1. swap_move_to_token
Purpose: Allows users to exchange APT MOVE for tokens in the pool.
- Input: Sender's address, pool object, and the amount of MOVE to swap.
- Checks if the MOVE amount is greater than 0 and calculates the output token amount.
- Transfers MOVE from the user to the pool.
- Transfers tokens from the pool to the user.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Updates the pool's reserves.
### 2. swap_token_to_move
Purpose: Allows users to exchange tokens for MOVE from the pool.
- Input: Sender's address, pool object, and the amount of tokens to swap.
- Checks if the token amount is greater than 0 and calculates the output MOVE amount.
- Transfers tokens from the user to the pool.
- Transfers MOVE from the pool to the user.
- Updates the pool's reserves.
### 3. get_output_amount
Purpose: Calculates the output token amount based on the AMM formula.
- Uses the Constant Product Formula with a 0.3% fee.
- Ensures accurate calculation to maintain balance in the pool.
### 4. get_token_output_amount (View Function)
Purpose: Allows users to preview the amount of tokens they would receive when swapping
MOVE.
- Helps users estimate the swap result before executing the transaction.
### 5. get_apt_output_amount (View Function)
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Purpose: Allows users to preview the amount of MOVE they would receive when swapping
tokens.
- Similar to the above, helps users estimate the reverse swap result.
### 6. get_pool_info (View Function)
Purpose: Provides information about the current state of the pool.
- Returns the current amounts of tokens and MOVE in the pool.
- Helps users and other applications monitor and analyze the pool's state.
All these functions work together to create a complete DEX contract, allowing users to execute
swap transactions and query pool information efficiently and transparently.
## FullCode
```rust
module pump4fun::pump_for_fun {
use std::string;
use std::option;
use std::signer;
use aptos_framework::object::{Self, Object};
use aptos_framework::fungible_asset::{Self, Metadata, MintRef, TransferRef, BurnRef};
use aptos_framework::primary_fungible_store;
use aptos_framework::coin::{Self};
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

use aptos_framework::aptos_coin::{Self, AptosCoin};
use aptos_framework::account::{Self, SignerCapability};
const DECIMAL: u8 = 8;
const MAX_SUPPLY: u64 = 100_000_000_000_000_000;
const FEE: u64 = 10_000_000; // 0.1 APT
const INITIAL_TOKEN_PER_MOVE: u64 = 5_000_000_000_000;
const MOVE_DECIMALS: u8 = 8;
const MOVE_MULTIPLIER: u64 = 100_000_000; // 10^8 for MOVE decimals
// Error codes
const INSUFFICIENT_LIQUIDITY: u64 = 1;
const INVALID_AMOUNT: u64 = 2;
const ERR_NOT_OWNER: u64 = 3;
const ERR_ZERO_AMOUNT: u64 = 4;
const ERR_MAX_SUPPLY_EXCEEDED: u64 = 5;
struct AppConfig has key {
fees: u64,
admin: address,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FAController has key {
dev_address: address,
mint_ref: MintRef,
burn_ref: BurnRef,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

transfer_ref: TransferRef,
}
struct LiquidityPool has key {
token_reserve: u64,
move_reserve: u64,
token_address: Object<Metadata>,
owner: address,
signer_cap: SignerCapability,
}
fun init_module(sender: &signer) {
let admin_addr = signer::address_of(sender);
move_to(sender, AppConfig {
fees: FEE,
admin: admin_addr,
});
}
public entry fun create_token_and_buy(
sender: &signer,
name: string::String,
symbol: string::String,
icon_uri: string::String,
project_url: string::String,
move_amount: u64 // Amount of MOVE in octas (10^8)
) acquires AppConfig, FAController {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

assert!(move_amount > 0, ERR_ZERO_AMOUNT);
let app_config = borrow_global<AppConfig>(@pump4fun);
let admin_addr = app_config.admin;
let sender_addr = signer::address_of(sender);
// Collect token creation fee
let fee_coins = coin::withdraw<AptosCoin>(sender, app_config.fees);
coin::deposit<AptosCoin>(admin_addr, fee_coins);
// Create new token
let constructor_ref = object::create_named_object(sender, *string::bytes(&name));
let object_signer = object::generate_signer(&constructor_ref);
// Initialize token
primary_fungible_store::create_primary_store_enabled_fungible_asset(
&constructor_ref,
option::some((MAX_SUPPLY as u128)),
name,
symbol,
DECIMAL,
icon_uri,
project_url
);
let fa_obj = object::object_from_constructor_ref<Metadata>(&constructor_ref);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Setup token controller
move_to(&object_signer, FAController {
dev_address: sender_addr,
mint_ref: fungible_asset::generate_mint_ref(&constructor_ref),
burn_ref: fungible_asset::generate_burn_ref(&constructor_ref),
transfer_ref: fungible_asset::generate_transfer_ref(&constructor_ref),
});
// Calculate total tokens to be created
let user_token_amount = (move_amount as u128) * (INITIAL_TOKEN_PER_MOVE as
u128) / (MOVE_MULTIPLIER as u128);
assert!((user_token_amount * 2) <= (MAX_SUPPLY as u128),
ERR_MAX_SUPPLY_EXCEEDED);
// Mint tokens to user
mint_tokens(sender, fa_obj, (user_token_amount as u64));
// Create and initialize Liquidity Pool with same amount
initialize_liquidity_pool(
sender,
fa_obj,
move_amount, // MOVE from user
(user_token_amount as u64) // Same amount of tokens for pool
);
}
fun mint_tokens(
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

account: &signer,
token: Object<Metadata>,
amount: u64,
) acquires FAController {
let token_addr = object::object_address(&token);
let controller = borrow_global<FAController>(token_addr);
let fa = fungible_asset::mint(&controller.mint_ref, amount);
primary_fungible_store::deposit(signer::address_of(account), fa);
}
fun initialize_liquidity_pool(
sender: &signer,
token: Object<Metadata>,
move_amount: u64,
token_amount: u64
) acquires FAController {
let (pool_signer, signer_cap) = account::create_resource_account(sender,
b"Liquidity_Pool");
// Register MOVE coin store for pool
if (!coin::is_account_registered<AptosCoin>(signer::address_of(&pool_signer))) {
coin::register<AptosCoin>(&pool_signer);
};
// Mint tokens to pool
mint_tokens(&pool_signer, token, token_amount);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Transfer MOVE to pool
let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(signer::address_of(&pool_signer), move_coins);
// Initialize LP
move_to(&pool_signer, LiquidityPool {
token_reserve: token_amount,
move_reserve: move_amount,
token_address: token,
owner: signer::address_of(sender),
signer_cap,
});
}
// Swap MOVE for tokens
public entry fun swap_move_to_token(
sender: &signer,
pool: Object<Metadata>,
move_amount: u64
) acquires LiquidityPool {
assert!(move_amount > 0, ERR_ZERO_AMOUNT);
let pool_addr = object::object_address(&pool);
let lp = borrow_global_mut<LiquidityPool>(pool_addr);
// Calculate output tokens
let token_out = get_output_amount(
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

move_amount,
lp.move_reserve,
lp.token_reserve
);
assert!(token_out > 0, INSUFFICIENT_LIQUIDITY);
// Transfer MOVE to pool
let move_coins = coin::withdraw<AptosCoin>(sender, move_amount);
coin::deposit(pool_addr, move_coins);
let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
// Transfer tokens to user
primary_fungible_store::transfer(
&pool_signer,
lp.token_address,
signer::address_of(sender),
token_out
);
// Update reserves
lp.move_reserve = lp.move_reserve + move_amount;
lp.token_reserve = lp.token_reserve - token_out;
}
// Swap tokens for MOVE
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public entry fun swap_token_to_move(
sender: &signer,
pool: Object<Metadata>,
token_amount: u64
) acquires LiquidityPool {
assert!(token_amount > 0, ERR_ZERO_AMOUNT);
let pool_addr = object::object_address(&pool);
let lp = borrow_global_mut<LiquidityPool>(pool_addr);
// Calculate MOVE output
let move_out = get_output_amount(
token_amount,
lp.token_reserve,
lp.move_reserve
);
assert!(move_out > 0, INSUFFICIENT_LIQUIDITY);
// Transfer tokens to pool
primary_fungible_store::transfer(
sender,
lp.token_address,
pool_addr,
token_amount
);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let pool_signer = account::create_signer_with_capability(&lp.signer_cap);
// Transfer MOVE to user
coin::transfer<AptosCoin>(&pool_signer, signer::address_of(sender), move_out);
// Update reserves
lp.token_reserve = lp.token_reserve + token_amount;
lp.move_reserve = lp.move_reserve - move_out;
}
// Calculate output amount based on AMM formula
fun get_output_amount(
input_amount: u64,
input_reserve: u64,
output_reserve: u64
): u64 {
let input_amount_with_fee = (input_amount as u128) * 997; // 0.3% fee
let numerator = input_amount_with_fee * (output_reserve as u128);
let denominator = (input_reserve as u128) * 1000 + input_amount_with_fee;
((numerator / denominator) as u64)
}
// View Functions
/// Returns the amount of tokens you would receive for the given MOVE amount
#[view]
public fun get_token_output_amount(
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

move_amount: u64,
pool: Object<Metadata>
): u64 acquires LiquidityPool {
let pool_addr = object::object_address(&pool);
let lp = borrow_global<LiquidityPool>(pool_addr);
get_output_amount(move_amount, lp.move_reserve, lp.token_reserve)
}
/// Returns the amount of MOVE you would receive for the given token amount
#[view]
public fun get_move_output_amount(
token_amount: u64,
pool: Object<Metadata>
): u64 acquires LiquidityPool {
let pool_addr = object::object_address(&pool);
let lp = borrow_global<LiquidityPool>(pool_addr);
get_output_amount(token_amount, lp.token_reserve, lp.move_reserve)
}
/// Returns the current pool reserves (token_reserve, move_reserve)
#[view]
public fun get_pool_info(pool: Object<Metadata>): (u64, u64) acquires LiquidityPool {
let pool_addr = object::object_address(&pool);
let lp = borrow_global<LiquidityPool>(pool_addr);
(lp.token_reserve, lp.move_reserve)
}
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
# What is DeFi Lending & Borrowing?
### Overview
DeFi Lending & Borrowing is a fully automated cryptocurrency lending and borrowing system
that operates on the blockchain. Let's understand in detail how it works through specific
examples.
## Multiple Liquidity Pools
Modern DeFi platforms typically offer multiple liquidity pools for different cryptocurrencies. Users
can choose to lend or borrow various assets like USDT, ETH, BTC, and other supported tokens.
Each pool operates independently with its own:
- Interest rates based on supply and demand
- Collateral requirements and ratios
- Total liquidity and utilization rates
## Detailed Operating Mechanism
Let's look at examples across different pools:
### 1. Creating the Liquidity Pools
Alice can deposit different assets into various pools:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- 1000 USDT into the USDT pool
- 10 ETH into the ETH pool
- 0.5 BTC into the BTC pool
### 2. Borrowing Process
- Bob can borrow from any available pool based on his needs
- He can use ETH as collateral to borrow USDT (cross-collateral)
- Or use BTC to borrow ETH, and so on
- Each pool has its own collateral ratio requirements
### 3. During the Loan Period
- Interest rates vary between different pools
- Each pool has its own minimum collateral ratio
- If collateral value drops below the safe ratio, Bob must:
- Add more collateral, or
- Repay part of the loan to maintain the safe ratio
### 4. Loan Completion
- Bob repays the borrowed amount + interest
- The smart contract automatically returns the collateralized assets
- Lenders receive their share of interest based on their contribution to the pool
## Common Use Cases

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### 1. Borrowing for Investment (Leverage)
Bob believes ETH price will increase. Instead of selling ETH, Bob collateralizes ETH to borrow
USDT and buy more ETH.
### 2. Borrowing for Payments
Carol urgently needs USDT but doesn't want to sell BTC. She can collateralize BTC to borrow
USDT, then repay when she has the money.
### 3. Lending for Passive Income
Alice wants to generate income from her crypto holdings. She can distribute her assets across
different pools to optimize returns and diversify risk.
In the following articles, we will learn how to build a simple smart contract to implement the
basic functions of a multi-pool lending platform like this.
# The types of Lending Pool
## Understanding Lending Pools and Guide to Building a DeFi Lending Platform
### Overview
In this series of articles, we will dive deep into understanding and building a decentralized
lending platform (DeFi Lending Platform). Before we start coding, we need to understand the
basic concepts of Lending Pools and how they work.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

## What is a Lending Pool?
A Lending Pool is a liquidity pool where users can deposit tokens for lending, and others can
borrow these tokens. This is the foundation of DeFi lending applications like Aave, Compound.
## Common Types of Lending Pools
### 1. Main Pool - Basic Pool
This is the most common type of pool in DeFi, with these characteristics:
- Users can deposit multiple types of tokens
- Uses an overcollateralized lending model
- Interest rates are automatically calculated based on supply and demand
- Collateral ratio typically ranges from 50-75% for security
### 2. Isolated Pool - Independent Pool
This type of pool is designed to minimize risk:
- Each pool supports only a specific token pair
- Risks are isolated, not affecting other pools
- Suitable for new tokens or high-risk assets
- Parameters like collateral ratio and interest rates can be customized
### 3. Leverage Pool

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

This pool is designed for professional traders:
- Allows high leverage borrowing (up to 10x)
- Direct integration with DEX
- Has automatic liquidation mechanisms to protect the pool
- Suitable for complex trading strategies
## Important Considerations When Designing Lending Pools
| Factor | Main Pool | Isolated Pool | Leverage Pool |
| --- | --- | --- | --- |
| Risk Level | Medium | Low | High |
| Collateral Ratio | 50-75% | Customizable | 10-50% |
| Complexity | Low | Medium | High |
In the following articles, we will delve into implementing each type of pool, starting with the Main
Pool - the most basic type. We will learn how to design smart contracts, handle interest rate
calculations, and implement necessary security mechanisms.
# Initialize Wrap Coin
## What is Wrap Coin?
### Overview
A wrapped coin is a cryptocurrency token issued on a blockchain that is backed one-to-one by
another cryptocurrency. The most common examples are WETH (Wrapped ETH) and WBTC
(Wrapped Bitcoin).

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

## How it Works
- **Wrapping process:** Users send their original cryptocurrency to a specialized smart contract
(custodian), which then issues an equivalent amount of wrapped tokens.
- **1:1 ratio:** One WETH equals one ETH, one WBTC equals one BTC. This ratio remains
constant.
- **Unwrap:** Users can exchange their wrapped tokens back to receive the original coins at
any time.
## Role in Lending & Borrowing
Wrapped coins serve an essential function in decentralized lending platforms (DeFi lending
platforms):
- **Compatibility:** Wrapped tokens enable coins from one blockchain to be used on another
blockchain. For example: WBTC allows Bitcoin usage on Ethereum DeFi.
- **Flexible collateral:** Users can use wrapped tokens as collateral to borrow other tokens.
- **Yield farming:** Wrapped tokens can be used in farming strategies to generate additional
profits.
## Risks to Consider
- Risks from smart contracts managing wrapped tokens
- Dependence on custodians holding the original assets
- Gas fees for wrapping/unwrapping tokens

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Wrapped coins are a vital tool in the DeFi ecosystem, especially in lending and borrowing,
enhancing flexibility and efficiency for decentralized financial transactions.
## Overview
Module `movement::all_tokens` is an important part of the lending platform, responsible for
managing and initializing tokens used in the lending system. This module allows:
- Initialization of new tokens (like WBTC, WETH)
- Management of token minting
- Setting up limits and control permissions
## Module Structure
### Structs
### Token Types
```rust
struct WBTC has key, store {}
struct WETH has key, store {}
```
- Represents the types of wrapped tokens (WBTC, WETH)
- Has `key` and `store` abilities for storage and transfer capabilities
### Capability Struct
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
struct Cap<phantom CoinType> has key {
mint_cap: coin::MintCapability<CoinType>,
freeze_cap: coin::FreezeCapability<CoinType>,
burn_cap: coin::BurnCapability<CoinType>,
}
```
- Manages capabilities for each token type
- Generic type allows use with different token types
- Includes mint, freeze, and burn token capabilities
## Functions
### Initialize Function
```rust
public entry fun intialize<CoinType>(
sender: &signer,
name: string::String,
symbol: string::String,
decimals: u8,
monitor_supply: bool
)
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

**Purpose:**
- Initialize a new token type in the system
- Only admin has permission to execute
- Create and store token capabilities
**Implementation steps:**
1. Verify caller is admin
2. Register token for caller
3. Initialize token with basic parameters
4. Store capabilities in storage
### Mint Function
```rust
public fun mint<CoinType>(
sender: &signer,
amount: u64
)
```
**Purpose:**
- Create (mint) a quantity of tokens for an address
- Ensure mint limits and register tokens for recipient

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

**Implementation steps:**
1. Check mint amount doesn't exceed MAX_PER_MINT
2. Get mint capability from admin address
3. Mint new tokens
4. Check and register token for recipient if needed
5. Transfer minted tokens to recipient's account
## Role in Lending Platform
- **Token Management:** Serves as the foundation for creating and managing tokens used in
the platform
- **Security:** Ensures only admin can initialize tokens and manage capabilities
- **Supply Control:** Limits the amount of tokens minted each time to ensure safety
- **Automation:** Automatically registers tokens for users when necessary
## Usage Example
```rust
// Initialize WBTC token
intialize<WBTC>(
admin_signer,
string::utf8(b"Wrapped Bitcoin"),
string::utf8(b"WBTC"),
8,
true
);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Mint WBTC for an address
mint<WBTC>(user_signer, 50_000);
```
## Full Code
```rust
module movement::all_tokens {
use aptos_framework::coin;
use aptos_framework::managed_coin;
use std::signer;
use std::string;
use movement::errors;
use movement::utils;
// Constants
const MAX_PER_MINT: u64 = 100_000;
struct WBTC has key, store {}
struct WETH has key, store {}
struct Cap<phantom CoinType> has key {
mint_cap: coin::MintCapability<CoinType>,
freeze_cap: coin::FreezeCapability<CoinType>,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

burn_cap: coin::BurnCapability<CoinType>,
}
public entry fun intialize<CoinType>(
sender: &signer,
name: string::String,
symbol: string::String,
decimals: u8,
monitor_supply: bool
){
assert!(utils::is_admin(sender), errors::get_e_not_admin());
managed_coin::register<CoinType>(sender);
let (burn_cap, freeze_cap, mint_cap) = coin::initialize<CoinType>(
sender,
name,
symbol,
decimals,
monitor_supply
);
move_to(sender, Cap<CoinType>{
mint_cap,
freeze_cap,
burn_cap
});
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public fun mint<CoinType>(
sender: &signer,
amount: u64
) acquires Cap {
assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
let minted_coins = coin::mint<CoinType>(amount, &cap.mint_cap);
if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
managed_coin::register<CoinType>(sender);
};
coin::deposit<CoinType>(signer::address_of(sender), minted_coins);
}
}
```
# Utils & Errors Handling
## Detailed Guide on Errors and Utils Modules in Movement Platform
## 1. Module movement::errors
This module plays a crucial role in managing and handling errors in the system. Centralizing
error management makes the code easier to maintain and debug.
### 1.1 Error Code Definition and Management

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Error codes are defined in hexadecimal format, making them easy to categorize and extend:
```rust
// Errors related to token minting
const E_MINT_BEYOND: u64 = 0x00001; // Minting amount exceeds allowed limit
const E_INVALID_ADDRESS: u64 = 0x00002; // Invalid wallet address
const E_NOT_ADMIN: u64 = 0x00003;
// User does not have admin privileges
```
### 1.2 Getter Functions and Usage
The module provides getter functions to safely retrieve error codes:
```rust
// Public getter functions for error codes
public fun get_e_not_admin(): u64
public fun get_e_mint_beyond(): u64
public fun get_e_invalid_address(): u64
```
**Purpose and Benefits:**
- Provides a unified interface to access error codes, avoiding hardcoding
- Makes code easier to maintain and upgrade when error codes need to be changed
- Centralizes error management in one place, making tracking and debugging easier
- Ensures consistency in error handling across the codebase

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

**Usage Guide:**
```rust
// Example 1: Check admin privileges
if (!is_admin(sender)) {
abort errors::get_e_not_admin()
};
// Example 2: Check mint limit with custom error message
assert!(
amount <= MAX_MINT_AMOUNT,
errors::get_e_mint_beyond()
);
```
## 2. Module movement::utils
The utils module provides utilities and helper functions frequently used in the platform.
Centralizing utility functions helps maintain DRY (Don't Repeat Yourself) principles and
improves maintainability.
### 2.1 Admin Address Management
Function to retrieve and validate admin address:
```rust
// Returns the platform's admin address
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public fun admin_address(): address {
@movement // Address is hardcoded to ensure security
}
```
- Returns the admin address (@movement) - this address is used for permission management
- Used to verify permissions and access important system capabilities
- Ensures consistency when accessing admin address across the codebase
### 2.2 Admin Verification
Function to check admin privileges:
```rust
// Check if a signer is an admin
public fun is_admin(sender: &signer): bool {
signer::address_of(sender) == @movement
}
```
- Checks if the caller is an admin through their address
- Compares the sender's address with the defined admin address
- Used before important operations requiring admin privileges
## 3. Platform Integration Guide
### 3.1 Verification and Access Control
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Example of using modules in functions requiring admin privileges:
```rust
public fun mint_tokens(sender: &signer, amount: u64) {
// Check admin privileges
assert!(utils::is_admin(sender), errors::get_e_not_admin());
// Check mint limit
assert!(amount < MAX_PER_MINT, errors::get_e_mint_beyond());
// Continue with mint logic if conditions are met
// ...
}
```
### 3.2 Accessing Capabilities
Example of using admin address to access capabilities:
```rust
// Get capability from admin address to perform important operations
let cap = borrow_global<Cap<CoinType>>(utils::admin_address());
// Use capability to perform operation
do_something_with_cap(cap);
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### 3.3 Best Practices in Error Handling
```rust
public fun transfer_tokens(
sender: &signer,
recipient: address,
amount: u64
){
// Check valid address
assert!(recipient != @0x0, errors::get_e_invalid_address());
// Check amount
assert!(amount > 0, errors::get_e_invalid_amount());
// Perform transfer if all conditions are ok
// ...
}
```
## 4. Benefits and Best Practices
1. **Code Centralization and Management**
- Error codes are centrally managed in one place, easy to maintain
- Easy to add/modify new error codes without affecting existing code
- Admin logic is centralized in utils, ensuring consistency
- Reduces code duplication and increases reusability
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

2. **Enhanced Security**
- Consistent admin privilege checking across the codebase
- Clear error codes that can be easily tracked and debugged
- Capability pattern ensures only admin can perform important operations
- Validation is performed systematically
3. **Extensibility and Maintainability**
- Easy to add new error codes as the platform grows
- Utils can be extended with new utility functions without affecting existing code
- Easy to update error handling logic when needed
- Code is highly modular, easy to test and maintain
# Initialize & Managed Lending Pool
## Pool Module Guide - Lending & Borrowing Platform
## 1. Pool Structure
### 1.1 Pool Struct
```rust
struct Pool<phantom CoinType> has key, store {
token: coin::Coin<CoinType>,
// Token stored in the pool
borrowed_amount: u64,
// Total tokens borrowed
deposited_amount: u64,
// Total tokens deposited
supply_rate: u64,
// Interest rate for depositors
borrow_rate: u64,
// Lending interest rate
supply_index: u64,
// Accumulation index for depositors
borrow_index: u64,
// Accumulation index for borrowers
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

updated_at: u64

// Last update timestamp

}
```
## 2. Core Functions
### 2.1 Pool Initialization
```rust
public entry fun inititial<CoinType>(
sender: &signer,
supply_rate_init: u64,
borrow_rate_init: u64
)
```
- Only admin has permission to initialize pool
- Set initial interest rates for depositors and borrowers
- Initialize initial indices to 1
### 2.2 Token Deposit
```rust
public entry fun deposit<CoinType>(sender: &signer, amount: u64)
```
- Withdraw token from user wallet
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Deposit into pool
- Update total deposited tokens
```rust
public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
let coins = coin::withdraw<CoinType>(sender, amount);
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
coin::deposit<CoinType>(signer::address_of(sender), coins);
pool.deposited_amount = pool.deposited_amount + amount;
}
```
Let's analyze each line of the deposit function:
**1. Function declaration:**
```rust
public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool
```
- Public function can be called from outside the module
- Parameters include sender and token amount
- acquires Pool: indicates function will access Pool resource
**2. Withdraw tokens from user wallet:**
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let coins = coin::withdraw<CoinType>(sender, amount);
```
- Use withdraw function from coin module to withdraw tokens from user wallet
**3. Get Pool reference:**
```rust
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
```
- Get mutable reference to Pool stored at admin address
**4. Deposit tokens into Pool:**
```rust
coin::deposit<CoinType>(signer::address_of(sender), coins);
```
- Use deposit function to send tokens to Pool
**5. Update amount:**
```rust
pool.deposited_amount = pool.deposited_amount + amount;
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Update total tokens deposited in Pool
### 2.3 Token Withdrawal
```rust
public entry fun withdraw<CoinType>(sender: &signer, amount: u64)
```
- Withdraw tokens from pool
- Transfer to user wallet
- Update to decrease deposited tokens
```rust
public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
let coins = coin::extract<CoinType>(&mut pool.token, amount);
coin::deposit<CoinType>(signer::address_of(sender), coins);
pool.deposited_amount = pool.deposited_amount - amount;
}
```
**1. Function declaration:**
```rust
public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Public function can be called from outside module
- Takes 2 parameters: sender (withdrawer) and amount (withdrawal amount)
- acquires Pool: indicates function will access Pool resource
**2. Get Pool reference:**
```rust
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
```
- Get mutable reference to Pool stored at admin address
**3. Withdraw tokens from Pool:**
```rust
let coins = coin::extract<CoinType>(&mut pool.token, amount);
```
- Use extract function to take required amount of tokens from Pool
**4. Transfer tokens to user wallet:**
```rust
coin::deposit<CoinType>(signer::address_of(sender), coins);
```
- Use deposit function to transfer tokens to withdrawer's wallet
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

**5. Update Pool balance:**
```rust
pool.deposited_amount = pool.deposited_amount - amount;
```
- Decrease total tokens deposited in Pool.deposited_amount - amount;
### 2.4 Token Borrowing
```rust
public entry fun borrow<CoinType>(sender: &signer, amount: u64)
```
- Check and register token for borrower if needed
- Withdraw tokens from pool and transfer to borrower
- Update to increase borrowed token amount
```rust
Let's analyze each step of the borrow function:
```
**1. Function declaration:**
```rust
public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
- Public function can be called from outside the module
- Takes borrower (sender) and desired borrow amount (amount) as parameters
- acquires Pool: indicates function will access Pool resource
**2. Get Pool reference:**
```rust
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
```
- Get mutable reference to Pool at admin address
**3. Withdraw tokens from Pool:**
```rust
let coins = coin::extract<CoinType>(&mut pool.token, amount);
```
- Use extract function to take required amount of tokens from Pool
**4. Check and register token for borrower:**
```rust
if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
managed_coin::register<CoinType>(sender);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

};
```
- Check if borrower's account is registered for the token
- If not, register the token for them
**5. Transfer tokens to borrower:**
```rust
coin::deposit<CoinType>(signer::address_of(sender), coins);
```
- Transfer withdrawn tokens to borrower's wallet
**6. Update Pool balance:**
```rust
pool.borrowed_amount = pool.borrowed_amount + amount;
```
### 2.5 Token Repayment
```rust
public entry fun repay<CoinType>(account: &signer, amount: u64)
```
- Withdraw tokens from user wallet
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Return to pool
- Update to decrease debt amount
```rust
Let's analyze each line of code in the repay function:
```
**1. Function declaration:**
```rust
public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool
```
- Public function can be called from outside module
- Takes 2 parameters: account (repayer) and amount (repayment amount)
- acquires Pool: indicates function will access Pool resource
**2. Get Pool reference:**
```rust
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
```
- Get mutable reference to Pool stored at admin address
**3. Withdraw tokens from user wallet:**

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
let coins = coin::withdraw<CoinType>(account, amount);
```
- Withdraw required tokens from repayer's wallet
**4. Deposit tokens to Pool:**
```rust
coin::merge<CoinType>(&mut pool.token, coins);
```
- Merge withdrawn tokens into Pool
**5. Update Pool balance:**
```rust
pool.deposited_amount = pool.deposited_amount + amount;
```
## FullCode
```rust
module movement::pool {
use movement::utils;
use movement::errors;

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

use aptos_framework::timestamp;
use aptos_framework::coin;
use aptos_framework::managed_coin;
use std::signer;
struct Pool<phantom CoinType> has key, store {
token: coin::Coin<CoinType>,
borrowed_amount: u64,
deposited_amount: u64,
supply_rate: u64,
borrow_rate: u64,
supply_index: u64,
borrow_index: u64,
updated_at: u64
}
public entry fun inititial<CoinType>(
sender: &signer,
supply_rate_init: u64,
borrow_rate_init: u64
){
assert!(utils::is_admin(sender), errors::get_e_not_admin());
move_to(sender, Pool<CoinType>{
token: coin::zero<CoinType>(),
borrowed_amount: 0,
deposited_amount: 0,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

supply_rate: supply_rate_init,
borrow_rate: borrow_rate_init,
supply_index: 1,
borrow_index: 1,
updated_at: timestamp::now_microseconds()
});
}
public entry fun deposit<CoinType>(sender: &signer, amount: u64) acquires Pool {
let coins = coin::withdraw<CoinType>(sender, amount);
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
coin::deposit<CoinType>(signer::address_of(sender), coins);
pool.deposited_amount = pool.deposited_amount + amount;
}
public entry fun withdraw<CoinType>(sender: &signer, amount: u64) acquires Pool {
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
let coins = coin::extract<CoinType>(&mut pool.token, amount);
coin::deposit<CoinType>(signer::address_of(sender), coins);
pool.deposited_amount = pool.deposited_amount - amount;
}
public entry fun borrow<CoinType>(sender: &signer, amount: u64) acquires Pool {
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
let coins = coin::extract<CoinType>(&mut pool.token, amount);
if (!coin::is_account_registered<CoinType>(signer::address_of(sender))) {
managed_coin::register<CoinType>(sender);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

};
coin::deposit<CoinType>(signer::address_of(sender), coins);
pool.borrowed_amount = pool.borrowed_amount + amount;
}
public entry fun repay<CoinType>(account: &signer, amount: u64) acquires Pool {
let pool = borrow_global_mut<Pool<CoinType>>(utils::admin_address());
let coins = coin::withdraw<CoinType>(account, amount);
coin::merge<CoinType>(&mut pool.token, coins);
pool.deposited_amount = pool.deposited_amount + amount;
}
}
```
# Insight into Non-Fungible Tokens
# Understanding NFTs: Digital Assets on the Blockchain
> NFTs, or Non-Fungible Tokens, represent a revolutionary concept in the digital world. These
unique digital assets exist on blockchain technology, offering a new way to own and trade digital
content.
>
## Key Features of NFTs
- Uniqueness: Each NFT is one-of-a-kind, distinguishable from all others.
- Digital Ownership: NFTs provide verifiable ownership of digital assets.
- Blockchain-based: They leverage blockchain technology for security and transparency.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Diverse Applications: NFTs can represent art, collectibles, virtual real estate, and more.
## The NFT Creation Process
NFT creation, often called "minting," involves several steps:
1. Asset Creation: Artists or creators develop unique digital content.
2. Blockchain Integration: The digital asset is linked to a blockchain, typically Movement.
3. Smart Contract Development: Creators establish rules for the NFT's behavior and attributes.
4. Minting: The NFT is officially created on the blockchain, ready for sale or transfer.
## The Value Proposition of NFTs
NFTs offer several advantages in the digital economy:
- Authenticity: Blockchain verification ensures the genuineness of each asset.
- Scarcity: Limited editions or unique pieces can drive value.
- Royalties: Smart contracts can ensure creators receive ongoing royalties from secondary
sales.
- Community Building: NFT projects often foster engaged communities around shared interests.
## Challenges and Considerations
While NFTs present exciting opportunities, they also face challenges:
- Environmental Concerns: Some blockchain networks consume significant energy.
- Market Volatility: NFT valuations can be highly speculative and unstable.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Intellectual Property Issues: Questions around copyright and ownership rights persist.
- Technological Barriers: Understanding and using NFTs can be complex for newcomers.
## The Future of NFTs
As the technology evolves, NFTs are expanding beyond digital art into areas like gaming, virtual
real estate, and identity verification. Their potential to revolutionize digital ownership and
creative economies continues to grow, making them a fascinating area to watch in the coming
years.
# Collection
## Digital Assets Demystified: Revolutionary Approach to NFTs
The Aptos framework provides a new approach to Digital Assets, revolutionizing the creation
and management of collections and Non-Fungible Tokens.
By leveraging the power of Objects that we've explored in the previous section (Here), we can
create objects containing distinct components of an NFT collection. This change compared to
traditional models enhances the system's flexibility and allows for more adaptable control of
components.
The object-oriented framework in Aptos brings several advantages:
- High flexibility: Developers can easily customize NFTs for specific use cases.
- Improved discoverability: The unique address of each object simplifies asset tracking and
interaction.
- Scalability: The system efficiently handles complex NFT structures.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

For those unfamiliar with Aptos' object model, our detailed Object modules provide an excellent
introduction to this groundbreaking approach in blockchain technology.
`Collection` - A set of NFTs with a name and a bit of context for the group.
```rust
#[resource_group_member(#[group = 0x1::object::ObjectGroup])]
struct Collection has key {
creator: address,
description: String,
name: String,
uri: String,
​
​
mutation_events: event::EventHandle<collection::MutationEvent>
}
```
To create a Collection with the Aptos framework, we have several different methods. Here are
some predefined functions to initialize a collection through `aptos_token_objects`.
To use this library, you need to `import` it into the `Move.toml` file.
```toml
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
- Complete `Move.toml` file contents.
```toml
[package]
name = "developer_portal"
version = "1.0.0"
authors = ["Movement Foundation"]
license = "MIT"
[addresses]
movement = "0x1"
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosTokenObjects]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token-objects"
[dev-dependencies]
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
## Why Objects Are Useful
In reality, a user (account) can own one or multiple different collections. Using Objects to store
Collections separately will help manage them more effectively and efficiently.
Furthermore, after creating Tokens, we know that these tokens may not necessarily belong to
the collection owner but can be owned by anyone. With the use of objects, transferring, buying,
selling, and managing these tokens will be easier and more flexible than ever before.
![image.png](/content-images/Collection/image.png)
### Initializing an object through the collection library
```rust
module movement::nft_factory {
use aptos_token_objects::collection;
use std::string::utf8;
use std::option;
fun init_module(creator: &signer, max_supply: u64) {
let royalty = option::none();
collection::create_fixed_collection(
creator,
utf8(b"My Collection Description"),
max_supply,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

utf8(b"My Collection"),
royalty,
utf8(b"https://mycollection.com"),
);
}
}
```
After initializing the module, we'll attempt to create a collection by `publish`ing this module
through the CLI:
```rust
aptos move publish
```
After completing this process, check the transaction details on the explorer:
![image.png](/content-images/Collection/image%201.png)
Through the `create_fixed_collection` function, we've initialized an `object` owned by the creator
who initiated and possesses the object. We've also generated an `addr` of
`0xa71c541d8f6022e60423d84a6cd5c0c76f898586933204f3521ab5f8f89bae86`. This address
represents both the object's location and the `address owner` of the Collection.
![image.png](/content-images/Collection/image%202.png)
The second resource initialized is a Collection that we defined in the Function.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

# Token Standard & Mint your NFT
## Create a Non-Function Token
After creating a collection, which is a set of NFTs, the next step we need to take is undoubtedly
to create the NFTs belonging to the Collection that we initiated in the previous topic.
Similar to Collections, NFTs are also objects stored separately, and actions performed on NFTs
will not affect the Collection.
```rust
let token_constructor_ref = token::create_named_token(
creator,
string::utf8(COLLECTION_NAME),
string::utf8(COLLECTION_DESCRIPTION),
token_name,
option::none(),
string::utf8(TOKEN_URI),
);
```
There are multiple ways to initialize an NFT with different types, but in this tutorial, we'll simplify
the process by using the `create_named_token` function to create an NFT through the
Collection name.
Since we'll reuse `Collection Name`, `Collection Description`, and other data in this function,
we'll convert these pieces of information into `constant` values for reusability:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
module movement::nft_factory {
use aptos_token_objects::collection;
use aptos_token_objects::token::{Self, Token};
use aptos_framework::object;
use std::string::{utf8, String};
use std::option;
use std::signer;
const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens
Collection";
const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
const MAX_SUPPLY: u64 = 10_000;
​

​
fun init_module(creator: &signer) {
let royalty = option::none();
collection::create_fixed_collection(
creator,
utf8(COLLECTION_DESCRIPTION),
MAX_SUPPLY,
utf8(COLLECTION_NAME),
royalty,
utf8(COLLECTION_URI),
);
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public entry fun mint_nft(creator: &signer, token_name: String) {
let constructor_ref = token::create_named_token(
creator,
utf8(COLLECTION_NAME),
utf8(COLLECTION_DESCRIPTION),
token_name,
option::none(),
utf8(COLLECTION_URI)
);
let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
object::transfer(creator, token_object, signer::address_of(creator));
}
}
```
Similar to the previous topic, we will publish the package. After publishing, we already have the
Object Collection in the account. Now, let's try to create an NFT using the `mint_nft` function.
```rust
movement move run --function-id 'default::nft_factory::mint_nft' --args string:Hello
```
After successful execution, let's examine our account on the Movement explorer:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

In addition to Core Objects and Collection Objects, we'll find several new objects, including
`TokenIdentifiers`, `Token`, and another Object we should pay attention to: `ConcurrentSupply`.
### ConcurrentSupply
![image.png](/content-images/Token%20Standard%20&%20Mint%20your%20NFT/image.png)
This provides information about the total supply of the collection and the number of tokens
currently circulating in the market.
### TokenIdentifiers
![image.png](/content-images/Token%20Standard%20&%20Mint%20your%20NFT/image%201.
png)
This will contain the name of the NFT that we initialized through the CLI.
### Token
![image.png](/content-images/Token%20Standard%20&%20Mint%20your%20NFT/image%202.
png)
This is the Object Token containing the information of the `Token`
# Token Metadata & Modifying Data
## Summary

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Token Metadata creation and modification for NFTs on Aptos blockchain
- Use of `create_named_token` function to initialize TokenObjects
- Creation of custom NFT using `Object Group Member` with user-defined fields
- Process of initializing and transferring tokens to object's signer
- Implementation of `mint_nft` function for token creation
- Storage and usage of `mutator_ref` for updating token metadata
- Example of updating token description using `update_token_description` function
## Overview
In the previous lesson, we successfully initialized a collection and token, but here you can see
that we use `create_named_token` to initialize a TokenObjects, and the fields here are
predefined and we can only pass in the Token Name.
So in order to customize an NFT according to our wishes, we need to initialize another
Resource and store it in the token Object that was initialized from the `create_named_token`
function
## Create a Token Metadata
Here, we'll create a custom NFT using an `Object Group Member` with fields that you can define
according to your needs.
```rust
struct MovementPepeMeme has key {
name: String,
uri: String,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

description: String,
}
```
Here's an example of an NFT meme token with three simple fields. In practice, you can
customize it according to your needs.
Next, we'll initialize a token:
```rust
let movement_meme = MovementPepeMeme {
name: token_name,
uri,
description
};
```
The `name`, `uri`, and `description` are parameters passed from outside.
Since `create_named_object` returns a ConstructorRef, we need to create a `signer` from the
object to store this NFT, transfer it to the signer, or use it for future transfers:
```rust
let token_signer = object::generate_signer(&constructor_ref);
```
Then we simply transfer it to the object's `signer`, similar to what we learned in the objects topic.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
let token_signer = object::generate_signer(&constructor_ref);
let movement_meme = MovementPepeMeme {
name: token_name,
uri,
description
};
move_to(&token_signer, movement_meme);
```
After completing the code, your implementation should look like this:
```rust
module movement::nft_factory {
use aptos_token_objects::collection;
use aptos_token_objects::token::{Self, Token};
use aptos_framework::object;
use std::string::{utf8, String};
use std::option;
use std::signer;
const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens
Collection";
const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

const MAX_SUPPLY: u64 = 10_000;
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementPepeMeme has key {
name: String,
uri: String,
description: String,
}
fun init_module(creator: &signer) {
let royalty = option::none();
collection::create_fixed_collection(
creator,
utf8(COLLECTION_DESCRIPTION),
MAX_SUPPLY,
utf8(COLLECTION_NAME),
royalty,
utf8(COLLECTION_URI),
);
}
public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String)
{
let constructor_ref = token::create_named_token(
creator,
utf8(COLLECTION_NAME),
utf8(COLLECTION_DESCRIPTION),
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

token_name,
option::none(),
utf8(COLLECTION_URI)
);
let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
let token_signer = object::generate_signer(&constructor_ref);
let movement_meme = MovementPepeMeme {
name: token_name,
uri,
description
};
move_to(&token_signer, movement_meme);
object::transfer(creator, token_object, signer::address_of(creator));
}
}
```
Next, we'll initialize the NFT through publishing the package and then call the `mint_nft` function
via the CLI as follows:
```rust
movement run --function-id
'0x8e4ad880c961f094f149993b3f83ac9eace3dd7ab8cedca7d0a4266b8de6aff7::nft_factory::min
t_nft' --args string:Hello string:link string:desc --profile default
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

After the successful execution, we can verify the results on the explorer. We'll find a new
Resource added:
![image.png](/content-images/Token%20Metadata%20&%20Modifying%20Data/image.png)
## Modify Token Metadata
We've successfully created an NFT with custom metadata. Now, how can we modify or update
this metadata?
This process is similar to working with Objects, as NFTs are essentially objects we've studied in
previous topics.
To modify metadata, we need to create a `mutator_ref` from the Token's `constructor` and store
it somewhere. In this example, we'll store it directly on the Resource:
```rust
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct MovementPepeMeme has key {
name: String,
uri: String,
description: String,
mutator_ref: token::MutatorRef
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Next, initialize the `mutator_ref` and store it in the resource:
```rust
public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String) {
let constructor_ref = token::create_named_token(
creator,
utf8(COLLECTION_NAME),
utf8(COLLECTION_DESCRIPTION),
token_name,
option::none(),
utf8(COLLECTION_URI)
);
let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
let token_signer = object::generate_signer(&constructor_ref);
let mutator_ref = token::generate_mutator_ref(&constructor_ref);
let movement_meme = MovementPepeMeme {
name: token_name,
uri,
description,
mutator_ref
};
move_to(&token_signer, movement_meme);
object::transfer(creator, token_object, signer::address_of(creator));
}
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Then we can use the mutator_ref to update the Token and Metadata:
```rust
public entry fun update_token_description(creator: &signer, collection: String, name: String,
description: String) acquires MovementPepeMeme {
let (meme_obj, meme) = get_meme(
&signer::address_of(creator),
&collection,
&name,
);
let creator_addr = token::creator(meme_obj);
assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
token::set_description(&meme.mutator_ref, description);
}
inline fun get_meme(creator: &address, collection: &String, name: &String):
(Object<MovementPepeMeme>, &MovementPepeMeme) {
let token_address = token::create_token_address(
creator,
collection,
name,
);
(object::address_to_object<MovementPepeMeme>(token_address),
borrow_global<MovementPepeMeme>(token_address))
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
### Full Code
```rust
module movement::nft_factory {
use aptos_token_objects::collection;
use aptos_token_objects::token::{Self, Token};
use aptos_framework::object::{Self, Object};
use std::string::{utf8, String};
use std::option;
use std::signer;
const COLLECTION_DESCRIPTION: vector<u8> = b"Movement Non-Fungible Tokens
Collection";
const COLLECTION_NAME: vector<u8> = b"Movement NFT Collection";
const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz";
const MAX_SUPPLY: u64 = 10_000;
const ENOT_CREATOR: u64 = 0;
struct MovementPepeMeme has key {
name: String,
uri: String,
description: String,
mutator_ref: token::MutatorRef
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public entry fun create_collection(creator: &signer) {
let royalty = option::none();
collection::create_fixed_collection(
creator,
utf8(COLLECTION_DESCRIPTION),
MAX_SUPPLY,
utf8(COLLECTION_NAME),
royalty,
utf8(COLLECTION_URI),
);
}
public entry fun mint_nft(creator: &signer, token_name: String, uri: String, description: String)
{
let constructor_ref = token::create_named_token(
creator,
utf8(COLLECTION_NAME),
utf8(COLLECTION_DESCRIPTION),
token_name,
option::none(),
utf8(COLLECTION_URI)
);
let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
let token_signer = object::generate_signer(&constructor_ref);
let mutator_ref = token::generate_mutator_ref(&constructor_ref);
move_to(&token_signer, MovementPepeMeme {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

name: token_name,
uri,
description,
mutator_ref
});
object::transfer(creator, token_object, signer::address_of(creator));
}
public entry fun update_meme_description(creator: &signer, collection: String, name: String,
description: String) acquires MovementPepeMeme {
let (meme_obj, meme) = get_meme(
&signer::address_of(creator),
&collection,
&name,
);
let creator_addr = token::creator(meme_obj);
assert!(creator_addr == signer::address_of(creator), ENOT_CREATOR);
token::set_description(&meme.mutator_ref, description);
}
inline fun get_meme(creator: &address, collection: &String, name: &String):
(Object<MovementPepeMeme>, &MovementPepeMeme) {
let token_address = token::create_token_address(
creator,
collection,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

name,
);
(object::address_to_object<MovementPepeMeme>(token_address),
borrow_global<MovementPepeMeme>(token_address))
}
}
```# Creating NFTs using Resource Accounts
## Summary
- Resource accounts in Aptos enable programmatic control of assets and actions.
- The process involves setting up a resource account, storing account information, and creating
an NFT collection.
- A CollectionConfig struct is used to manage collection details.
- The create_collection function combines all steps to set up the NFT collection.
- A mint function allows for creating and transferring NFTs within the collection.
- This approach allows for autonomous management of NFTs in decentralized applications.
# Option 1: Create a new Resource account
### Step 1: Understanding Resource Accounts
Resource accounts in Aptos are a powerful feature that allows for the creation of accounts that
can be programmatically controlled. They're particularly useful for creating decentralized
applications (dApps) that need to manage assets or perform actions autonomously.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

### Step 2: Setting Up the Resource Account
To create an NFT collection using a resource account, we first need to set up the account and
generate a signer. Here's how we do it:
```rust
use aptos_framework::account::{Self, SignerCapability, create_resource_account,
create_signer_with_capability};
// Create the resource account
let (resource, resource_cap) = create_resource_account(account, seeds);
// Generate a signer from the resource account
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
```
In this code:
- `create_resource_account` creates a new resource account and returns the account address
and a capability to generate signers for it.
- `create_signer_with_capability` uses the capability to create a signer for the resource account.
### Step 3: Storing the Resource Account Information
Next, we'll store the resource account information in a custom struct:
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

struct ResourceInfo has key {
source: address,
resource_cap: SignerCapability
}
move_to&lt;ResourceInfo&gt;(&resource_signer_from_cap, ResourceInfo {
source: account_addr,
resource_cap: resource_cap
});
```
This step is crucial because it allows us to retrieve the signer capability later when we need to
perform actions on behalf of the resource account.
### Step 4: Creating the NFT Collection
Now that we have our resource account set up, we can create the NFT collection:
```rust
collection::create_fixed_collection(
&resource_signer_from_cap,
collection_description,
collection_maximum,
collection_name,
option::none(),
collection_uri,
);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```
This function creates a new collection with a fixed number of tokens. The resource account is
the owner of this collection.
### Step 5: Defining the Collection Configuration
To keep track of our collection's details, we'll create a `CollectionConfig` struct:
```rust
struct CollectionConfig has key {
collection_name: String,
collection_description: String,
collection_maximum: u64,
collection_uri: String,
token_counter: u64,
token_base_name: String,
token_description: String,
}
```
This struct will store all the necessary information about our collection, including details for
individual tokens.
### Step 6: Implementing the Collection Creation Function
Now, let's put it all together in a function that creates the collection:
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
public entry fun create_collection(
account: &signer,
collection_name: String,
collection_description: String,
collection_uri: String,
collection_maximum: u64,
token_base_name: String,
token_description: String,
seeds: vector&lt;u8&gt;
){
let (resource, resource_cap) = create_resource_account(account, seeds);
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
let account_addr = signer::address_of(account);
move_to(&resource_signer_from_cap, ResourceInfo {
source: account_addr,
resource_cap: resource_cap
});
move_to(&resource_signer_from_cap, CollectionConfig {
collection_name,
collection_description,
collection_maximum,
collection_uri,
token_counter: 0,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

token_base_name,
token_description,
});
collection::create_fixed_collection(
&resource_signer_from_cap,
collection_description,
collection_maximum,
collection_name,
option::none(),
collection_uri,
);
}
```
This function combines all the previous steps to create a resource account, set up the collection
configuration, and create the actual NFT collection.
### Step 7: Minting NFTs
Finally, let's implement a function to mint NFTs within our collection:
```rust
public entry fun mint(
nft_claimer: &signer,
collection_address: address,
token_name: String,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

token_uri: String
) acquires ResourceInfo, CollectionConfig {
let nft_claimer_addr = signer::address_of(nft_claimer);
let collection_config = borrow_global_mut&lt;CollectionConfig&gt;(collection_address);
let resource_info = borrow_global_mut&lt;ResourceInfo&gt;(collection_address);
let resource_signer_from_cap =
account::create_signer_with_capability(&resource_info.resource_cap);
let constructor_ref = token::create_named_token(
&resource_signer_from_cap,
collection_config.collection_name,
collection_config.collection_description,
token_name,
option::none(),
token_uri
);
let token_object = object::object_from_constructor_ref&lt;Token&gt;(&constructor_ref);
object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
}
```
This function does the following:
- Retrieves the collection configuration and resource info.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Creates a new token within the collection.
- Transfers the newly created token to the claimer's address.
### Fullcode
```rust
module movement::mint_nft_by_resource_account {
use std::string::{Self, String};
use aptos_token_objects::collection;
use aptos_token_objects::token::{Self, Token};
use aptos_framework::object;
use std::signer;
use std::option;
use aptos_framework::account::{Self, SignerCapability, create_resource_account,
create_signer_with_capability};
struct ResourceInfo has key {
source: address,
resource_cap: SignerCapability
}
struct CollectionConfig has key {
collection_name: String,
collection_description: String,
collection_maximum: u64,
collection_uri: String,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

token_counter: u64,
token_base_name: String,
token_description: String,
}
public entry fun create_collection(
account: &signer,
collection_name: String,
collection_description: String,
collection_uri: String,
collection_maximum: u64,
// Token
token_base_name: String,
token_description: String,
seeds: vector<u8>
){
let (resource, resource_cap) = create_resource_account(account, seeds);
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
let account_addr = signer::address_of(account);
// Token
move_to(&resource_signer_from_cap, ResourceInfo {
source: account_addr,
resource_cap: resource_cap
});
move_to(&resource_signer_from_cap, CollectionConfig {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

collection_name,
collection_description,
collection_maximum: collection_maximum,
collection_uri,
token_counter: 1,
// Token
token_base_name,
token_description,
});
collection::create_fixed_collection(
&resource_signer_from_cap,
collection_description,
collection_maximum,
collection_name,
option::none(),
collection_uri,
);
}
public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String,
token_uri: String) acquires ResourceInfo, CollectionConfig {
let nft_claimer_addr = signer::address_of(nft_claimer);
let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
let resource_info = borrow_global_mut<ResourceInfo>(collection_address);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let resource_signer_from_cap =
account::create_signer_with_capability(&resource_info.resource_cap);
let constructor_ref = token::create_named_token(
&resource_signer_from_cap,
collection_config.collection_name,
collection_config.collection_description,
token_name,
option::none(),
token_uri
);
let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
}
}
```
# Option 2: Publish/Mint to an Existing Resource Account
```rust
let (resource, resource_cap) = create_resource_account(account, seeds);
let resource_signer_from_cap = create_signer_with_capability(&resource_cap);
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

The function `account::create_resource_account` simply creates a new resource account, which
you can use to deploy or store data, NFTs, etc.
However, in some cases, you may need to deploy or publish a module, or mint NFTs in an
existing resource of another account. For this, we'll use the
`resource_account::retrieve_resource_account_cap` function from the aptos_framework:
```rust
const DEV: address = @dev;
let signer_cap = resource_account::retrieve_resource_account_cap(caller, DEV);
let resource_signer = account::create_signer_with_capability(&signer_cap);
```
Here, DEV is the address of the pre-existing resource account. In this example, let's create a
new resource account using the CLI:
```rust
movement account create-resource-account --seed "any-thing"
```
The result will be a resource account created from the CLI caller's account. In this case:
```rust
Transaction submitted:
https://explorer.aptoslabs.com/txn/0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a7
59755d9b3a0afbfb?network=devnet
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

{
"Result": {
"resource_account":
"f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31",
"transaction_hash":
"0xbfaad379aedfc64abe3cd95e941851c55892b1d2835749a759755d9b3a0afbfb",
"gas_used": 511,
"gas_unit_price": 100,
"sender": "1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97",
"sequence_number": 2,
"success": true,
"timestamp_us": 1729570392468682,
"version": 95355030,
"vm_status": "Executed successfully"
}
}
```
- resource address:
`f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31`
- source address:
`0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97`
To publish a module to the resource address, create a profile for it in the `./aptos/config.yaml`
file:
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

--profiles:
default:
network: Devnet
private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
public_key:
"0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
account: 1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97
rest_url: "https://fullnode.devnet.aptoslabs.com"
faucet_url: "https://faucet.devnet.aptoslabs.com"
resource:
network: Devnet
private_key: "0x9e8e8a0fb6089a4fefb865c8e159b0fd691083eddf7a263263a1f8a4f27e74e8"
public_key:
"0x93789f387574b4d17d84d9a3e49432d2d2ae2f3ba9eac1b47687c0adeec04eac"
account: f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
rest_url: "https://fullnode.devnet.aptoslabs.com"
faucet_url: "https://faucet.devnet.aptoslabs.com"
```
Note that the PrivateKey and PublicKey of these two profiles are identical; only the account
differs.
Next, modify the `Move.toml` file, changing the module's address to the resource account
address:
```rust
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

[package]
name = "movement"
version = "1.0.0"
authors = []
[addresses]
source_addr =
"0x1b298d10a8ed3b25e6c03aff2e046e1bf5c8e764bce39d9c9b4bcbc9479dcc97" // owner addr
movement = "f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31" //
resource addr
[dev-addresses]
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
[dependencies.AptosToken]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-token"
[dev-dependencies]
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

You can now run the command to publish the module to the resource account `movement =
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31`. If you encounter
a GAS error, run this CLI command to fund the `resource profile`:
```rust
movement account fund-with-faucet --account
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31 --amount
100000000
```
After funding, you can publish using this CLI command:
```rust
movement move publish --profile resource
```
or using sender account is `resource_address`
```rust
movement move publish --sender-account
f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31
```
If successful, check the modules of the `resource addr`
`f63618161394bc3d5554f30ee82ad049d716f9780c1d441e2c5bf76ddd516a31`. You should see
your module, its functions, and other data and resources.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

## Fullcode
```rust
module movement::mint_nft_by_resource_account {
use std::string::{Self, String};
use aptos_token_objects::collection;
use aptos_token_objects::token::{Self, Token};
use aptos_framework::resource_account;
use aptos_framework::object;
use std::signer;
use std::option;
use aptos_framework::account::{Self, SignerCapability, create_resource_account,
create_signer_with_capability};
struct ResourceInfo has key {
source: address,
resource_cap: SignerCapability
}
struct CollectionConfig has key {
collection_name: String,
collection_description: String,
collection_maximum: u64,
collection_uri: String,
token_counter: u64,
token_base_name: String,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

token_description: String,
}
const SOURCE_ADDR: address = @source_addr;
public entry fun create_collection(
account: &signer,
collection_name: String,
collection_description: String,
collection_uri: String,
collection_maximum: u64,
// Token
token_base_name: String,
token_description: String,
seeds: vector<u8>
){
let resource_cap_cap = resource_account::retrieve_resource_account_cap(caller,
SOURCE_ADDR);
let resource_signer = account::create_signer_with_capability(&resource_cap);
let account_addr = signer::address_of(account);
// Token
move_to(&resource_signer_from_cap, ResourceInfo {
source: account_addr,
resource_cap: resource_cap
});

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

move_to(&resource_signer_from_cap, CollectionConfig {
collection_name,
collection_description,
collection_maximum: collection_maximum,
collection_uri,
token_counter: 1,
// Token
token_base_name,
token_description,
});
collection::create_fixed_collection(
&resource_signer_from_cap,
collection_description,
collection_maximum,
collection_name,
option::none(),
collection_uri,
);
}
public entry fun mint(nft_claimer: &signer, collection_address: address, token_name: String,
token_uri: String) acquires ResourceInfo, CollectionConfig {
let nft_claimer_addr = signer::address_of(nft_claimer);
let collection_config = borrow_global_mut<CollectionConfig>(collection_address);
let resource_info = borrow_global_mut<ResourceInfo>(collection_address);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let resource_signer_from_cap =
account::create_signer_with_capability(&resource_info.resource_cap);
let constructor_ref = token::create_named_token(
&resource_signer_from_cap,
collection_config.collection_name,
collection_config.collection_description,
token_name,
option::none(),
token_uri
);
let token_object = object::object_from_constructor_ref<Token>(&constructor_ref);
object::transfer(&resource_signer_from_cap, token_object, nft_claimer_addr);
}
}
```
# Managed Collection
## Summary
- Introduces the concept of managing NFT collections and tokens using Aptos blockchain
- Explains the use of `Object` for storing token and collection data
- Demonstrates creation of custom structures for collection management
- Shows implementation of collection initialization and token minting functions
- Highlights the importance of tracking object addresses for collections and tokens
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

- Introduces a method to store and retrieve minted NFTs for each user
- Provides code examples for creating collections, minting tokens, and viewing token information
## Create NFT Collection & Manager
When using aptos_token and collection, all data and resources are stored as `Object`. This
makes our `token` much more flexible, but at the same time also makes management more
complex. In this section, we will use another resource together to manage these tokens and
collections effectively.
```rust
struct CreateNFTCollection has key {
collection_object: Object<collection::Collection>,
collection_name: String,
minting_enabled: bool,
mint_fee: u64
}
```
With this structure, we can store the initialization components and information of the Collection.
We can also add details like `admin` or other functions. However, in this example, I'll separate
the `admin` resource into a distinct resource to make changing the owner or admin of this
collection more flexible.
```rust
struct DataManager has key {
admin: address,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
```
Next, we'll complete the initialization of a collection. But first, we need to set the `admin` to
determine who has the authority to create collections.
```rust
fun init_module(resource_account: &signer) {
move_to(resource_account, DataManager {
admin: @movement
})
}
```
![image.png](/content-images/Managed%20Collection/image.png)
## Create Movement AptosCollection
Here, we'll use the account itself as the platform admin. Whenever someone initializes a
collection, they'll automatically become the admin of that collection.
```rust
public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
let admin_addr = signer::address_of(admin);
// Check if the collection already exists for the admin
// Abort if the MovementCollection already exists for the admin
assert!(!exists&lt;MovementCollection&gt;(admin_addr), 0);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

// Set the admin address in the CollectionManager
// Move the MovementCollection resource to the admin's account
let module_data = borrow_global_mut&lt;CollectionManager&gt;(@movement);
module_data.admin = admin_addr;
// Create a new collection object with specified parameters
let collection_object = aptos_token::create_collection_object(
admin,
// Creator
utf8(COLLECTION_DESCRIPTION),
// Description
1000,
// Max Supply
utf8(COLLECTION_NAME),
// Collection Name
utf8(COLLECTION_URI),
// Collection URI
true,
// mutable_description
true,
// mutable_royalty
true,
// mutable_uri
true,
// mutable_token_description
true,
// mutable_token_name
true,
// mutable_token_properties
true,
// mutable_token_uri
true,
// tokens_burnable_by_creator
true,
// tokens_freezable_by_creator
0,
// royalty_numerator
100,
// royalty_denominator
);
move_to(admin, MovementCollection {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

collection_object,
collection_name: utf8(COLLECTION_NAME),
minting_enabled: true,
mint_fee: 0
});
}
```
![image.png](/content-images/Managed%20Collection/image%201.png)
After initializing the Collection, we'll create tokens within the `collection`. Since we've stored the
`collection_name` in the MovementCollection Resource, we can easily access the user's global
data to retrieve this information through acquires.
```rust
public entry fun mint_nft(user: &signer) acquires MovementCollection {
let user_addr = signer::address_of(user);
let movement_collection = borrow_global&lt;MovementCollection&gt;(@movement);
aptos_token::mint_token_object(
user,
// Creator
movement_collection.collection_name, // Collection Name
utf8(b"Token Movement Description"), // Token Description
utf8(b"Token Movement Name"),
// Token Name
utf8(b"Token URI"),
// Token URI: `https://example.com/image.png`
vector[],
// Property Keys: vector<String>
vector[],
// Property Types: vector<String>
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

vector[]

// Property Values: vector<u8>

);
}
```
Here we have a `property` parameter, but we'll discuss it in later lessons. Returning to this
section, we notice an issue: we're creating `objects` but we don't know their addresses or
locations, similar to what we learned in the object lesson. We should store these object
addresses for future use.
```rust
struct MovementCollection has key {
collection_object: Object<AptosCollection>,
collection_address: address,
collection_name: String,
minting_enabled: bool,
mint_fee: u64
}
```
We're adding a `collection_address` field to store the object_address of the created collection.
We'll store it like this:
```rust
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
collection_object,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

collection_address,
collection_name: utf8(COLLECTION_NAME),
minting_enabled: true,
mint_fee: 0
});
```
This allows us to store the collection_address in the resources. We can also create a view
function to retrieve this `object` address:
```rust
#[view]
public fun get_collection_object_address(owner: address): address acquires
MovementCollection {
let movement_collection = borrow_global<MovementCollection>(owner);
object::create_object_address(&owner, COLLECTION_NAME)
}
```
After checking the `object` information, you'll see that it creates four different resources when
you call the `create_movement_collection` function:
![Screenshot 2024-10-15 at
15.54.09.png](/content-images/Managed%20Collection/Screenshot_2024-10-15_at_15.54.09.p
ng)

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

![Screenshot 2024-10-15 at
15.54.14.png](/content-images/Managed%20Collection/Screenshot_2024-10-15_at_15.54.14.p
ng)
![Screenshot 2024-10-15 at
15.54.18.png](/content-images/Managed%20Collection/Screenshot_2024-10-15_at_15.54.18.p
ng)
![Screenshot 2024-10-15 at
15.54.22.png](/content-images/Managed%20Collection/Screenshot_2024-10-15_at_15.54.22.p
ng)
## Create AptosToken
Similarly, when initializing AptosToken:
We'll use `create_object_address` to generate an address for storing the token_object. I'll add
another field to `MovementCollection` with the data type `table&lt;address,
vector&lt;address&gt;&gt;`. This allows me to track how many tokens a person has minted and
which tokens they are.
```rust
struct MovementCollection has key {
collection_object: Object<AptosCollection>,
collection_address: address,
collection_name: String,
minting_enabled: bool,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

mint_fee: u64,
minted_nfts: table::Table<address, vector<address>>,
}
```
When initializing the collection, I'll create a new `table`:
```rust
move_to(admin, MovementCollection {
collection_object,
collection_address,
collection_name: utf8(COLLECTION_NAME),
minting_enabled: true,
mint_fee: 0,
minted_nfts: table::new()
});
```
I'll change the `aptos_token::mint` function to `aptos_token::mint_token_object` so it returns an
object, which I'll use to create a named_address:
```rust
public entry fun mint_nft(user: &signer) acquires MovementCollection {
let user_addr = signer::address_of(user);
let movement_collection = borrow_global_mut<MovementCollection>(@movement);
if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
};
let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
let create_token_object = aptos_token::mint_token_object(
user,
movement_collection.collection_name,
utf8(b"Token Movement Description"),
utf8(b"Token Movement Name"),
utf8(b"Token URI"),
vector[],
vector[],
vector[]
);
let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
vector::push_back(nft_minted, token_address);
}
#[view]
public fun get_token_object(owner: address): vector<address> acquires MovementCollection {
let movement_collection = borrow_global<MovementCollection>(owner);
*table::borrow(&movement_collection.minted_nfts, owner)
}
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

With this view function, I can easily determine how many `AptosTokens` have been created and
which `tokens` they are.
![image.png](/content-images/Managed%20Collection/image%202.png)
## FullCode
```rust
module movement::nft_aptos_collection {
use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
use aptos_token_objects::token;
use aptos_token_objects::collection::{Self,Collection};
use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
use std::signer;
use std::table;
use std::option;
use std::string::{utf8, String};
use std::event;
use std::vector;
const COLLECTION_NAME: vector<u8> = b"Movement NFT";
const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
struct CollectionManager has key {
admin: address
}
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

struct MovementCollection has key {
collection_object: Object<AptosCollection>,
collection_address: address,
collection_name: String,
minting_enabled: bool,
mint_fee: u64,
minted_nfts: table::Table<address, vector<address>>,
}
#[event]
struct CreateMovementCollectionEvents has drop, store {
collection_address: address,
collection_name: String,
owner: address
}
fun init_module(resource_account: &signer) {
move_to(resource_account, CollectionManager {
admin: @movement
})
}
public entry fun create_movement_collection(admin: &signer) acquires CollectionManager {
let admin_addr = signer::address_of(admin);
assert!(!exists<MovementCollection>(admin_addr), 0);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let module_data = borrow_global_mut<CollectionManager>(@movement);
module_data.admin = admin_addr;
let collection_object = aptos_token::create_collection_object(
admin,
// Creator
utf8(COLLECTION_DESCRIPTION),
// Desciprtion
1000,
// Max Supply
utf8(COLLECTION_NAME),
// Collection Name
utf8(COLLECTION_URI),
// Collection Uri
true,
// mutable_description
true,
// mutable_royalty
true,
// mutable_uri
true,
// mutable_token_description
true,
// mutable_token_name
true,
// mutable_token_properties
true,
// mutable_token_uri
true,
// tokens_burnable_by_creator
true,
// tokens_freezable_by_creator
0,
// royalty_numerator
100,
// royatly_denominator
);
let collection_address = object::create_object_address(&admin_addr,
COLLECTION_NAME);
move_to(admin, MovementCollection {
collection_object,
collection_address,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

collection_name: utf8(COLLECTION_NAME),
minting_enabled: true,
mint_fee: 0,
minted_nfts: table::new()
});
event::emit(CreateMovementCollectionEvents {
collection_address,
collection_name: utf8(COLLECTION_NAME),
owner: admin_addr
});
}
#[view]
public fun get_collection_object_address(owner: address): address acquires
MovementCollection {
let movement_collection = borrow_global<MovementCollection>(owner);
object::create_object_address(&owner, COLLECTION_NAME)
}
public entry fun mint_nft(user: &signer) acquires MovementCollection {
let user_addr = signer::address_of(user);
let movement_collection = borrow_global_mut<MovementCollection>(@movement);
if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
table::add(&mut movement_collection.minted_nfts, user_addr,
vector::empty<address>());
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

};
let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
let create_token_object = aptos_token::mint_token_object(
user,
movement_collection.collection_name,
utf8(b"Token Movement Description"),
utf8(b"Token Movement Name"),
utf8(b"Token URI"),
vector[],
vector[],
vector[]
);
let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
vector::push_back(nft_minted, token_address);
}
#[view]
public fun get_token_object(owner: address): vector<address> acquires MovementCollection
{
let movement_collection = borrow_global<MovementCollection>(owner);
*table::borrow(&movement_collection.minted_nfts, owner)
}
}
```
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

# Royalty & Property Map
## Summary
- Royalties for NFT collections are defined using numerator and denominator values
- NFT properties are stored in a PropertyMap as key-value pairs
- Various functions are available for managing and querying PropertyMap data
- Specific functions exist for reading different data types from PropertyMap
- PropertyMap can be modified using add, update, and remove functions
## Royalty
In the previous topic, we used `aptos_token::create_collection` to initialize a collection, which
includes two parameters called `royalty`.
```rust
let collection_object = aptos_token::create_collection_object(
admin,
// Creator
utf8(COLLECTION_DESCRIPTION),
// Description
1000,
// Max Supply
utf8(COLLECTION_NAME),
// Collection Name
utf8(COLLECTION_URI),
// Collection Uri
true,
// mutable_description
true,
// mutable_royalty
true,
// mutable_uri
true,
// mutable_token_description
true,
// mutable_token_name
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

true,
true,
true,
true,
0,
100,

// mutable_token_properties
// mutable_token_uri
// tokens_burnable_by_creator
// tokens_freezable_by_creator
// royalty_numerator
// royalty_denominator

);
```
`royalty_numerator` and `royalty_denominator` define the royalty percentage for the NFT
collection. Specifically:
1. `royalty_numerator`: The royalty amount.
2. `royalty_denominator`: The total transaction amount.
The royalty percentage is calculated by dividing `royalty_numerator` by `royalty_denominator`.
In this example:
```rust
royalty_numerator = 0
royalty_denominator = 100
```
This results in a royalty percentage of 0/100 = 0%, meaning no royalties are applied to this
collection. To set a royalty percentage—for example, 2.5%—you could use:

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

```rust
royalty_numerator = 25
royalty_denominator = 1000
```
This creates a ratio of 25/1000 = 2.5%.
Using two separate values (instead of a simple decimal) allows for precise representation of
fractions without encountering issues with decimal precision in computers.
## Property
In the `mint_nft` function, we have three empty parameters:
```rust
let create_token_object = aptos_token::mint_token_object(
user,
movement_collection.collection_name,
utf8(b"Token Movement Description"),
utf8(b"Token Movement Name"),
utf8(b"Token URI"),
vector[],
vector[],
vector[]
);
```

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

Typically, an NFT contains additional metadata such as parameters, attributes, or any other
desired information.
Each NFT has a PropertyMap to store these properties, which are saved as key-value pairs:
```rust
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
/// A Map for typed key to value mapping, the contract using it
/// should keep track of what keys are what types, and parse them accordingly.
struct PropertyMap has drop, key {
inner: SimpleMap<String, PropertyValue>,
}
/// A typed value for the `PropertyMap` to ensure that typing is always consistent
struct PropertyValue has drop, store {
type: u8,
value: vector<u8>,
}
```
Based on this, we can create data pairs:
```rust
let create_token_object = aptos_token::mint_token_object(
user,
movement_collection.collection_name,
utf8(b"Token Movement Description"),
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

utf8(b"Token Movement Name"),
utf8(b"Token URI"),
vector[utf8(b"keys")],
vector[utf8(b"types")],
vector[b"value"]
);
```
## Additional Functions
### Key Functions for PropertyMap Management
| **Function** | **Description** | **Parameters** | **Return** |
| --- | --- | --- | --- |
| init | Initializes PropertyMap | ref: &ConstructorRef, container: PropertyMap | None |
| extend | Adds PropertyMap to object | ref: &ExtendRef, container: PropertyMap | None |
| burn | Removes entire property map | ref: MutatorRef | None |
| prepare_input | Prepares property container | keys: vector<String>, types: vector<String>,
values: vector<vector<u8>> | PropertyMap |
| generate_mutator_ref | Creates MutatorRef | ref: &ConstructorRef | MutatorRef |
### PropertyMap Query Functions
| **Function** | **Description** | **Parameters** | **Return** |
| --- | --- | --- | --- |
| contains_key | Checks for key | object: &Object<T>, key: &String | bool |
| length | Counts entries | object: &Object<T> | u64 |
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

| read | Retrieves BCS-encoded property | object: &Object<T>, key: &String | (String,
vector<u8>) |
### Type-Specific Read Functions
| **Function** | **Description** | **Parameters** | **Return** |
| --- | --- | --- | --- |
| read_bool | Retrieves boolean | object: &Object<T>, key: &String | bool |
| read_u8/u16/u32/u64/u128/u256 | Retrieves unsigned integer | object: &Object<T>, key:
&String | respective uint |
| read_address | Retrieves address | object: &Object<T>, key: &String | address |
| read_bytes | Retrieves byte vector | object: &Object<T>, key: &String | vector<u8> |
| read_string | Retrieves string | object: &Object<T>, key: &String | String |
### PropertyMap Modification Functions
| **Function** | **Description** | **Parameters** | **Return** |
| --- | --- | --- | --- |
| add | Adds BCS-encoded property | ref: &MutatorRef, key: String, type: String, value:
vector<u8> | None |
| add_typed | Adds non-BCS-encoded property | ref: &MutatorRef, key: String, value: T | None |
| update | Updates BCS-encoded property | ref: &MutatorRef, key: &String, type: String, value:
vector<u8> | None |
| update_typed | Updates non-BCS-encoded property | ref: &MutatorRef, key: &String, value: T |
None |
| remove | Deletes property | ref: &MutatorRef, key: &String | None |

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

# Permission to mint NFTs
## Summary
- Introduces the concept of ExtendRef to allow minting of NFTs by users
- Demonstrates how to initialize ExtendRef and store it in MovementCollection struct
- Shows implementation of a `mint_nft` function that allows anyone to mint NFTs
- Utilizes `ExtendRef` to create and transfer token objects to users
- Provides full code example of the NFT minting module in Rust
- Includes functions for creating collections, minting NFTs, and retrieving collection and token
addresses
## Create ExtendRef
In the previous topic, we helped the collection admin create a token. So how do we allow
everyone to mint these NFTs? Actually, we've learned this in the `object` section—it's about
initializing object abilities, specifically `ExtendRef` in this case.
In this example, we'll initialize ExtendRef and store it in MovementCollection:
```rust
struct MovementCollection has key {
collection_object: Object<AptosCollection>,
collection_address: address,
collection_name: String,
minting_enabled: bool,
mint_fee: u64,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

minted_nfts: table::Table<address, vector<address>>,
extend_ref: ExtendRef
}
```
Next, we'll initialize extend_ref in the `create_movement_collection` function:
```rust
let creator_constructor_ref = &object::create_object(admin_addr);
let extend_ref = object::generate_extend_ref(creator_constructor_ref);
let creator = &object::generate_signer_for_extending(&extend_ref);
let collection_address = object::create_object_address(&admin_addr, COLLECTION_NAME);
move_to(admin, MovementCollection {
collection_object,
collection_address,
collection_name: utf8(COLLECTION_NAME),
minting_enabled: true,
mint_fee: 0,
minted_nfts: table::new(),
extend_ref
});
```
## Open Minting to Everyone

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

After initializing `ExtendRef`, we can allow users to use it to create `NFT`s. In this example, we'll
allow everyone to mint NFTs:
```rust
public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
let user_addr = signer::address_of(user);
let movement_collection = borrow_global_mut<MovementCollection>(owner);
let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
table::add(&mut movement_collection.minted_nfts, user_addr, vector::empty<address>());
};
let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
let create_token_object = aptos_token::mint_token_object(
creator,
movement_collection.collection_name,
utf8(b"Token Movement Description"),
utf8(b"Token Movement Name"),
utf8(b"Token URI"),
vector[],
vector[],
vector[]
);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
vector::push_back(nft_minted, token_address);
object::transfer(creator, create_token_object, user_addr);
}
```
In the example above, we use data from `MovementCollection` via borrow_global at a specific
owner address. This will be a parameter because we can have multiple collections, and users
can choose to mint_nft from any Collection.
```rust
let movement_collection = borrow_global_mut<MovementCollection>(owner);
let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
```
Finally, we'll initialize the NFT and transfer it to the owner using `extend_ref`:
```rust
let create_token_object = aptos_token::mint_token_object(
creator,
movement_collection.collection_name,
utf8(b"Token Movement Description"),
utf8(b"Token Movement Name"),
utf8(b"Token URI"),
vector[],
vector[],
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

vector[]
);
object::transfer(creator, create_token_object, user_addr);
```
### FullCode
```rust
module movement::nft_aptos_collection {
use aptos_token_objects::aptos_token::{Self, AptosToken, AptosCollection};
use aptos_token_objects::token;
use aptos_token_objects::collection::{Self,Collection};
use aptos_token_objects::property_map;
use aptos_framework::object::{Self, Object, ExtendRef, ObjectCore};
use std::signer;
use std::table;
use std::option;
use std::string::{utf8, String};
use std::event;
use std::vector;
const COLLECTION_NAME: vector<u8> = b"Movement NFT";
const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
const COLLECTION_URI: vector<u8> = b"https://movementlabs.xyz/image.png";
struct CollectionManager has key {
extend_ref: ExtendRef
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
struct MovementCollection has key {
collection_object: Object<AptosCollection>,
collection_address: address,
collection_name: String,
minting_enabled: bool,
mint_fee: u64,
minted_nfts: table::Table<address, vector<address>>,
extend_ref: ExtendRef
}
#[event]
struct CreateMovementCollectionEvents has drop, store {
collection_address: address,
collection_name: String,
owner: address
}
fun init_module(creator: &signer) {
let creator_constructor_ref = &object::create_object(@movement);
let extend_ref = object::generate_extend_ref(creator_constructor_ref);
move_to(creator, CollectionManager {
extend_ref
})
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

public entry fun create_movement_collection(admin: &signer) {
let admin_addr = signer::address_of(admin);
assert!(!exists<MovementCollection>(admin_addr), 0);
let creator_constructor_ref = &object::create_object(admin_addr);
let extend_ref = object::generate_extend_ref(creator_constructor_ref);
let creator = &object::generate_signer_for_extending(&extend_ref);
let collection_object = aptos_token::create_collection_object(
creator,
// Creator
utf8(COLLECTION_DESCRIPTION),
// Desciprtion
1000,
// Max Supply
utf8(COLLECTION_NAME),
// Collection Name
utf8(COLLECTION_URI),
// Collection Uri
true,
// mutable_description
true,
// mutable_royalty
true,
// mutable_uri
true,
// mutable_token_description
true,
// mutable_token_name
true,
// mutable_token_properties
true,
// mutable_token_uri
true,
// tokens_burnable_by_creator
true,
// tokens_freezable_by_creator
0,
// royalty_numerator
100,
// royatly_denominator
);

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let collection_address = object::create_object_address(&admin_addr,
COLLECTION_NAME);
move_to(admin, MovementCollection {
collection_object,
collection_address,
collection_name: utf8(COLLECTION_NAME),
minting_enabled: true,
mint_fee: 0,
minted_nfts: table::new(),
extend_ref
});
event::emit(CreateMovementCollectionEvents {
collection_address,
collection_name: utf8(COLLECTION_NAME),
owner: admin_addr
});
}
#[view]
public fun get_collection_object_address(owner: address): address acquires
MovementCollection {
let movement_collection = borrow_global<MovementCollection>(owner);
object::create_object_address(&owner, COLLECTION_NAME)
}
public entry fun mint_nft(user: &signer, owner: address) acquires MovementCollection {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

let user_addr = signer::address_of(user);
let movement_collection = borrow_global_mut<MovementCollection>(owner);
let creator = &object::generate_signer_for_extending(&movement_collection.extend_ref);
if (!table::contains(&movement_collection.minted_nfts, user_addr)) {
table::add(&mut movement_collection.minted_nfts, user_addr,
vector::empty<address>());
};
let nft_minted = table::borrow_mut(&mut movement_collection.minted_nfts, user_addr);
let create_token_object = aptos_token::mint_token_object(
creator,
movement_collection.collection_name,
utf8(b"Token Movement Description"),
utf8(b"Token Movement Name"),
utf8(b"Token URI"),
vector[],
vector[],
vector[]
);
let token_address = object::create_object_address(&user_addr, COLLECTION_NAME);
vector::push_back(nft_minted, token_address);
object::transfer(creator, create_token_object, user_addr);
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

}
#[view]
public fun get_token_object_address(owner: address): vector<address> acquires
MovementCollection {
let movement_collection = borrow_global<MovementCollection>(owner);
*table::borrow(&movement_collection.minted_nfts, owner)
}
}
```
# Aptos Collection & Token V2
## Summary
- Aptos Collection & Token V2 provides enhanced customization and standardization for NFTs
on the Aptos blockchain.
- The `aptos_token_objects::aptos_token` module offers a standardized approach for creating
collections and tokens.
- Aptos Collections are created with two resources: `Collection` and `AptosCollection`, allowing
for various customizable attributes.
- Aptos Tokens automatically generate ability options for mutator, burn, and transfer operations,
simplifying the token creation process.
- The `AptosToken` object provides built-in functionality for burning, transferring, and mutating
tokens without manual setup.
- This approach offers greater flexibility and ease of use compared to manual initialization with
`aptos_token_objects::token`.

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

## Overview
With the use of `use aptos_token_objects::token` to initialize tokens, or using `use
aptos_token_objects::collection` and `collection::create_fixed_collection` to initialize collections,
these are Tokens that you can customize according to your preferences. However, with
`aptos_framework`, they also provide you with another standard to standardize `aptos_tokens`
(token v2), making synchronization in common cases easier through
`aptos_token_objects::aptos_token`
When initializing with `collection::create_fixed_collection`, we will create an object called
Collection, but when you initialize an Aptos Collection through the function
`aptos_tokens::create_collection`, you will receive 2 resources including:
```rust
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Collection has key {
creator: address,
description: String,
name: String,
uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosCollection has key {
mutator_ref: Option<collection::MutatorRef>,
royalty_mutator_ref: Option<royalty::MutatorRef>,
mutable_description: bool,
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

mutable_uri: bool,
mutable_token_description: bool,
mutable_token_name: bool,
mutable_token_properties: bool,
mutable_token_uri: bool,
tokens_burnable_by_creator: bool,
tokens_freezable_by_creator: bool,
}
```
For example, when using the `aptos_token::create_collection` function:
```rust
module movement::nft_aptos_collection {
use aptos_token_objects::aptos_token;
use std::string;
const COLLECTION_NAME: vector<u8> = b"Movement NFT";
const COLLECTION_DESCRIPTION: vector<u8> = b"Movement NFT Descriprtion";
fun init_module(caller: &signer) {
aptos_token::create_collection(
caller,
// Creator
string::utf8(b"Move Spiders are awesome"), // Collection Description
1000,
// Max Supply
string::utf8(b"Move Spiders"),
// Collection Name
string::utf8(b"https://movementlabs.xyz"), // Collection URI
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

true,
true,
true,
true,
true,
true,
true,
true,
true,
0,
100,

// mutable_description
// mutable_royalty
// mutable_uri
// mutable_token_description
// mutable_token_name
// mutable_token_properties
// mutable_token_uri
// tokens_burnable_by_creator
// tokens_freezable_by_creator
// royalty_numerator
// royatly_denominator

);
}
}
```
Here you can see that with `aptos_collection`, you can easily customize various `ability`
settings. These include options to modify internal fields of the `token`, such as `description`,
`royalty`, `uri`, and more.
## Aptos Tokens
Similar to Aptos Collection, aptos_token also provides a Mint function based on the
`AptosCollection` you've previously created. This function is akin to create_token in
`aptos_token_objects::token`, but with a key difference: it automatically generates various
`ability` options for `mutator`, `burn`, or `transfer` operations. This eliminates the need for
manual setup as we did before.
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

When using `aptos_token::mint`, we not only create a `Token` object but also an additional
object called `AptosToken`:
```rust
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Token has key {
collection: Object<Collection>,
description: String,
name: String,
uri: String,
}
#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct AptosToken has key {
burn_ref: Option<token::BurnRef>,
transfer_ref: Option<object::TransferRef>,
mutator_ref: Option<token::MutatorRef>,
property_mutator_ref: property_map::MutatorRef,
}
```
With AptosToken already initialized and using the `ability` options you need without manual
initialization as when using `aptos_token_objects::token`
```rust
fun create_movement_token(caller: &signer) {
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

aptos_token::mint(
caller,
// creator
string::utf8(COLLECTION_NAME),
// collection name
string::utf8(b"Movement Token description"), // token description
string::utf8(b"Movement Token"),
// token name
string::utf8(b"https://movementlabs.xyz"), // token uri
vector[],
// property_keys
vector[],
// property_types
vector[],
// property_values
)
}
```
{
"Movement CLI": {
"title": "Movement CLI",
"description": "CLI tool for compiling, testing, and deploying Move Contracts",
"link": "https://docs.movementnetwork.xyz/devs/movementcli",
"tags": [
"cli",
"contracts"
]
},
"Aptos TS SDK": {
"title": "Aptos TS SDK",
"description": "Typescript SDK for interacting with Aptos Move based chains like Movement
Network.",
"link": "https://aptos.dev/en/build/sdks/ts-sdk",
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

"tags": [
"sdk",
"frontend"
]
},
"Razer Wallet Kit": {
"title": "Razor Wallet Kit",
"description": "A wallet adaptor for DApps to interact with all the wallets in Movement
ecosystem easily",
"link": "https://kit.razorwallet.xyz/",
"tags": [
"sdk",
"frontend",
"wallet"
]
},
"Nightly Connect": {
"title": "Nightly Connect",
"description": "Nightly Connect is a permissionless, open-source solution that serves as both
a wallet adapter and a bridge wallet, enabling connections through QR codes or deep links.",
"link": "https://connect.nightly.app/docs/movement/movement/start",
"tags": [
"sdk",
"frontend",
"wallet"
]
},
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

"Scaffold Move": {
"title": "Scaffold Move",
"description": "Scaffold Move is an open-source, cutting-edge toolkit for building decentralized
applications (dApps) on Move Based Blockchains.",
"link": "https://scaffold-move-chi.vercel.app/",
"tags": [
"fullstack",
"contracts"
]
},
"Lync Infrastructure Tools": {
"title": "Lync Infrastructure Tools",
"description": "Lync provides a suite of tools for helping speed up the development process
on Movement Network, this includes Indexers, NFT Deployers, Social Login SDK's, Unity SDK,
as well as Wallet Creation and Transaction APIs.",
"link": "https://docs.lync.world/movement-labs/",
"tags": [
"fullstack",
"contracts",
"indexer",
"sdk"
]
},
"Pyth": {
"title": "Pyth",
"description": "Pyth Network is an oracle protocol that connects the owners of market data to
applications on multiple blockchains.",
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

"link": "https://docs.pyth.network/home",
"tags": [
"oracle",
"price feeds"
]
},
"Move On Aptos": {
"title": "Move On Aptos",
"description": "A powerful IntelliJ plugin that enhances Move development with features like
syntax highlighting, navigation and search, code formatting, code analysis, rename refactoring,
and imports integration using the Aptos Move framework.",
"link": "https://plugins.jetbrains.com/plugin/14721-move-on-aptos",
"tags": [
"plugin",
"intellij",
"development",
"aptos"
]
},
"Move Language": {
"title": "Move Language Extension for VSCode",
"description": "Built by developers for developers, this extension will simplify your Move
development and will make your first experience with Move less painful.",
"link":
"https://marketplace.visualstudio.com/items?itemName=PontemNetwork.move-language",
"tags": [
"extension",
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

"vscode",
"development"
]
},
"Mosaic Swap Widget": {
"title": "Mosaic Swap Widget",
"description": "The Swap Widget bundles the whole swapping experience into a single React
component that developers can easily embed in their app with a few lines of code.",
"link": "https://www.npmjs.com/package/@mosaicag/swap-widget",
"tags": ["sdk", "frontend", "widget"]
},
"Mosaic Gas Station": {
"title": "Mosaic Gas Station",
"description": "Movement Gas Station is a simple and efficient solution for transaction
sponsorship on the Movement network. It allows dApp developers to easily cover gas fees for
their users, enhancing user experience and reducing barriers to entry.",
"link": "https://github.com/kitelabs-io/mvmt-gas-station",
"tags": ["contracts"]
},
"Mosaic Token Utils": {
"title": "Mosaic Token Utils",
"description": "Helper to query the balance of multiple fa and coins without indexer.",
"link": "https://github.com/kitelabs-io/mvmt-token-utils",
"tags": ["contracts"]
},
"Mosaic Token List": {
"title": "Mosaic Token List",
{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

"description": "Mosaic's Movement Token List is the go-to categorized catalog for both
legacy coins and Fungible Assets tradeable on the Movement chain",
"link": "https://github.com/kitelabs-io/mvmt-tokens",
"tags": ["tokens"]
}
}

{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",
"amt": "23m",
"link":"https://youtu.be/i8iYgcjrtJk",
"tags": ["Contract", "Code Review"],
"featured": true
},
"Solidity vs Move" : {
"category": "Beginner",
"title": "Solidity vs Move",
"description": "Learn the differences between the Solidity and Move languages and start
exploring the security enhancements and developer environment provided by Move.",
"amt": "23m",
"link":"https{
"Onchain Twitter Clone" : {
"category": "Beginner",
"title": "Onchain Twitter Clone",
"description": "Learn the basics of Move by reviewing a module for an onchain Twitter Clone",

